<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TypeScript学习笔记（高级篇</title>
    <link href="undefined2020/04/ts3/"/>
    <url>2020/04/ts3/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript高级"><a href="#TypeScript高级" class="headerlink" title="TypeScript高级"></a>TypeScript高级</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起个新名字。</p><pre><code class="ts">type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name {    if (typeof n === &#39;string&#39;) {        return n;    } else {        return n();    }}</code></pre><p>上例中，我们使用 <code>type</code> 创建类型别名。</p><blockquote><p>类型别名常用于联合类型。</p></blockquote><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><pre><code class="ts">type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 报错，event 不能为 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><blockquote><p>注意，类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</p></blockquote><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>定义一对值分别为 <code>string</code> 和 <code>number</code> 的元组</p><pre><code class="ts">let tom: [string, number] = [&#39;Tom&#39;, 25];let tom2: [string, number]tom2[0] = &#39;Tom&#39;  // 直接赋值会在node和浏览器中报错，但是ts不会报错tom2[1] = 1 // 可以对它赋值，也可以不赋值，不会报错tom2[1] = &#39;tox&#39; // 这个地方就会报错，因为指定了是numbertom2 = [&#39;Tom&#39;] // 会报错，因为整体赋值必须要符合定义tom2.push(&#39;d&#39;) // 新加入得元素只要符合tom2.push(1)let tom3: any = [] // 经测试正常还是用这个把</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p><pre><code class="ts">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};</code></pre><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p><pre><code class="ts">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true// 会被编译为var Days;(function (Days) {    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;})(Days || (Days = {}));</code></pre><p><strong>手动赋值</strong></p><pre><code class="ts">enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 7); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // true</code></pre><blockquote><p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的，小心被覆盖<br>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1</p></blockquote><p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)</p><pre><code class="ts">enum Days {Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;};</code></pre><p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p><pre><code class="ts">enum Color {Red, Green, Blue = &quot;blue&quot;.length};  // &quot;blue&quot;.length 就是一个计算所得项。</code></pre><p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项</strong>，那么它就会因为无法获得初始值而报错</p><p><strong>常数枚举</strong></p><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p><p><strong>外部枚举</strong></p><p>是使用 <code>declare enum</code> 定义的枚举类型</p><blockquote><p>同时使用 declare 和 const 也是可以的</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>TypeScript</strong> 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><p><strong>TypeScript</strong> 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public、private</code> 和 <code>protected</code>。</p><p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化</p><p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承</p><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁</p><pre><code class="ts">class Animal {    // public name: string;    public constructor (public name) {        // this.name = name;    }}class Animal {    readonly name;    public constructor(name) {        this.name = name;    }}a.name = &#39;Tom&#39;; //会报错</code></pre><blockquote><p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法</p><p>首先，抽象类是不允许被实例化的</p><p>其次，抽象类中的抽象方法必须被子类实现</p><pre><code class="ts">abstract class Animal {    public name;    public constructor(name) {        this.name = name;    }    public abstract sayHi();}class Cat extends Animal {    public sayHi() {        console.log(`Hello`);    }}let animal =  new Animal(&#39;dd&#39;) // 会报错，抽象类不能被实例化let cat = new Cat(&#39;dd&#39;)  // ok</code></pre><blockquote><p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类</p></blockquote><h3 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h3><p>给类加上 TypeScript 的类型很简单，与接口类似</p><pre><code class="ts">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    sayHi(): string {      return `My name is ${this.name}`;    }}let a: Animal = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><p>接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。</p><p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p><h3 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h3><p>实现（<code>implements</code>）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它</p><p>一个类可以实现多个接口</p><pre><code class="ts">interface Alarm {    alert(): void;}interface Light {    lightOn(): void;    lightOff(): void;}class Door {}class SecurityDoor extends Door implements Alarm {    alert() {        console.log(&#39;SecurityDoor alert&#39;);    }}class Car implements Alarm, Light {    alert() {        console.log(&#39;Car alert&#39;);    }    lightOn() {        console.log(&#39;Car light on&#39;);    }    lightOff() {        console.log(&#39;Car light off&#39;);    }}</code></pre><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><pre><code class="ts">interface Alarm {    alert(): void;}interface LightableAlarm extends Alarm {    lightOn(): void;    lightOff(): void;}</code></pre><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><pre><code class="ts">class Point {    x: number;    y: number;    constructor(x: number, y: number) {        this.x = x;        this.y = y;    }}interface Point3d extends Point {    z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3};</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><pre><code class="ts">function createArray(length: number, value: any): Array&lt;any&gt; {    let result = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray&lt;string&gt;(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><pre><code class="ts">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {    return [tuple[1], tuple[0]];}swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]</code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</p><pre><code class="ts">interface Lengthwise {    length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {    console.log(arg.length);    return arg;}</code></pre><p>上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。</p><p>此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了</p><p>多个类型参数之间也可以互相约束</p><pre><code class="ts">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T {    for (let id in source) {        target[id] = (&lt;T&gt;source)[id];    }    return target;}let x = { a: 1, b: 2, c: 3, d: 4 };copyFields(x, { b: 10, d: 20 });</code></pre><p>上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code class="ts">interface CreateArrayFunc&lt;T&gt; {    (length: number, value: T): Array&lt;T&gt;;}let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><h3 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><pre><code class="ts">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}</code></pre><h2 id="声明的合并"><a href="#声明的合并" class="headerlink" title="声明的合并"></a>声明的合并</h2><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</p><h3 id="函数的合并"><a href="#函数的合并" class="headerlink" title="函数的合并"></a>函数的合并</h3><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string {    if (typeof x === &#39;number&#39;) {        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    } else if (typeof x === &#39;string&#39;) {        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);    }}</code></pre><h3 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h3><pre><code class="ts">interface Alarm {    price: number;}interface Alarm {    weight: number;}// 相当于interface Alarm {    price: number;    weight: number;}</code></pre><blockquote><p>合并的属性的类型必须是唯一的</p></blockquote><p>接口中方法的合并，与函数的合并一样</p><pre><code class="ts">interface Alarm {    price: number;    alert(s: string): string;}interface Alarm {    weight: number;    alert(s: string, n: number): string;}// 相当于interface Alarm {    price: number;    weight: number;    alert(s: string): string;    alert(s: string, n: number): string;}</code></pre><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://ts.xcatliu.com/advanced/further-reading" target="_blank" rel="noopener">索引链接</a></p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>高级1</tag>
      
      <tag>每日一更</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（基础篇2</title>
    <link href="undefined2020/04/ts2/"/>
    <url>2020/04/ts2/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数声明定义</p><pre><code class="ts">function sum(x: number, y: number): number {  return x + y;}</code></pre><blockquote><p>输入多余的（或者少于要求的）参数，是不被允许的</p></blockquote></li><li><p>函数表达式定义</p><pre><code class="ts">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {  return x + y;};</code></pre><blockquote><p>注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。<br>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。<br>在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。</p></blockquote></li><li><p>用接口定义函数的形状</p><pre><code class="ts">interface SearchFunc {  (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {  return source.search(subString) !== -1;}</code></pre><blockquote><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p></blockquote></li><li><p>可选参数<br>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数</p><pre><code class="ts">function buildName(firstName: string, lastName?: string) {  if (lastName) {      return firstName + &#39; &#39; + lastName;  } else {      return firstName;  }}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);</code></pre><blockquote><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了</p></blockquote></li><li><p>参数默认值<br>TypeScript 会将添加了默认值的参数识别为可选参数</p><pre><code class="ts">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {  return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);</code></pre><blockquote><p>此时就不受「可选参数必须接在必需参数后面」的限制了</p></blockquote></li><li><p>剩余参数<br>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）</p></li></ul><p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它</p><pre><code class="ts">function push(array: any[], ...items: any[]) {    items.forEach(function(item) {        array.push(item);    });}let a = [];push(a, 1, 2, 3);</code></pre><blockquote><p>rest 参数只能是最后一个参数</p></blockquote><ul><li>重载</li></ul><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。</p><p>利用联合类型，我们可以这么实现：</p><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string {    if (typeof x === &#39;number&#39;) {        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    } else if (typeof x === &#39;string&#39;) {        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);    }}</code></pre><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p><blockquote><p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p></blockquote><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>使用 <code>值</code> as <code>类型</code> 的语法</p><pre><code class="ts">interface Cat {    name: string;    run(): void;}interface Fish {    name: string;    swim(): void;}function isFish(animal: Cat | Fish) {    if (typeof animal.swim === &#39;function&#39;) {  // 会报错，因为swim不是Cat和Fish的共有属性        return true;    }    return false;}function isFish(animal: Cat | Fish) {    if (typeof (animal as Fish).swim === &#39;function&#39;) { // 使用断言，避免错误        return true;    }    return false;}</code></pre><blockquote><p>类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误</p></blockquote><pre><code class="ts">window.foo = 1; // 直接赋值会提示你window上边没有foo属性(window as any).foo = 1; // 把window断言成一个any就可以随便赋值了</code></pre><ul><li>总结</li></ul><p>联合类型可以被断言为其中一个类型</p><p>父类可以被断言为子类</p><p>任何类型都可以被断言为 any</p><p>any 可以被断言为任何类型</p><p>要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可</p><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p><p>声明文件必需以 <code>.d.ts</code> 为后缀。</p><pre><code class="ts">// src/jQuery.d.tsdeclare var jQuery: (selector: string) =&gt; any;</code></pre><blockquote><p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files、include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p></blockquote><h2 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h2><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。</p><p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p><p><code>@types</code> 的使用方式很简单，直接用 <code>npm</code> 安装对应的声明模块即可，以 <code>jQuery</code> 举例</p><pre><code class="cmd">cnpm install @types/jquery --save-dev</code></pre><p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个页面</a>搜索你需要的声明文件。</p><h2 id="书写声明文件"><a href="#书写声明文件" class="headerlink" title="书写声明文件"></a>书写声明文件</h2><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p><ul><li>全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>npm包<a href="https://ts.xcatliu.com/basics/declaration-files#npm-bao" target="_blank" rel="noopener">教程链接</a></li><li>UMD库<a href="https://ts.xcatliu.com/basics/declaration-files#umd-ku" target="_blank" rel="noopener">教程链接</a></li><li>直接扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#zhi-jie-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>在 npm 包或 UMD 库中扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>模块插件<a href="https://ts.xcatliu.com/basics/declaration-files#mo-kuai-cha-jian" target="_blank" rel="noopener">教程链接</a></li><li>声明文件中的依赖<a href="https://ts.xcatliu.com/basics/declaration-files#sheng-ming-wen-jian-zhong-de-yi-lai" target="_blank" rel="noopener">教程链接</a></li><li>自动生成声明文件<a href="https://ts.xcatliu.com/basics/declaration-files#zi-dong-sheng-cheng-sheng-ming-wen-jian" target="_blank" rel="noopener">教程链接</a></li></ul><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>ECMAScript 标准提供的内置对象有：<code>Boolean、Error、Date、RegExp</code> 等。</p><pre><code class="ts">let b: Boolean = new Boolean(1);let e: Error = new Error(&#39;Error occurred&#39;);let d: Date = new Date();let r: RegExp = /[a-z]/;</code></pre><blockquote><p>更多的内置对象，可以查看 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">文档</a>。</p></blockquote><h2 id="DOM-和-BOM-的内置对象"><a href="#DOM-和-BOM-的内置对象" class="headerlink" title="DOM 和 BOM 的内置对象"></a>DOM 和 BOM 的内置对象</h2><p>DOM 和 BOM 提供的内置对象有：<code>Document、HTMLElement、Event、NodeList</code> 等。</p><pre><code class="ts">let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&#39;div&#39;);document.addEventListener(&#39;click&#39;, function(e: MouseEvent) {  // Do something});</code></pre><h2 id="用-TypeScript-写-Node-js"><a href="#用-TypeScript-写-Node-js" class="headerlink" title="用 TypeScript 写 Node.js"></a>用 TypeScript 写 Node.js</h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p><pre><code class="cmd">npm install @types/node --save-dev</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>基础2</tag>
      
      <tag>每日一更</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（基础篇1</title>
    <link href="undefined2020/04/ts1/"/>
    <url>2020/04/ts1/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>cnpm install -g typescript</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><pre><code>tsc hello.ts</code></pre><blockquote><p>我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>TypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以。</p><blockquote><p>TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。<br>如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json，请参阅<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html" target="_blank" rel="noopener">官方手册</a></p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。</p><p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>boolean</code></p><pre><code class="ts">let isDone: boolean = false;</code></pre><p>注意，使用构造函数 <strong>Boolean</strong> 创造的对象不是布尔值：</p><pre><code class="ts">let createdByNewBoolean: boolean = new Boolean(1); // 会报错的，是一个Boolean对象let createdByNewBoolean: boolean = Boolean(1); // 通过，是一个boolean</code></pre><blockquote><p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p></blockquote><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p><code>number</code></p><pre><code class="ts">let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;</code></pre><blockquote><p>编译完会自动转成十进制</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>string</code></p><pre><code class="ts">let myName: string = &#39;Tom&#39;;let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is ${myName}.I&#39;ll be ${myAge + 1} years old next month.`;</code></pre><blockquote><p>编译完模板字符串会变成加号串联的形式，自动加<code>/n</code></p></blockquote><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p><code>void</code></p><p><strong>JavaScript</strong> 没有空值（Void）的概念，在 <strong>TypeScript</strong> 中，可以用 <code>void</code> 表示没有任何返回值的函数：</p><pre><code class="ts">function alertName(): void {    alert(&#39;My name is Tom&#39;);}</code></pre><blockquote><p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code></p></blockquote><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p><code>null undefined</code></p><pre><code class="ts">let u: undefined = undefined;let n: null = null;</code></pre><blockquote><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给其他类型的变量，但是反过来 <code>void</code> 不能赋值给任何类型的变量</p></blockquote><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p><code>any</code><br>如果是一个普通类型，在赋值中改变类型是不被允许的。</p><p>但是如果是<code>any</code>类型，则允许被赋值为任意类型</p><pre><code class="ts">let myFavoriteNumber: any = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><blockquote><p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p></blockquote><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</p><pre><code class="ts">let something;something = &#39;seven&#39;;something = 7;something.setName(&#39;Tom&#39;);</code></pre><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果变量在定义的时候赋值，但是没指定类型，会自动进行推论</p><pre><code class="ts">let myFavoriteNumber = &#39;seven&#39;;// 等价于let myFavoriteNumber: string = &#39;seven&#39;;myFavoriteNumber = 7; // 会报错</code></pre><blockquote><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查：</p></blockquote><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型使用 | 分隔每个类型。</p><pre><code class="ts">let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;; // okmyFavoriteNumber = 7; // okmyFavoriteNumber = true; // 会报错</code></pre><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p><pre><code class="ts">function getLength(something: string | number): number {    return something.length; // 会报错，.length不是string和number共有的属性    return something.toString(); // ok}</code></pre><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p><pre><code class="ts">let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;;console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 会报错</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><pre><code class="ts">interface IPerson {    name: string;    age: number;}let tom: IPerson = {    name: &#39;Tom&#39;,    age: 25};</code></pre><p>接口一般首字母大写，有的编程语言会建议接口的名称加上<code>I</code>前缀</p><p>定义的变量比接口多属性少属性都是不允许的，<strong>赋值的时候，变量的形状必须和接口的形状保持一致。</strong></p><ul><li>可选属性</li></ul><p><strong>可选属性的含义是该属性可以不存在</strong>，这时<strong>仍然不允许添加未定义的属性</strong></p><pre><code class="ts">interface Person {    name: string;    age?: number;}let tom: Person = {    name: &#39;Tom&#39;,    gender: &#39;male&#39; // 这句就会报错，因为出现了未加定义的属性};</code></pre><ul><li>任意属性</li></ul><p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是<strong>它的类型的子集</strong></p><pre><code class="ts">interface Person {    name: string;    age?: number;    [propName: string]: string;}let tom: Person = {    name: &#39;Tom&#39;,    age: 25, // 这句就会报错，因为不是string，即使上边定义age是number也不行    gender: &#39;male&#39;,};interface Person {    name: string;    age?: number;    [propName: string]: string | number; // 接口定义成这样使用联合类型age就不会报错了}</code></pre><ul><li>只读属性</li></ul><p>一些字段只能在创建的时候被赋值</p><pre><code class="ts">interface Person {    readonly id: number;    name: string;    age?: number;    [propName: string]: any;}let tom: Person = {    id: 89757,    name: &#39;Tom&#39;,    gender: &#39;male&#39;};tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre><blockquote><p>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</p></blockquote><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><ul><li><p>「类型 + 方括号」表示法</p><pre><code class="ts">let fibonacci: number[] = [1, 1, 2, 3, 5];</code></pre><blockquote><p>数组的项中<strong>不允许</strong>出现其他的类型<br>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制,如果约定是<code>number</code>类型,<strong>push</strong>一个<code>string</code>类型就会报错</p></blockquote></li><li><p>数组泛型</p><pre><code class="ts">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre></li><li><p>用接口表示数组<br><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p><pre><code class="ts">interface NumberArray {  [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre></li><li><p>类数组<br>类数组（Array-like Object）不是数组类型，比如 arguments：</p><pre><code class="ts">function sum() {  let args: {      [index: number]: number;      length: number;      callee: Function;  } = arguments;}</code></pre></li><li><p>any 在数组中的应用<br>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p><pre><code class="ts">let list: any[] = [&#39;xcatliu&#39;, 25, { website: &#39;http://xcatliu.com&#39; }];</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>基础1</tag>
      
      <tag>每日一更</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa学习笔记</title>
    <link href="undefined2020/04/js-koa/"/>
    <url>2020/04/js-koa/</url>
    
    <content type="html"><![CDATA[<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>cnpm install koa --save</code></pre><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h2><pre><code class="js">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use(async ctx =&gt; {  ctx.body = &#39;Hello World&#39;;});app.listen(3000);</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>使用yield以及next,当一个中间件调用<code>next()</code>函数时，函数挂起并控件传递给定义的下一个中间件。在没有更多的中间件执行下游之后，堆栈将退出，并且每个中间件被恢复以执行其上游行为。</p><pre><code class="js">const Koa = require(&#39;koa&#39;);const app = new Koa();const one = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; one&#39;);  next();  console.log(&#39;&lt;&lt; one&#39;);}const two = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; two&#39;);  next();  console.log(&#39;&lt;&lt; two&#39;);}const three = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; three&#39;);  next();  console.log(&#39;&lt;&lt; three&#39;);}app.use(one);app.use(two);app.use(three);app.listen(3000);/*&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one*/</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>应用配置是 app 实例属性，目前支持的配置项如下</p><ul><li>app.env node运行环境，默认为 NODE_ENV or “development”</li><li>app.proxy 表示是否开启代理信任开关,默认为false，如果为 true，则解析 “Host” 的 header 域，对于获取request请求中的host，protocol，ip分别优先从Header字段中的<a href="https://cloud.tencent.com/developer/section/1190030" target="_blank" rel="noopener">X-Forwarded-Host</a>，X-Forwarded-Proto，X-Forwarded-For获取</li><li>app.subdomainOffset 表示子域名是从第几级开始的，这个参数决定了request.subdomains的返回结果，默认值为2，表示 .subdomains 所忽略的字符偏移量。<pre><code class="js">//比如有netease.youdata.163.com域名app.subdomainOffset = 2;console.log(ctx.request.subdomains);  //返回[&quot;youdata&quot;, &quot;netease&quot;]app.subdomainOffset = 3;console.log(ctx.request.subdomains);  //返回[&quot;netease&quot;]//koa获取subdomains的源码get subdomains() {    const offset = this.app.subdomainOffset;    const hostname = this.hostname;    if (net.isIP(hostname)) return [];    return hostname    .split(&#39;.&#39;)    .reverse()    .slice(offset);}</code></pre></li></ul><h2 id="app-listen-…"><a href="#app-listen-…" class="headerlink" title="app.listen(…)"></a>app.listen(…)</h2><p><code>app.listen(...)</code> 实际上是以下代码的语法糖</p><pre><code class="js">http.createServer(app.callback()).listen(3000);</code></pre><p>这意味着您可以同时支持 <strong>HTTP</strong> 和 <strong>HTTPS</strong>，或者在多个端口监听同一个应用</p><pre><code class="js">const http = require(&#39;http&#39;);const https = require(&#39;https&#39;);const Koa = require(&#39;koa&#39;);const app = new Koa();http.createServer(app.callback()).listen(3000);https.createServer(app.callback()).listen(3001);</code></pre><h2 id="app-callback"><a href="#app-callback" class="headerlink" title="app.callback()"></a>app.callback()</h2><p>返回一个适合 <code>http.createServer()</code> 方法的回调函数用来处理请求。 您也可以使用这个回调函数将您的app挂载在 Connect/Express 应用上。</p><pre><code class="js">//koa的callback函数实现源码function callback() {      const fn = compose(this.middleware);   //koa-compose包负责将多个中间件组装成一个中间件  if (!this.listeners(&#39;error&#39;).length) this.on(&#39;error&#39;, this.onerror);      const handleRequest = (req, res) =&gt; {          const ctx = this.createContext(req, res);  //这个函数负责生成中间件接收器ctx，绑定一些对象的关联关系      return this.handleRequest(ctx, fn);  //使用中间件函数fn处理路由请求    };        return handleRequest;  }  //handleRequest函数的源码实现也很简单，执行中间件函数，并做一些返回处理和异常处理  function handleRequest(ctx, fnMiddleware) {        const res = ctx.res;    res.statusCode = 404;        const onerror = err =&gt; ctx.onerror(err);        const handleResponse = () =&gt; respond(ctx);    onFinished(res, onerror);        return fnMiddleware(ctx).then(handleResponse).catch(onerror);  }</code></pre><h2 id="app-use-function"><a href="#app-use-function" class="headerlink" title="app.use(function)"></a>app.use(function)</h2><p>use函数主要作用是给app.middleware数组中添加中间件</p><h2 id="app-keys"><a href="#app-keys" class="headerlink" title="app.keys="></a>app.keys=</h2><p>该密钥会被传递给KeyGrip, 当然，您也可以自己生成 KeyGrip. 例如:</p><pre><code class="js">app.keys = [&#39;im a newer secret&#39;, &#39;i like turtle&#39;];app.keys = new KeyGrip([&#39;im a newer secret&#39;, &#39;i like turtle&#39;], &#39;sha256&#39;);</code></pre><p>在进行cookie签名时，只有设置 signed 为 true 的时候，才会使用密钥进行加密：</p><pre><code class="js">ctx.cookies.set(&#39;name&#39;, &#39;tobi&#39;, { signed: true });</code></pre><h2 id="app-context"><a href="#app-context" class="headerlink" title="app.context"></a>app.context</h2><p>app.context是从中创建ctx的原型。 可以通过编辑app.context向ctx添加其他属性。当需要将ctx添加到整个应用程序中使用的属性或方法时，这将会非常有用。这可能会更加有效（不需要中间件）和/或更简单（更少的require()），而不必担心更多的依赖于ctx，这可以被看作是一种反向模式。</p><p>例如，从ctx中添加对数据库的引用：</p><pre><code class="js">app.context.db = db();app.use(async ctx =&gt; {  console.log(ctx.db);});</code></pre><blockquote><p>ctx上的很多属性是被限制的，在app.context只能通过使用Object.defineProperty()来编辑这些属性（不推荐）。可以在 <a href="https://github.com/koajs/koa/issues/652上查阅" target="_blank" rel="noopener">https://github.com/koajs/koa/issues/652上查阅</a><br>已安装的APP沿用父级的ctx和配置。因此，安装的应用程序只是一组中间件。</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>默认情况下Koa会将所有错误信息输出到 stderr， 除非 app.silent 是 true.当err.status是404或者err.expose时，默认错误处理程序也不会输出错误。要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个”错误”事件侦听器：</p><pre><code class="js">app.on(&#39;error&#39;, err =&gt; {  log.error(&#39;server error&#39;, err)});</code></pre><p>如果错误发生在 请求/响应 环节，并且其不能够响应客户端时，Contenxt 实例也会被传递到 error 事件监听器的回调函数里。</p><pre><code class="js">app.on(&#39;error&#39;, (err, ctx) =&gt; {  log.error(&#39;server error&#39;, err, ctx)});</code></pre><p>当发生错误但仍能够响应客户端时（比如没有数据写到socket中），Koa会返回一个500错误(Internal Server Error)。 无论哪种情况，Koa都会生成一个应用级别的错误信息，以便实现日志记录等目的。</p><h1 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context(上下文)"></a>Context(上下文)</h1><p>在每个<code>requset</code>请求中被创建，在中间件中作为接收器(receiver)来引用</p><pre><code class="js">app.use(async ctx =&gt; {  ctx; // is the Context  ctx.request; // is a koa Request  ctx.response; // is a koa Response});</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Context 详细的方法和访问器。</p><h3 id="ctx-req"><a href="#ctx-req" class="headerlink" title="ctx.req"></a>ctx.req</h3><p><strong>Node</strong> 的 request 对象。</p><h3 id="ctx-res"><a href="#ctx-res" class="headerlink" title="ctx.res"></a>ctx.res</h3><p><strong>Node</strong> 的 response 对象</p><blockquote><p>Koa 不支持 直接调用底层 res 进行响应处理。请避免使用以下 node 属性：<br>res.statusCode<br>res.writeHead()<br>res.write()<br>res.end()</p></blockquote><h3 id="ctx-request"><a href="#ctx-request" class="headerlink" title="ctx.request"></a>ctx.request</h3><p><strong>Koa</strong> 的 Request 对象。</p><h3 id="ctx-response"><a href="#ctx-response" class="headerlink" title="ctx.response"></a>ctx.response</h3><p><strong>Koa</strong> 的 Response 对象。</p><h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>推荐的命名空间，用于通过中间件传递信息到前端视图<code>ctx.state.user = await User.find(id);</code></p><h3 id="ctx-app"><a href="#ctx-app" class="headerlink" title="ctx.app"></a>ctx.app</h3><p>应用实例引用。</p><h3 id="ctx-cookies-get-name-options"><a href="#ctx-cookies-get-name-options" class="headerlink" title="ctx.cookies.get(name, [options])"></a>ctx.cookies.get(name, [options])</h3><p>获得 <strong>cookie</strong> 中名为 <strong>name</strong> 的值，options 为可选参数;signed 如果为 true，表示请求时 cookie 需要进行签名。</p><blockquote><p>注意：Koa 使用了 Express 的 cookies 模块，options 参数只是简单地直接进行传递。</p></blockquote><h3 id="ctx-cookies-set-name-value-options"><a href="#ctx-cookies-set-name-value-options" class="headerlink" title="ctx.cookies.set(name, value, [options])"></a>ctx.cookies.set(name, value, [options])</h3><p>设置 cookie 中名为 name 的值，options 为可选参数：</p><ul><li>maxAge 一个数字，表示 Date.now()到期的毫秒数</li><li>signed 是否要做签名</li><li>expires cookie有效期</li><li>pathcookie 的路径，默认为 ‘/‘</li><li>domain cookie 的域</li><li>secure false 表示 cookie 通过 HTTP 协议发送，true 表示 cookie 通过 HTTPS 发送。</li><li>httpOnly true 表示 cookie 只能通过 HTTP 协议发送</li><li>overwrite 一个布尔值，表示是否覆盖以前设置的同名的Cookie（默认为false）。 如果为true，在设置此cookie时，将在同一请求中使用相同名称（不管路径或域）设置的所有Cookie将从Set-Cookie头部中过滤掉。</li></ul><h3 id="ctx-throw-status-msg-properties"><a href="#ctx-throw-status-msg-properties" class="headerlink" title="ctx.throw([status], [msg], [properties])"></a>ctx.throw([status], [msg], [properties])</h3><p>抛出包含 .status 属性的错误，默认为 500。该方法可以让 Koa 准确的响应处理状态。 Koa支持以下组合： </p><pre><code class="js">ctx.throw(400);ctx.throw(400, &#39;name required&#39;);ctx.throw(400, &#39;name required&#39;, { user: user });//该对象被合并到错误中，这对装饰机器友好错误非常有用，并且这些错误会被报给上层请求。</code></pre><p>this.throw(‘name required’, 400) 等价于：</p><pre><code class="js">const err = new Error(&#39;name required&#39;);err.status = 400;err.expose = true;throw err;</code></pre><blockquote><p>注意：这些用户级错误被标记为 err.expose，其意味着这些消息被准确描述为对客户端的响应，而并非使用在您不想泄露失败细节的场景中。</p></blockquote><h3 id="ctx-assert-value-status-msg-properties"><a href="#ctx-assert-value-status-msg-properties" class="headerlink" title="ctx.assert(value, [status], [msg], [properties])"></a>ctx.assert(value, [status], [msg], [properties])</h3><p>当!value时， Helper 方法抛出一个类似.throw()的错误。 类似node’s assert() 方法。 </p><pre><code class="js">ctx.assert(ctx.state.user, 401, &#39;User not found. Please login!&#39;);</code></pre><p>koa 使用 <a href="https://github.com/jshttp/http-assert" target="_blank" rel="noopener">http-assert</a> 来<a href="https://www.runoob.com/w3cnote/c-assert.html" target="_blank" rel="noopener">断言</a>。</p><h3 id="ctx-respond"><a href="#ctx-respond" class="headerlink" title="ctx.respond"></a>ctx.respond</h3><p>为了避免使用 Koa 的内置响应处理功能，您可以直接赋值 this.repond = false;。如果您不想让 Koa 来帮助您处理 reponse，而是直接操作原生 res 对象，那么请使用这种方法。</p><blockquote><p>注意： 这种方式是不被 Koa 支持的。其可能会破坏 Koa 中间件和 Koa 本身的一些功能。其只作为一种 hack 的方式，并只对那些想要在 Koa 方法和中间件中使用传统 fn(req, res) 方法的人来说会带来便利。</p></blockquote><h3 id="Request-aliases"><a href="#Request-aliases" class="headerlink" title="Request aliases"></a>Request aliases</h3><p>ctx会代理ctx.response和ctx.request上的一些属性和函数(这个代理逻辑是在ctx.response和ctx.request的原型上实现的)</p><pre><code class="js">//以下是koa源码（method表示代理方法，access表示代理属性可读可写，getter表示代理属性可读）：delegate(proto, &#39;response&#39;)  .method(&#39;attachment&#39;) //将Content-Disposition 设置为 “附件” 以指示客户端提示下载  .method(&#39;redirect&#39;) //返回重定向，如果没有code设置，默认设置code为302  /*    // 字符串 &quot;back&quot; 是一个特殊参数，其提供了 Referrer 支持。当没有Referrer时，使用 alt 或者 / 代替。    ctx.redirect(&#39;back&#39;);    ctx.redirect(&#39;back&#39;, &#39;/index.html&#39;);    ctx.redirect(&#39;/login&#39;);    ctx.redirect(&#39;http://google.com&#39;);  */  .method(&#39;remove&#39;)   //删除响应头的某个属性  .method(&#39;vary&#39;)  //设置Vary响应头  .method(&#39;set&#39;) //设置响应头，可以传递对象，数组，单个值的形式  .method(&#39;append&#39;) //给response.headers中的某个key值追加其它value  .method(&#39;flushHeaders&#39;)  //执行this.res.flushHeaders()  .access(&#39;status&#39;)  //http返回code码，优先选择用户的设置，如果用户没有主动设置，而设置了ctx.body的值， 如果设置值为null，则返回204，如果设置值不为null，那么返回200，否则默认情况下是404  .access(&#39;message&#39;)  //获取响应的状态消息. 默认情况下, response.message 与 response.status 关联  .access(&#39;body&#39;)   //response的返回结果  .access(&#39;length&#39;)  //response的headers的Content-Length，可以自己设置，默认根据body二进制大小设置  .access(&#39;type&#39;)   //设置响应的content-type  .access(&#39;lastModified&#39;)  //设置响应头Last-Modified  .access(&#39;etag&#39;)  //设置包含 &quot; 包裹的 ETag 响应头  .getter(&#39;headerSent&#39;)  //检查是否已经发送了一个响应头。 用于查看客户端是否可能会收到错误通知  .getter(&#39;writable&#39;);   //返回是否可以继续写入delegate(proto, &#39;request&#39;)  .method(&#39;acceptsLanguages&#39;)  .method(&#39;acceptsEncodings&#39;)  .method(&#39;acceptsCharsets&#39;)  .method(&#39;accepts&#39;)        //accepts函数用于判断客户端请求是否接受某种返回类型  .method(&#39;get&#39;)   //获取请求头中的某个属性值  .method(&#39;is&#39;)  //判断请求头希望返回什么类型  /*    检查请求所包含的 &quot;Content-Type&quot; 是否为给定的 type 值。 如果没有 request body，返回 undefined。 如果没有 content type，或者匹配失败，返回 false。 否则返回匹配的 content-type。    // With Content-Type: text/html; charset=utf-8    ctx.is(&#39;html&#39;); // =&gt; &#39;html&#39;    ctx.is(&#39;text/html&#39;); // =&gt; &#39;text/html&#39;    ctx.is(&#39;text/*&#39;, &#39;text/html&#39;); // =&gt; &#39;text/html&#39;    // When Content-Type is application/json    ctx.is(&#39;json&#39;, &#39;urlencoded&#39;); // =&gt; &#39;json&#39;    ctx.is(&#39;application/json&#39;); // =&gt; &#39;application/json&#39;    ctx.is(&#39;html&#39;, &#39;application/*&#39;); // =&gt; &#39;application/json&#39;    ctx.is(&#39;html&#39;); // =&gt; false    //比如说您希望保证只有图片发送给指定路由    if (ctx.is(&#39;image/*&#39;)) {      // process    } else {      ctx.throw(415, &#39;images only!&#39;);    }  */  .access(&#39;querystring&#39;) //获取原始查询字符串  .access(&#39;idempotent&#39;)  .access(&#39;socket&#39;) //返回请求套接字  .access(&#39;search&#39;) //搜索字符串  .access(&#39;method&#39;)  //请求方法  .access(&#39;query&#39;)  //获取请求的查询字符串对象  .access(&#39;path&#39;)  //获取请求路径名  .access(&#39;url&#39;)  //请求的url,该url可以被重写  .getter(&#39;origin&#39;)  //获取url的来源：包括 protocol 和 host（http://example.com）  .getter(&#39;href&#39;) //获取完整的请求URL，包括 protocol，host 和 url（http://example.com/foo/bar?q=1）  .getter(&#39;subdomains&#39;) //以数组形式返回子域名    /* 举例来说，如果域名是 &quot;tobi.ferrets.example.com&quot;:    如果没有设置 app.subdomainOffset，其 subdomains 为 [&quot;ferrets&quot;, &quot;tobi&quot;]。 如果设置 app.subdomainOffset 为3，其 subdomains 为 [&quot;tobi&quot;]  */  .getter(&#39;protocol&#39;) //返回请求协议  .getter(&#39;host&#39;) //获取当前主机的host(hostname:port)  .getter(&#39;hostname&#39;) //获取当前主机的host  .getter(&#39;URL&#39;) //获取 WHATWG 解析的 URL 对象  .getter(&#39;header&#39;) //返回请求头对象  .getter(&#39;headers&#39;)  //返回请求头对象  .getter(&#39;secure&#39;) //通过 ctx.protocol == &quot;https&quot; 来检查请求是否通过 TLS 发出  .getter(&#39;stale&#39;)   .getter(&#39;fresh&#39;) //检查请求缓存是否 &quot;fresh&quot;(内容没有发生变化)。该方法用于在 If-None-Match / ETag, If-Modified-Since 和 Last-Modified 中进行缓存协调。当在 response headers 中设置一个或多个上述参数后，该方法应该被使用。  .getter(&#39;ips&#39;)  //当 X-Forwarded-For 存在并且 app.proxy 被启用时，这些 ips 的数组被返回  .getter(&#39;ip&#39;); //请求远程地址//比如以下操作是等价的：ctx.body = {  code: 200,  result: {      nick: &quot;zhangdianpeng&quot;  }}ctx.response.body = {    code: 200,    result: {        nick: &quot;zhangdianpeng&quot;    }}console.log(&#39;ctx.method:&#39;, ctx.method);console.log(&#39;ctx.request.method:&#39;, ctx.request.method);/*作者：网易云社区链接：https://www.jianshu.com/p/20cf1c476d22来源：简书改进：RainSun*/</code></pre><h1 id="使用Make构建网站"><a href="#使用Make构建网站" class="headerlink" title="使用Make构建网站"></a>使用Make构建网站</h1><p><a href="http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html" target="_blank" rel="noopener">阮一峰教程</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>Web后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b安装aria2</title>
    <link href="undefined2020/04/pi-aria2/"/>
    <url>2020/04/pi-aria2/</url>
    
    <content type="html"><![CDATA[<h1 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h1><h2 id="安装aria2"><a href="#安装aria2" class="headerlink" title="安装aria2"></a>安装<code>aria2</code></h2><pre><code>sudo apt-get install aria2</code></pre><h2 id="配置aria2的文件"><a href="#配置aria2的文件" class="headerlink" title="配置aria2的文件"></a>配置<code>aria2</code>的文件</h2><pre><code>mkdir ~/.aria2touch ~/.aria2/aria2.sessionmkdir /home/pi/data/aria2mkdir /home/pi/data/aria2/downloadnano ~/.aria2/aria2.conf</code></pre><p><code>conf</code>文件里边写</p><pre><code>dir=/home/pi/data/aria2/downloaddisable-ipv6=trueenable-rpc=truerpc-allow-origin-all=truerpc-listen-all=truecontinue=trueinput-file=/home/pi/.aria2/aria2.sessionsave-session=/home/pi/.aria2/aria2.session max-concurrent-downloads=5save-session-interval=60peer-id-prefix=-TR2770-user-agent=Transmission/2.77bt-seed-unverified=truebt-save-metadata=true</code></pre><p>测试运行看看有没有错误</p><pre><code>aria2c –conf-path=/home/pi/.aria2/aria2.conf</code></pre><p>把它做成系统服务</p><pre><code>sudo nano /etc/init.d/aria2c</code></pre><p>输入</p><pre><code>#!/bin/sh### BEGIN INIT INFO# Provides:          aria2# Required-Start:    $remote_fs $network# Required-Stop:     $remote_fs $network# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: Aria2 Downloader### END INIT INFOcase &quot;$1&quot; instart)echo -n &quot;Starting aria2c&quot;sudo -u pi aria2c --conf-path=/home/pi/.aria2/aria2.conf -D;;stop)echo -n &quot;Shutting down aria2c &quot;killall aria2c;;restart)killall aria2csudo -u pi aria2c --conf-path=/home/pi/.aria2/aria2.conf -D;;esacexit</code></pre><h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><pre><code>sudo chmod 755 /etc/init.d/aria2c</code></pre><h2 id="测试服务是否能启动"><a href="#测试服务是否能启动" class="headerlink" title="测试服务是否能启动"></a>测试服务是否能启动</h2><pre><code>sudo service aria2c start</code></pre><p>报错就再输入一句</p><pre><code>sudo update-rc.d aria2c defaults</code></pre><h2 id="添加aria2c服务自动运行"><a href="#添加aria2c服务自动运行" class="headerlink" title="添加aria2c服务自动运行"></a>添加aria2c服务自动运行</h2><pre><code>sudo update-rc.d aria2c defaults</code></pre><h2 id="进文件夹下载yaaw"><a href="#进文件夹下载yaaw" class="headerlink" title="进文件夹下载yaaw"></a>进文件夹下载yaaw</h2><pre><code>cd data/aria2git clone http://github.com/wzhy90/yaaw</code></pre><p>之后就在teaweb里边设置代理就ok</p>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>aria2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>aria2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记</title>
    <link href="undefined2020/04/docker/"/>
    <url>2020/04/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>查看全部网桥</p><pre><code>docker network ls</code></pre><p>查看某个网桥</p><pre><code>docker network inspect &lt;name&gt;</code></pre><p>创建一个名为<code>lacus</code>的网桥</p><pre><code>docker network create --driver bridge lacus</code></pre><p>允许指定网段 上一句指定参数在名之前</p><pre><code>--subnet 172.22.16.0/24 --gateway 172.22.16.1</code></pre><p>删除<code>lacus</code>网桥</p><pre><code>docker network rm lacus</code></pre><p>连接到<code>lacus</code>网桥</p><pre><code>--network=lacus</code></pre><hr><h2 id="容器间通信的三种方式"><a href="#容器间通信的三种方式" class="headerlink" title="容器间通信的三种方式"></a>容器间通信的三种方式</h2><p><strong>IP通信</strong></p><p>只要放在了一个网桥下就可以通过ip进行访问了</p><p><strong>Docker DNS Server</strong></p><p>docker内嵌了DNS Server，只要使用<code>--name=&lt;name&gt;</code>指定容器名并且绑定在一个网桥中就可以使用名字<code>ping -c 3 name</code>连通</p><blockquote><p>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。</p></blockquote><p><strong>joined 容器</strong></p><p>通过<code>--network=container:&lt;name&gt;</code>指定<code>jointed</code>容器</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运行portainer</strong></p><pre><code>docker run -d -p 127.0.0.1:5001:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer  portainer/portainer</code></pre><p><strong>运行mongodb</strong></p><pre><code>// pidocker run -d --name rpi-mongodb3 -v /home/pi/db/mongo:/data/db -p 27017:27017 --network=lacus casualsimulation/rpi-mongodb3 mongod --auth// aldocker run -d --name mongo -v /root/db/mongo:/data/db -p 127.0.0.1:5000:27017 --network=lacus mongo mongod --auth</code></pre><p><strong>打包</strong></p><pre><code>// al ccbdocker build -t lacus/ccb_backend:1.0 .// al ygdocker build -t lacus/yg_backend:1.0 .// al cocdocker build -t lacus/coc_backend:1.0 .// al ccb frontEnddocker build -t lacus/ccb_frontend:1.0 .</code></pre><p><strong>运行</strong></p><pre><code>// al ccbdocker run -it --name ccb -v /root/data/ccb/docker/logs:/app/logs -p 127.0.0.1:5002:80 --network=lacus lacus/ccb_backend:1.0 /bin/sh// al ygdocker run -it --name yg -v /root/data/yg/docker/logs:/app/logs -v /root/data/yg/docker/upload:/app/upload -p 127.0.0.1:5003:80 --network=lacus lacus/yg_backend:1.0 /bin/sh// al cocdocker run -it --name coc -v /root/data/coc/docker/logs:/app/logs -v /root/data/coc/docker/upload:/app/upload -p 127.0.0.1:5004:80 --network=lacus lacus/coc_backend:1.0 /bin/sh// al ccb frontEnddocker run -d --name ccb_frontend -p 127.0.0.1:5005:80 --network=lacus lacus/ccb_frontend:1.0// pi ccb frontEnddocker run -d --name ccb_frontend -p 127.0.0.1:5003:80 --network=lacus lacus/ccb_frontend:1.0// pi ccb backEnddocker run -it --name ccb -v /home/pi/data/ccb/docker/logs:/app/logs -p 127.0.0.1:5002:80 --network=lacus lacus/ccb_backend:1.0 /bin/sh</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器初始化</title>
    <link href="undefined2020/03/init-centos/"/>
    <url>2020/03/init-centos/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h1><p>因为是阿里的服务器，装的centos8，已经自己换好阿里的镜像源了，很nice<br>更新<code>yum</code></p><pre><code>sudo yum -y update</code></pre><p>Todo</p><ol><li><input checked="" disabled="" type="checkbox"> nginx</li><li><input checked="" disabled="" type="checkbox"> mongodb </li><li><input checked="" disabled="" type="checkbox"> docker</li><li><input checked="" disabled="" type="checkbox"> htop<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2>使用<code>yum</code>安装<pre><code>sudo yum -y install nginx   # 安装 nginxsudo yum remove nginx  # 卸载 nginx</code></pre>配置<code>nginx</code>服务<pre><code>sudo systemctl enable nginx # 设置开机启动sudo service nginx start # 启动nginx服务sudo service nginx stop # 停止nginx服务sudo service nginx restart # 重启nginx服务sudo service nginx reload # 重新加载配置，一般是在修改过nginx配置文件时使用</code></pre><h2 id="安装htop"><a href="#安装htop" class="headerlink" title="安装htop"></a>安装htop</h2>使用<code>yum</code>安装<pre><code>yum install epel-release -yyum install htop -y</code></pre><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">网页链接</a><br>如果报错<code>package docker-ce-3:19.03.8-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of the providers can be installed</code><br>就执行以下命令<pre><code>dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmsudo yum install docker-ce docker-ce-clisudo systemctl start docker</code></pre><h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2>使用<code>docker</code>安装<pre><code>docker run -d --name mongo -v /root/db/mongo:/data/db -p 127.0.0.1:5000:27017 --network=lacus mongo mongod --auth</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>部署新服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongoDB学习笔记</title>
    <link href="undefined2019/11/mongodb/"/>
    <url>2019/11/mongodb/</url>
    
    <content type="html"><![CDATA[<h1 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h1><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><pre><code class="js">db.createUser(  {    user: &quot;yingbo&quot;,    pwd: &quot;&quot;,    roles: [ { role: &quot;dbAdmin&quot;, db: &quot;yingbo&quot; },{ role: &#39;readWrite&#39;, db: &quot;yingbo&quot;} ]  })db.createUser(  {    user: &quot;admin&quot;,    pwd: &quot;&quot;,    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]  })</code></pre><h3 id="log目录-var-log-mongodb-mongod-log"><a href="#log目录-var-log-mongodb-mongod-log" class="headerlink" title="log目录 /var/log/mongodb/mongod.log"></a>log目录 <code>/var/log/mongodb/mongod.log</code></h3><h3 id="db目录-var-lib-mongo"><a href="#db目录-var-lib-mongo" class="headerlink" title="db目录 /var/lib/mongo"></a>db目录 <code>/var/lib/mongo</code></h3><h3 id="配置文件-etc-mongod-conf"><a href="#配置文件-etc-mongod-conf" class="headerlink" title="配置文件 /etc/mongod.conf"></a>配置文件 <code>/etc/mongod.conf</code></h3><h3 id="启动-重启-停止-sudo-service-mongod-start-restart-stop"><a href="#启动-重启-停止-sudo-service-mongod-start-restart-stop" class="headerlink" title="启动/重启/停止  sudo service mongod start/restart/stop"></a>启动/重启/停止  <code>sudo service mongod start/restart/stop</code></h3><h3 id="开启用户认证-conf-文件加"><a href="#开启用户认证-conf-文件加" class="headerlink" title="开启用户认证 conf 文件加"></a>开启用户认证 conf 文件加</h3><pre><code>security:  authorization: enabled</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre><code class="c">//方法一mongo --port 12236 -u &quot;admin&quot; -p &quot;&quot; --authenticationDatabase &quot;admin&quot;//方法二db.auth(&quot;yingbo&quot;, &quot;&quot;)</code></pre><h3 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h3><p><code>show dbs</code></p><h3 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h3><pre><code>use &lt;dbname&gt;db.dropDatabase()</code></pre><h3 id="显示所有集合"><a href="#显示所有集合" class="headerlink" title="显示所有集合"></a>显示所有集合</h3><p><code>show tables</code> 或者 <code>show collections</code></p><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><pre><code class="js">//正常情况下直接插入数据就可以自动新建一个集合//创建固定集合 mycol，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。db.createCollection(&quot;&lt;collectionName&gt;&quot;, { capped : true, autoIndexId : true, size :    6142800, max : 10000 } )//单纯的新建一个集合db.createCollection(&quot;&lt;collectionName&gt;&quot;)</code></pre><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><p><code>db.&lt;collectionName&gt;.drop()</code></p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><code>db.&lt;collectionName&gt;.insert(&lt;object&gt;)</code></p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><code>db.&lt;collectionName&gt;.remove({key:value})</code> find里边可以为{}删除全部</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code>db.&lt;collectionName&gt;.update(   &lt;query&gt;,   &lt;update&gt;,   {     upsert: &lt;boolean&gt;,     multi: &lt;boolean&gt;,     writeConcern: &lt;document&gt;   })/*    query : update的查询条件，类似sql update查询内where后面的。    update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的    upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。    multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。    writeConcern :可选，抛出异常的级别。*/</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><code>db.&lt;collectionName&gt;.find({key:value})</code> find里边可以没有参数</p><pre><code>//格式化显示db.col.find().pretty()//条件语句db.col.find({likes : {$lt :200, $gt : 100}}).pretty() //限制 100&lt;likes&lt;200$lt:小于$lte:小于或等于$gt:大于$gte:大于或等于$ne: 不等于$type:     Double     1          String     2          Object     3          Array     4          Binary data     5          Undefined     6     已废弃。    Object id     7          Boolean     8          Date     9          Null     10          Regular Expression     11          JavaScript     13          Symbol     14          JavaScript (with scope)     15          32-bit integer     16          Timestamp     17          64-bit integer     18          Min key     255     Query with -1.    Max key     127//ANDdb.col.find({key1:value1, key2:value2}).pretty()//ORdb.col.find({$or:[{&quot;by&quot;:&quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()//AND+ORdb.col.find({&quot;likes&quot;: {$gt:50}, $or: [{&quot;by&quot;: &quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()// 排除某个字段，例如_iddb.col.find({},{&quot;_id&quot;: 0})// 指定返回某几个字段db.col.find({},{&quot;name&quot;: 1, &quot;sex&quot;: 1})</code></pre><hr><h2 id="Limit与Skip方法"><a href="#Limit与Skip方法" class="headerlink" title="Limit与Skip方法"></a>Limit与Skip方法</h2><p><code>db.&lt;collectionName&gt;.find().limit(&lt;number1&gt;).skip(&lt;number2&gt;)</code></p><p>number1 : 本次查询最多显示条数</p><p>number2 : 本次查询跳过的条数</p><hr><h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort() 方法"></a>sort() 方法</h2><p><code>db.&lt;collectionName&gt;.find().sort({&lt;key&gt;:&lt;number&gt;})</code></p><p>key : 需要进行排序的键名</p><p>number : 其中 1 为升序排列，而 -1 是用于降序排列</p><hr><h2 id="createIndex-方法"><a href="#createIndex-方法" class="headerlink" title="createIndex() 方法"></a>createIndex() 方法</h2><p><code>db.values.createIndex({&lt;key&gt;: &lt;number&gt;, &lt;key&gt;: &lt;number&gt;}, {background: true})</code></p><p>key : 需要进行排序的键名</p><p>number : 其中 1 为升序排列，而 -1 是用于降序排列</p><p>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。</p><hr><h2 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h2><pre><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}]){   &quot;result&quot; : [      {         &quot;_id&quot; : &quot;runoob.com&quot;,         &quot;num_tutorial&quot; : 2      },      {         &quot;_id&quot; : &quot;Neo4j&quot;,         &quot;num_tutorial&quot; : 1      }   ],   &quot;ok&quot; : 1}</code></pre><p>$sum    计算总和。    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</p><p>$avg    计算平均值    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</p><p>$min    获取集合中所有文档对应值得最小值。    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</p><p>$max    获取集合中所有文档对应值得最大值。    db.mycol.aggregate([{$group : {_id :<br>“$by_user”, num_tutorial : {$max : “$likes”}}}])</p><p>$push    在结果文档中插入值到一个数组中。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</p><p>$addToSet    在结果文档中插入值到一个数组中，但不创建副本。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</p><p>$first    根据资源文档的排序获取第一个文档数据。    db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</p><p>$last    根据资源文档的排序获取最后一个文档数据    db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</p><pre><code>结果中就只还有_id,tilte和author三个字段db.article.aggregate(    { $project : {        title : 1 ,        author : 1 ,    }} );连id一起删除db.article.aggregate(    { $project : {        _id : 0 ,        title : 1 ,        author : 1    }});</code></pre><p>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</p><pre><code>db.articles.aggregate( [  { $match : { score : { $gt : 70, $lte : 90 } } },  { $group: { _id: null, count: { $sum: 1 } } }] );</code></pre><p>$limit：用来限制MongoDB聚合管道返回的文档数。</p><p>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</p><pre><code>db.article.aggregate(    { $skip : 5 });</code></pre><p>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</p><p>$group：将集合中的文档分组，可用于统计结果。</p><p>$sort：将输入文档排序后输出。</p><p>$geoNear：输出接近某一地理位置的有序文档。</p><hr><h2 id="MongoDB-复制（副本集）"><a href="#MongoDB-复制（副本集）" class="headerlink" title="MongoDB 复制（副本集）"></a>MongoDB 复制（副本集）</h2><p>等树莓派装完再看</p><h2 id="MongoDB-分片"><a href="#MongoDB-分片" class="headerlink" title="MongoDB 分片"></a>MongoDB 分片</h2><p>等树莓派装完再看</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p><code>mongodump -h dbhost -d dbname -o dbdirectory</code></p><p>-h：<br>MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p><p>-d：<br>需要备份的数据库实例，例如：test</p><p>-o：<br>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 </p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p><code>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</code></p><pre><code>--host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017--db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2--drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！&lt;path&gt;：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。--dir：指定备份的目录你不能同时指定 &lt;path&gt; 和 --dir 选项。</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b更换国内软件源</title>
    <link href="undefined2019/11/pi-origin/"/>
    <url>2019/11/pi-origin/</url>
    
    <content type="html"><![CDATA[<h1 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h1><h2 id="切换到root用户"><a href="#切换到root用户" class="headerlink" title="切换到root用户"></a>切换到root用户</h2><p><code>su - root</code></p><h2 id="修改-etc-apt-sources-list"><a href="#修改-etc-apt-sources-list" class="headerlink" title="修改 /etc/apt/sources.list"></a>修改 /etc/apt/sources.list</h2><p><code>sudo nano /etc/apt/sources.list</code></p><pre><code>原文`deb http://mirrordirector.raspbian.org/raspbian/ stretch main contrib non-free rpi` 加#注释掉加入如下阿里源，`deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi`</code></pre><h2 id="修改-etc-apt-sources-list-d-raspi-list"><a href="#修改-etc-apt-sources-list-d-raspi-list" class="headerlink" title="修改/etc/apt/sources.list.d/raspi.list"></a>修改/etc/apt/sources.list.d/raspi.list</h2><p><code>sudo nano /etc/apt/sources.list.d/raspi.list</code></p><pre><code>原文`deb http://archive.raspberrypi.org/debian/ stretch main ui，` 加#加入如下科大源：`deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui`</code></pre><h2 id="更新系统和软件"><a href="#更新系统和软件" class="headerlink" title="更新系统和软件"></a>更新系统和软件</h2><p><code>sudo apt-get update</code></p><pre><code>`sudo apt-get upgrade`</code></pre>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>软件源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>软件源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b部署ngrok</title>
    <link href="undefined2019/11/pi-ngrok/"/>
    <url>2019/11/pi-ngrok/</url>
    
    <content type="html"><![CDATA[<h1 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h1><p>先去<a href="http://www.ngrok.cc/" target="_blank" rel="noopener">sunny ngrok</a>买个id</p><p>下载<br><code>wget &#39;hls.ctopus.com/sunny/linux_arm.zip?v=2&#39;</code></p><p>重命名<br><code>mv linux_arm.zip?v=2 linux_arm.zip</code></p><p>解压缩<br><code>unzip linux_arm.zip</code></p><p>切文件夹<br><code>cd linux_arm</code></p><p>启动！<br><code>./sunny clientid &lt;your-clientid&gt;</code></p><p>后台运行<br><code>setsid ./sunny clientid &lt;your-clientid&gt; &amp;</code></p><p>移动到 /use/local/bin 目录下并给予可执行权限</p><pre><code>sudo mv sunny /usr/local/bin/sunnysudo chmod +x /usr/local/bin/sunny</code></pre><p>编写启动脚本<br><code>sudo vim /etc/init.d/sunny</code></p><p>内容</p><pre><code>#!/bin/sh -e### BEGIN INIT INFO# Provides:          ngrok.cc# Required-Start:    $network $remote_fs $local_fs# Required-Stop:     $network $remote_fs $local_fs# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: autostartup of ngrok for Linux### END INIT INFONAME=sunnyDAEMON=/usr/local/bin/$NAMEPIDFILE=/var/run/$NAME.pid[ -x &quot;$DAEMON&quot; ] || exit 0case &quot;$1&quot; in  start)      if [ -f $PIDFILE ]; then        echo &quot;$NAME already running...&quot;        echo -e &quot;\033[1;35mStart Fail\033[0m&quot;      else        echo &quot;Starting $NAME...&quot;        start-stop-daemon -S -p $PIDFILE -m -b -o -q -x $DAEMON -- clientid &lt;your-clientid&gt; || return 2        echo -e &quot;\033[1;32mStart Success\033[0m&quot;    fi    ;;  stop)        echo &quot;Stoping $NAME...&quot;        start-stop-daemon -K -p $PIDFILE -s TERM -o -q || return 2        rm -rf $PIDFILE        echo -e &quot;\033[1;32mStop Success\033[0m&quot;    ;;  restart)    $0 stop &amp;&amp; sleep 2 &amp;&amp; $0 start    ;;  *)    echo &quot;Usage: $0 {start|stop|restart}&quot;    exit 1    ;;esacexit 0</code></pre><p>测试</p><pre><code>sudo chmod 755 /etc/init.d/sunnysudo /etc/init.d/sunny startsudo /etc/init.d/sunny start    #启动sudo /etc/init.d/sunny stop     #停止sudo /etc/init.d/sunny restart  #重启</code></pre><p>开机启动</p><pre><code>cd /etc/init.dsudo update-rc.d sunny defaults 90    #加入开机启动sudo update-rc.d -f sunny remove  #取消开机启动</code></pre>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>ngrok</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>ngrok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b安装gogs</title>
    <link href="undefined2019/11/pi-gogs/"/>
    <url>2019/11/pi-gogs/</url>
    
    <content type="html"><![CDATA[<h1 id="gogs"><a href="#gogs" class="headerlink" title="gogs"></a>gogs</h1><p>创建新用户git 如果不创建会导致主账号登陆不了ssh</p><p>切换为root用户为了获取创建用户的权限</p><p><code>sudo su</code></p><p>给root创建一个新的密码</p><p><code>sudo passwd root</code></p><p>添加一个新用户（如用户名为git）</p><p><code>useradd git</code></p><p>为该用户设定登录密码</p><p><code>passwd git</code></p><p>为该用户指定命令解释程序（通常为/bin/bash）</p><p><code>usermod -s /bin/bash git</code></p><p>为该用户指定用户主目录</p><p><code>usermod -d /home/git git</code></p><p>查看用户的属性</p><p><code>cat /etc/passwd</code></p><p>切换到用户git</p><p><code>su git</code></p><p>再次切换到root用户（不要用sudo su, 而用su root）</p><p><code>su root</code></p><p>执行visudo命令</p><p><code>visudo</code></p><p>该命令实际上打开的是/etc/sudoers文件，修改该文件，在“root ALL=(ALL:ALL) ALL”这一行下面加入一行：</p><p><code>git ALL=(ALL:ALL) ALL</code></p><p>ctrl+o（然后再按enter）保存，ctrl+c取消，ctrl+x退出</p><hr><p>下载<br><code>wget &#39;https://github.com/gogs/gogs/releases/download/v0.11.91/raspi_armv7.zip&#39;</code></p><p>解压<br><code>unzip raspi_armv7.zip</code></p><p>进文件夹<br><code>cd gogs</code></p><p>开启web服务<br><code>./gogs web</code></p><p>去3000端口进行设置，数据库设置成sqlite就行</p><p>在<code>/etc/systemd/system/gogs.service</code>新建文件</p><pre><code>[Unit]Description=Gogs (Go Git Service)After=syslog.targetAfter=network.target#After=mysqld.service#After=postgresql.service#After=memcached.service#After=redis.service[Service]# Modify these two values and uncomment them if you have# repos with lots of files and get an HTTP error 500 because# of that####LimitMEMLOCK=infinity#LimitNOFILE=65535Type=simpleUser=gitGroup=gitWorkingDirectory=/home/git/gogsExecStart=/home/git/gogs/gogs webRestart=alwaysEnvironment=USER=git HOME=/home/git[Install]WantedBy=multi-user.target</code></pre><p>更新 User、Group、WorkingDirectory、ExecStart 和 Environment 为相对应的值。其中 WorkingDirectory 为您的 Gogs 实际安装路径根目录。</p><p>[可选] 如果您 Gogs 安装示例使用 MySQL/MariaDB、PostgreSQL、Redis 或 memcached，请去掉相应 After 属性的注释。</p><p>然后通过 <code>sudo systemctl enable gogs</code> 命令激活，最后执行 <code>sudo systemd start gogs</code>，就可以做到开机启动了。</p><p>官方文件解释<a href="'https://gogs.io/docs/advanced/configuration_cheat_sheet'">docs</a></p><p>重启 <code>sudo systemctl restart gogs</code></p>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>gogs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>gogs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令总结</title>
    <link href="undefined2019/11/git/"/>
    <url>2019/11/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><ul><li><p>SSH <code>C:\Users\yingbo\.ssh</code></p><ul><li>创建： <code>ssh-keygen -t rsa -C &#39;邮件地址&#39;</code></li><li>测试： <code>ssh -T git@github.com</code></li><li>注意：上面创建语句完成后会让你输入密码，直接回车，不然之后提交的时候每次都会让你输入密码</li></ul></li><li><p><code>git init</code> 初始化仓库</p></li><li><p><code>git status</code> 查看仓库状态</p></li><li><p><code>git add &#39;文件名&#39;</code> 向暂存区添加文件，如果添加所有文件，’文件名’ =&gt; *</p></li><li><p><code>git commit -m &#39;text&#39;</code> </p><ul><li>提交，text为提交描述</li><li>直接 <code>git commit</code>会进入详细编辑的界面<ul><li>第一行简介</li><li>第二行空行</li><li>第三行详情</li></ul></li></ul></li><li><p><code>git log</code> 提交日志</p><ul><li>尾缀<ul><li><code>--pretty = short</code> 只显示概要</li><li><code>目录名/文件名</code> 只显示该目录或者该文件的记录</li><li><code>-P</code> 显示改动</li><li><code>-P</code> 文件名 显示该文件的改动</li></ul></li></ul></li><li><p><code>git diff</code> 查看区别</p><ul><li><code>git diff HEAD</code> 本次与上次的区别</li></ul></li><li><p><code>git branch</code> 显示所有分支</p><ul><li><code>git checkout -b name</code> 创建name分支并进入( 等同于下边两步)<ul><li>=&gt; <code>git branch name</code></li><li>=&gt; <code>git checkout name</code></li></ul></li><li><code>git checkout -</code> 切换回上一个分支</li><li>注：最好每做一件事就创建一个新的分支，保证代码无误再合并到主分支，保障主分支随时可用</li></ul></li><li><p>合并分支</p><ul><li><code>git checkout &#39;合并到的分支名&#39;</code></li><li><code>git merge --no--ff &#39;合并后消失的分支名&#39;</code></li><li><code>git log --graph</code> 图表形式提交日志</li></ul></li><li><p><code>git reset --hard &#39;哈希值&#39;</code> 回溯历史版本</p></li><li><p><code>git reflog</code> 操作日志</p></li><li><p>查看冲突并解决 git merge 后提示有冲突，此时冲突文件会被修改，进文件改成想要的样子，然后git add，git commit，done！</p></li><li><p><code>git commit --amend</code> 修改上一条的提交信息</p></li><li><p>压缩历史</p><ul><li><code>git commit -am</code> 一次性进暂存然后提交<ul><li>注：修改名称为 typo 例： fix typo</li></ul></li><li><code>git rebase -i HEAD~2</code> 合并两次最新提交</li><li>进入编辑器</li><li>pick 7a34294 Add feature-C</li><li>pick ofba227 Fix typo 将typo -&gt; fixup<br>然后保存 -&gt; ok</li></ul></li><li><p>添加远程仓库</p><ul><li><code>git remote add origin &#39;网址&#39;</code></li><li><code>git push -u origin master</code></li><li>//将当前分支推送到origin远端的master分支（master不存在的话自动新建）</li><li><code>git clone &#39;网址&#39;</code> 克隆仓库</li><li><code>git branch -a</code> 同时显示本地和远端的分支</li><li><code>git checkout -b feature-D origin/feature-D</code></li><li>//新建本地feature-D分支并把远端的feature-D同步过来</li></ul></li><li><p><code>git fetch</code> 与 <code>git pull</code> 的区别</p><ul><li>git pull = git fetch + git margin</li></ul></li><li><p>删除分支</p><ul><li><code>git branch -D &#39;分支名&#39;</code></li></ul></li><li><p>PR总结</p><pre><code>git checkout -b &lt;name&gt; //创建分支coding...git commit -m &#39;&lt;content&gt;&#39; //提交git pushd -u origin &lt;name&gt;  //推远端web -&gt; prgit branch -d &lt;name&gt;  //删除本地git push origin --delete &lt;name&gt; //删除远端</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 命令积累</title>
    <link href="undefined2019/11/linux/"/>
    <url>2019/11/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h3 id="切换用户su-root"><a href="#切换用户su-root" class="headerlink" title="切换用户su - root"></a>切换用户<code>su - root</code></h3><ul><li><code>-</code> 的含义是携带当前环境变量</li></ul><h3 id="增加用户useradd"><a href="#增加用户useradd" class="headerlink" title="增加用户useradd"></a>增加用户<code>useradd</code></h3><ul><li><code>-g</code> 指定用户所在群组 </li><li><code>-m</code> 自动建立用户的登入目录 </li><li><code>-n</code> 取消建立和用户同名的群组</li></ul><h3 id="更改对应用户密码passwd"><a href="#更改对应用户密码passwd" class="headerlink" title="更改对应用户密码passwd"></a>更改对应用户密码<code>passwd</code></h3><h3 id="查看进程ps"><a href="#查看进程ps" class="headerlink" title="查看进程ps"></a>查看进程<code>ps</code></h3><ul><li><code>-ef</code> 查看所有进程以及其pid </li><li><code>-aux</code> 查看所有进程并显示其占用的cpu以及mem </li><li><code>-w</code> 显示加宽可以显示更多信息</li><li><code>ps -auxwww</code>加宽三次</li></ul><h3 id="停止进程kill-pid"><a href="#停止进程kill-pid" class="headerlink" title="停止进程kill (pid)"></a>停止进程<code>kill (pid)</code></h3><ul><li><code>-s</code> 发送指定信号到进程</li><li><code>-p</code> 打印出进程号，但是不发送信号</li><li><code>-l</code> 打印出所有可用信号名称</li></ul><h3 id="查看磁盘fdisk-l"><a href="#查看磁盘fdisk-l" class="headerlink" title="查看磁盘fdisk -l"></a>查看磁盘<code>fdisk -l</code></h3><ul><li>必须使用<code>root</code>权限</li></ul><h3 id="切换目录cd"><a href="#切换目录cd" class="headerlink" title="切换目录cd ../"></a>切换目录<code>cd ../</code></h3><ul><li><code>./</code>当前目录</li><li><code>../</code>上级目录</li><li><code>cd -</code>返回到上个目录</li></ul><h3 id="显示当前文件夹下的文件夹以及文件ls"><a href="#显示当前文件夹下的文件夹以及文件ls" class="headerlink" title="显示当前文件夹下的文件夹以及文件ls"></a>显示当前文件夹下的文件夹以及文件<code>ls</code></h3><ul><li><code>-l</code> 显示详细信息</li><li><code>-a -all</code> 列出所有文件包括隐藏文件</li><li><code>-d</code> 将目录名和其他文件一样列出，而不是列出目录的内容</li><li><code>-f</code> 不排序目录内容，按他们在磁盘上存储的顺序列出</li></ul><h3 id="创建一个目录mkdir"><a href="#创建一个目录mkdir" class="headerlink" title="创建一个目录mkdir"></a>创建一个目录<code>mkdir</code></h3><ul><li><code>-m</code> 对新建目录设置权限</li><li><code>-p</code> 可以是一个路径，可以一次创建多层目录</li></ul><h3 id="查看文件内容cat-文件路径"><a href="#查看文件内容cat-文件路径" class="headerlink" title="查看文件内容cat (文件路径)"></a>查看文件内容<code>cat (文件路径)</code></h3><ul><li><code>-n</code> 输出行号</li><li><code>-b</code> 输出行号，对空白行不编号</li></ul><h3 id="复制文件cp"><a href="#复制文件cp" class="headerlink" title="复制文件cp"></a>复制文件<code>cp</code></h3><ul><li><code>-a</code> 保留链接，文件属性，复制其子目录，其作用等于dpr选项的组合</li><li><code>-d</code> 拷贝时保留链接</li><li><code>-f</code> 删除已经存在的目标文件而不提示</li><li><code>-i</code> 覆盖目标文件之前给出提示要求用户确认</li><li><code>-p</code> 除了复制内容，修改时间还有访问权限也复制到新文件中</li><li><code>-r</code> 若给出的文件是一目录文件，此时将会递归复制该目录下的所有文件以及子目录，此时目标文件必须为一个目录名</li></ul><h3 id="为文件改名或者移动mv"><a href="#为文件改名或者移动mv" class="headerlink" title="为文件改名或者移动mv"></a>为文件改名或者移动<code>mv</code></h3><ul><li><code>-i</code> 若操作会导致文件被覆写，将会提示用户确认</li><li><code>-f</code> 禁止交互 会让<code>-i</code> 失效</li><li><code>mv fromfile tofile</code>如把文件a.txt得命名为b.txt，可以是mv a.txt b.txt。</li></ul><h3 id="移除目录或者文件rm"><a href="#移除目录或者文件rm" class="headerlink" title="移除目录或者文件rm"></a>移除目录或者文件<code>rm</code></h3><ul><li><code>-i</code> 进行交互式删除</li><li><code>-f</code> 不需要提示</li><li><code>-r</code> 将所有目录以及子目录递归地删除</li><li><code>-d</code> 删除空目录</li></ul><h3 id="修改文件所有者chown"><a href="#修改文件所有者chown" class="headerlink" title="修改文件所有者chown"></a>修改文件所有者<code>chown</code></h3><h3 id="修改文件所有组chgrp"><a href="#修改文件所有组chgrp" class="headerlink" title="修改文件所有组chgrp"></a>修改文件所有组<code>chgrp</code></h3><h3 id="修改文件访问权限chmod"><a href="#修改文件访问权限chmod" class="headerlink" title="修改文件访问权限chmod"></a>修改文件访问权限<code>chmod</code></h3><ul><li><code>-c</code> 若文件权限更改成功才显示</li><li><code>-f</code> 若文件无法被更改也不打印错误信息</li><li><code>-v</code> 显示权限变更详细资料</li><li>修改文件权限<a href="'https://blog.csdn.net/slwhy/article/details/78876237'">链接</a></li></ul><h3 id="在指定文件中搜索内容"><a href="#在指定文件中搜索内容" class="headerlink" title="在指定文件中搜索内容"></a>在指定文件中搜索内容</h3><ul><li><code>grep</code> 选项 格式 文件</li><li><code>-c</code> 只输出匹配的行数</li><li><code>-i</code> 不区分大小写</li><li><code>-h</code> 查询多文件不显示文件名</li><li><code>-l</code> 查询多文件只显示包含匹配字符的文件名</li><li><code>-n</code> 显示匹配行以及行号</li><li><code>-s</code> 不显示不存在或者无匹配文本的错误信息</li><li><code>-v</code> 显示不包含匹配文本的所有行</li></ul><h3 id="查找指定文件find-路径-选项-描述"><a href="#查找指定文件find-路径-选项-描述" class="headerlink" title="查找指定文件find [路径] [选项] [描述]"></a>查找指定文件<code>find [路径] [选项] [描述]</code></h3><ul><li><code>-depth</code> 使用深度级别的查找过程方式，在某层指定目录中优先查找文件内容</li><li><code>-mount</code> 不在其他文件系统的目录个文件中查找</li><li><code>-name</code> 支持通配符* 和 ?</li><li><code>-user</code> 搜索文件所属为用户名的文件</li><li><code>-print</code> 输出搜索结果并打印</li><li><code>-and</code> 把两个查找参数链接起来</li></ul><h3 id="查找文件locate"><a href="#查找文件locate" class="headerlink" title="查找文件locate"></a>查找文件<code>locate</code></h3><ul><li>先建立一个所有文件名以及路径的数据库所以比find快</li><li><code>-u</code> 从根目录开始建立数据库</li><li><code>-U</code> 从指定位置开始建立数据库</li><li><code>-f</code> 将特定的文件系统排除在数据库外</li><li><code>-r</code> 使用正则表达式做寻找的条件</li><li><code>-o</code> 指定数据库的名成</li><li>创建后会在crontab中每天已更新</li><li>使用updatedb强制更新</li></ul><h3 id="创建链接ln-s-genromfs-0-5-1-tar-gz-hello"><a href="#创建链接ln-s-genromfs-0-5-1-tar-gz-hello" class="headerlink" title="创建链接ln -s ../genromfs-0.5.1.tar.gz ./hello"></a>创建链接<code>ln -s ../genromfs-0.5.1.tar.gz ./hello</code></h3><h3 id="gzip压缩解压"><a href="#gzip压缩解压" class="headerlink" title="gzip压缩解压"></a>gzip压缩解压</h3><ul><li>自动识别</li><li><code>-c</code> 将输出信息输出保留源文件</li><li><code>-d</code> 将压缩文件解压，但是不能压缩目录</li><li><code>-l</code> 显示详细信息</li><li><code>-r</code> 查找指定目录压缩或解压缩里边所有文件</li><li><code>-t</code> 测试，检查压缩文件是否完整</li><li><code>-v</code> 对每一个压缩或者解压的文件显示文件名和压缩比</li></ul><h3 id="对文件目录进行打包和解包tar"><a href="#对文件目录进行打包和解包tar" class="headerlink" title="对文件目录进行打包和解包tar"></a>对文件目录进行打包和解包<code>tar</code></h3><ul><li><code>tar [选项] [打包后文件名] 文件目录列表</code></li><li><code>-c</code> 建立新的打包文件</li><li><code>-r</code> 向打包文件末尾追加文件</li><li><code>-x</code> 从打包文件中解出文件</li><li><code>-o</code> 将文件解开到标准输出</li><li><code>-v</code> 显示处理过程中相关信息</li><li><code>-f</code> 对普通文件操作</li><li><code>-z</code> 调用gzip压缩打包文件，与<code>-x</code>连用解压缩</li><li><code>-j</code> 调用bzip2压缩打包文件，与<code>-x</code>连用解压缩</li><li><code>-Z</code> 调用Compress压缩打包文件，与<code>-x</code>连用解压缩</li></ul><h3 id="查看网络状态ifconfig"><a href="#查看网络状态ifconfig" class="headerlink" title="查看网络状态ifconfig"></a>查看网络状态<code>ifconfig</code></h3><h3 id="系统服务命令chkconfig-list"><a href="#系统服务命令chkconfig-list" class="headerlink" title="系统服务命令chkconfig --list"></a>系统服务命令<code>chkconfig --list</code></h3><ul><li>查看指定命令 <code>chkconfig --list|grep ntpd</code></li><li>操作指定服务 <code>chkconfig --level 3 ntpd on</code></li></ul><h3 id="查看当前文件夹pwd"><a href="#查看当前文件夹pwd" class="headerlink" title="查看当前文件夹pwd"></a>查看当前文件夹<code>pwd</code></h3><h3 id="查看所有端口占用情况"><a href="#查看所有端口占用情况" class="headerlink" title="查看所有端口占用情况"></a>查看所有端口占用情况</h3><p><code>netstat -ntlp</code></p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>touch</code></p><h3 id="查看-5000端口占用程序"><a href="#查看-5000端口占用程序" class="headerlink" title="查看 5000端口占用程序"></a>查看 5000端口占用程序</h3><p><code>sudo lsof -i:5000</code></p><h3 id="停止进程"><a href="#停止进程" class="headerlink" title="停止进程"></a>停止进程</h3><p><code>sudo kill (PID)</code></p><h3 id="下载到当前文件夹"><a href="#下载到当前文件夹" class="headerlink" title="下载到当前文件夹"></a>下载到当前文件夹</h3><p><code>wget&quot;&lt;url&gt;&quot;</code></p><h3 id="下载到-home-omio-Desktop"><a href="#下载到-home-omio-Desktop" class="headerlink" title="下载到 /home/omio/Desktop"></a>下载到 /home/omio/Desktop</h3><p><code>wget -P /home/omio/Desktop/&quot;&lt;url&gt;&quot;</code></p><h3 id="下载并重命名为NewFileName"><a href="#下载并重命名为NewFileName" class="headerlink" title="下载并重命名为NewFileName"></a>下载并重命名为NewFileName</h3><p><code>wget -O /home/omio/Desktop/NewFileName&quot;&lt;url&gt;&quot;</code></p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>zip -r archive_name.zip directory_to_compress</code></p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p><code>unzip archive_name.zip</code></p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><code>tar -cvf archive_name.tar directory_to_compress</code></p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p><code>tar -xvf archive_name.tar.gz</code></p><h3 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf archive_name.tar.gz directory_to_compress</code></p><h3 id="解压缩-1"><a href="#解压缩-1" class="headerlink" title="解压缩"></a>解压缩</h3><p><code>tar -zxvf archive_name.tar.gz</code></p><p><code>tar -zxvf archive_name.tar.gz -C /tmp/extract_here/</code></p><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p><code>mv fromfile tofile</code></p><ul><li>如把文件a.txt得命名为b.txt，可以是mv a.txt b.txt。</li></ul><h3 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h3><p><code>rm -d 目录名</code></p><h3 id="删除一个空目录-1"><a href="#删除一个空目录-1" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h3><p><code>rm -dir 目录名</code></p><h3 id="删除一个非空目录"><a href="#删除一个非空目录" class="headerlink" title="删除一个非空目录"></a>删除一个非空目录</h3><p><code>rm -r 目录名</code></p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>rm 文件名</code></p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><a href="'https://blog.csdn.net/slwhy/article/details/78876237'">链接</a></p><ul><li>sudo chmod o+rwx /usr/local/bin/sunny</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>system</tag>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask 简单安装和部署</title>
    <link href="undefined2019/11/flask/"/>
    <url>2019/11/flask/</url>
    
    <content type="html"><![CDATA[<h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><p>安装venv</p><p><code>python3 -m venv venv</code></p><p>启动venv</p><p><code>. venv/bin/activate</code></p><p>关闭venv</p><p><code>deactivate</code> </p><p>查看现在已经安装的依赖</p><p><code>pip3 list</code></p><p>更新pip</p><p><code>pip install --upgrade pip</code></p><p>安装Flask</p><p><code>pip install Flask</code></p><p>安装最新的flask</p><p><code>pip install -U https://github.com/pallets/flask/archive/master.tar.gz</code></p><p>安装pymongo</p><p><code>pip install pymongo</code></p><p>安装requests</p><p><code>pip install requests</code></p><p>安装payjs</p><p><code>pip install payjs</code></p><p>设置全局变量</p><p><code>export FLASK_APP=qrcode.py</code></p><p><code>export FLASK_ENV=development</code></p><p>启动</p><p><code>flask run --host=0.0.0.0</code></p><p>在虚拟环境下安装gunicorn </p><p><code>pip install gunicorn</code></p><p>添加配置文件 gunicorn.conf.py</p><pre><code># 并行工作线程数workers = 4# 监听内网端口5000【按需要更改】bind = &#39;127.0.0.1:5000&#39;# 设置守护进程【关闭连接时，程序仍在运行】daemon = True# 设置超时时间120s，默认为30s。按自己的需求进行设置timeout = 120# 设置访问日志和错误信息日志路径# accesslog = &#39;./logs/acess.log&#39;# errorlog = &#39;./logs/error.log&#39;# 自动重启autostart = ture</code></pre><p>启动gunicorn</p><p><code>gunicorn qrcode:app -c gunicorn.conf.py</code></p><p>查询gunicorn</p><p><code>pstree -ap|grep gunicorn</code></p><p>停止进程</p><p><code>kill (pid)</code></p><hr><p>在路由中</p><ol><li>同时有user/ 和 user 优先解释 user/</li><li>只有 user 的情况下 访问user/会报404</li><li>只有 user/ 的情况下 访问user会被重定向</li></ol>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/11/hello-world/"/>
    <url>2019/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>quickStart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>