<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>绿宝书学习笔记10</title>
    <link href="undefined2020/07/green10/"/>
    <url>2020/07/green10/</url>
    
    <content type="html"><![CDATA[<h3 id="4-4-4-块与语句的值"><a href="#4-4-4-块与语句的值" class="headerlink" title="4.4.4 块与语句的值"></a>4.4.4 块与语句的值</h3><p>严格来说，所有语句在执行之后都会有“结果”，但是只有语句被正确执行并且返回一个“有效的值(value)”时，这个Value才能被其他计算过程使用。</p><h4 id="4-4-4-1-语句的执行状态"><a href="#4-4-4-1-语句的执行状态" class="headerlink" title="4.4.4.1 语句的执行状态"></a>4.4.4.1 语句的执行状态</h4><p>JS中的代码出错都是以“某某语句出错”的形式展现出来的，因为，事实上，所谓“异常”就是一个在语句层面捕捕获处理的语义对象</p><p>包括<code>throw</code>在内，所有简单语句中的所有四个子句都有自己的执行状态</p><ul><li>继续：语句处于循环中并被<code>continue</code>子句指示返回指定位置继续；</li><li>中断：语句处于<code>switch</code>或者循环中，并被<code>break</code>子句指示终止；</li><li>返回：语句从函数中返回并带有某个<code>Value</code>（包括默认返回的undefined）</li></ul><p>除此之外，所有语句都使用称为<code>normal</code>状态的结果（Result）来返回自己的值</p><h4 id="4-4-4-2-语句无值"><a href="#4-4-4-2-语句无值" class="headerlink" title="4.4.4.2 语句无值"></a>4.4.4.2 语句无值</h4><p>确实有一些语句是无值的，其中包括所有的声明语句、debugger语句、导入导出语句，以及空语句和空快语句</p><p>当<code>eval</code>作用于结果无知的语句时，它将返回undefined，但是，并不能反过来判断此语句是否为无值，一个准确且有效的判断方法是利用下边这项特性</p><ul><li>在一个语句块的返回值中，无值语句将被忽略</li></ul><p>也就是说，如果语句无值，那么把它放在一批语句的末端时，将不会影响该语句的结果</p><h4 id="4-4-4-3-语句有值"><a href="#4-4-4-3-语句有值" class="headerlink" title="4.4.4.3 语句有值"></a>4.4.4.3 语句有值</h4><p>大多数语句都是有值的</p><p>但是所谓的“形式分块”让语句的值变成了更加复杂的讨论北京，从表面上来看，例如条件语句if，可以简单的理解为</p><ul><li>如果语句失败，那么它的结果是一个包含了throw状态的异常对象</li><li>如果语句成功，那么它的结果必然是then或者else分支中被正确执行的语句的值。</li></ul><p>但是<code>if(false); else;</code>then与else分支都是空语句，而空语句都是无值的，那么表明if语句最终——由分支语句决定的——也是无值的吗？</p><p>ECMAScript规定，在所有逻辑语句或有形式分块的语句中</p><ul><li>子句或块返回无值时，逻辑语句本身将以undefined返回</li><li>continue与break只改变语句的执行流程，对返回的值无影响</li></ul><h3 id="4-4-5-标签语句与块"><a href="#4-4-5-标签语句与块" class="headerlink" title="4.4.5 标签语句与块"></a>4.4.5 标签语句与块</h3><p>大多数语句都可以添加一个标签而变成“标签化语句”，例如：<code>aa:100; // 100</code></p><p>这里的aa就是一个标签，即使这个标签不被其他语句或语法引用，或者该标签的存在毫无意义，它在语法上也是合法的</p><p>当标签语句能作用于循环语句时，该标签可以被循环语句“内部的”<code>break</code>和<code>continue</code>子句引用。</p><pre><code class="js">aa: while(true) break aa;// undefined</code></pre><p>其中，类似<code>break xxx</code>这样的带标签的<code>break</code>子句主要用于多重循环中，在一般常见的switch语句的块中是不使用标签化的<code>break</code>的。当然如果使用，也是合法的</p><p>标签语句是独立的语法元素，因此可以和变量名或者其他标识符名字重名</p><h2 id="4-5-组织形式分块的方法"><a href="#4-5-组织形式分块的方法" class="headerlink" title="4.5 组织形式分块的方法"></a>4.5 组织形式分块的方法</h2><p>所谓形式分块，它的作用就是定义一个“块级别的”作用域</p><p>意味着JS会为该分块创建作用域。称为词法作用域。</p><h3 id="4-5-1-词法作用域"><a href="#4-5-1-词法作用域" class="headerlink" title="4.5.1 词法作用域"></a>4.5.1 词法作用域</h3><p>代码分块带来的语法效果是信息隐蔽——变量或成员的可见性问题，可见性的区间称为作用域，当这个域是通过静态词法分析得出的时候，就被称为词法作用域</p><p>词法环境是词法作用域这个概念的运行期实现：代码在物理行上、显式地进行形式分块，并在引擎执行期映射成词法环境记录，以便将“块级别的”词法作用域实例化</p><h4 id="4-5-1-1-不存在“级别1：表达式”"><a href="#4-5-1-1-不存在“级别1：表达式”" class="headerlink" title="4.5.1.1 不存在“级别1：表达式”"></a>4.5.1.1 不存在“级别1：表达式”</h4><p>在JS中没有“表达式级别的”词法作用域</p><h4 id="4-5-1-2-级别2：语句"><a href="#4-5-1-2-级别2：语句" class="headerlink" title="4.5.1.2 级别2：语句"></a>4.5.1.2 级别2：语句</h4><p>变量“存在于”某个语句级别的作用域，是指该变量被创建出来之后，在脱离了创造它的（单个或者连续的）表达式之后，仍然可以下（或仅在）所在语句中的作用域中被访问</p><p>在JS for循环阔号中定义的变量仍可在外边被访问到，说明早期的JS在设计上以及引擎实现上都没有“语句级别的”词法作用域，只支持函数级别的变量作用域。但是ES6之后使用let声明就不可以在外边访问到，就是“块级作用域”</p><p>对于没有形式分块的单一语句是没有块级作用域的意义的</p><pre><code class="js">if(false) let x = 100;// SyntaxError: Lexical declaration connot appear in a signle-statement...</code></pre><h4 id="4-5-1-3-级别3：函数"><a href="#4-5-1-3-级别3：函数" class="headerlink" title="4.5.1.3 级别3：函数"></a>4.5.1.3 级别3：函数</h4><p>当使用函数调用运算符”()”时。JS会为函数构建一个词法环境，以便将该函数的形式分块实例化为一个函数</p><p>对于语句内的声明要提升到语句之外的函数或者全局作用域，看起来和var一样</p><p>之所以在函数内可以声明子集的函数，而在语句内却无法声明函数，是因为函数的名字是一个变量名，而不是一个词法名字</p><p>箭头函数也是有自己的作用域的</p><h4 id="4-5-1-4-级别4：模块"><a href="#4-5-1-4-级别4：模块" class="headerlink" title="4.5.1.4 级别4：模块"></a>4.5.1.4 级别4：模块</h4><p>模块词法作用域所对应的形式分块是由模块的<code>export</code>声明决定的，执行环境将预先扫描这些声明并进行词法分析，然后会在实例化时创建一个自有的词法环境来登记它们，但是实例化或成却是在执行<code>import</code>声明来导入该模块才发生的，用以绑定全部的顶层声明</p><p>所有的导入都将使用本地名字，然后就变成了只读的变量</p><p>在模块的词法作用域中访问<code>this</code>总是得到<code>undefined</code></p><h4 id="4-5-1-5-级别5：全局"><a href="#4-5-1-5-级别5：全局" class="headerlink" title="4.5.1.5 级别5：全局"></a>4.5.1.5 级别5：全局</h4><p>JS全局环境中一共存在三种用来等级名字的组件，包括词法作用域、变量作用域和全局对象</p><p>所有变量声明的名字都在变量作用域登记，用户代码通过“访问不存在的变量名”导致的名字创建作为全局对象的属性登记的，其他的<code>let/count</code>等声明导致的登记，才是发生在全局的词法作用域中的</p><h3 id="4-5-2-执行流程及其变更"><a href="#4-5-2-执行流程及其变更" class="headerlink" title="4.5.2 执行流程及其变更"></a>4.5.2 执行流程及其变更</h3><p>术语命令式来自命令和动作，这种计算模型就是基于冯诺依曼体系中的编程语言能得到的运算效果的本质：顺序执行</p><p>但是程序执行总会有意外，我们需要改变“顺序执行”的流程</p><p>GOTO会带来大量的问题，所以在每个词法作用域设计类似GOTO的语句，例如<code>break</code></p><h4 id="4-5-2-1-级别1：可能的逃逸"><a href="#4-5-2-1-级别1：可能的逃逸" class="headerlink" title="4.5.2.1 级别1：可能的逃逸"></a>4.5.2.1 级别1：可能的逃逸</h4><p>没有任何有效的方式可在表达式中实现类似GOTO的效果。</p><p>通过制造“异常”可以在表达式计算过程中产哼一个向外层的中断。但与GOTO不同的是，这并非表达式专属的，而是普通的、一般意义上的、可被捕获的异常</p><h4 id="4-5-2-2-级别2：“break-”等语法"><a href="#4-5-2-2-级别2：“break-”等语法" class="headerlink" title="4.5.2.2 级别2：“break ”等语法"></a>4.5.2.2 级别2：“break <label>”等语法</h4><p>在循环中可以使用break和continue来改变循环流程，break；会直接跳出当前循环，continue：跳过当前循环并进入下一次循环</p><p><code>break &lt;label&gt;</code>会跳出label指明的作用域</p><pre><code class="js">var i = 0;my_label: {  i ++;  while(true) {    break my_label;  }  i = 0;}console.log(i) // 1</code></pre><h4 id="4-5-2-3-级别3：return子句"><a href="#4-5-2-3-级别3：return子句" class="headerlink" title="4.5.2.3 级别3：return子句"></a>4.5.2.3 级别3：return子句</h4><ul><li>break label;不能跨越函数的词法作用域</li><li>return 子句可以跨越任何语句的作用域而退出函数</li></ul><p>函数外边套标签，函数内部的break无法访问到外边的标签</p><h4 id="4-5-2-4-级别4：动态模块与Promise中的流程控制"><a href="#4-5-2-4-级别4：动态模块与Promise中的流程控制" class="headerlink" title="4.5.2.4 级别4：动态模块与Promise中的流程控制"></a>4.5.2.4 级别4：动态模块与Promise中的流程控制</h4><p>模块有自己的词法作用域，但没有相关流程控制语句，静态加载的模块并没有执行流程的概念，对于动态模块来说，他的作用域将会“被包含于”一个Promise对象的执行环境中，类似在<code>new Promise(func)</code>语句中的func中</p><p>因此这种情况下也能针对模块进行流程控制，例如在Promise.then中响应onRejected,或者调用promise.catch()和promise.finally()，然而这些响应函数的调用都不会回到：模块，因此也就不存在所谓的：模块作用域中的GOTO语句</p><h4 id="4-5-2-5-级别5：throw语句"><a href="#4-5-2-5-级别5：throw语句" class="headerlink" title="4.5.2.5 级别5：throw语句"></a>4.5.2.5 级别5：throw语句</h4><p>首先应该注意到<code>try...catch...finally</code>语法结构的词法作用域是语句，而<code>throw</code>是全局。我们称呼<code>throw</code>时，用的是”语句“，而不是”子句“</p><p>尽管<code>throw</code>也是一个流程变更的语句，然而其作用域却是脚本引擎全局。</p><h3 id="4-5-3-词法作用域之间的相关性"><a href="#4-5-3-词法作用域之间的相关性" class="headerlink" title="4.5.3 词法作用域之间的相关性"></a>4.5.3 词法作用域之间的相关性</h3><p>结构化的语言中的作用域是互补相交的，只存在平行或者嵌套两种相关性</p><ul><li>相同级别的词法作用域可以互相嵌套</li><li>高级别的词法作用域能够包含低级别的词法作用域</li><li>低级别的词法作用域不能包含高级别的词法作用域，由于不存在包含关系，因此语言实现时，一般处理称语法上的违例或者强制解释为平行关系</li></ul><pre><code class="js">// 代码块一if(true) {  // ...  // 代码块二  function foo() {    // ...  }}// 等效于// 代码块一if(true) {  //...}// 代码块二function foo() {  // ...}</code></pre><h3 id="4-5-4-执行流程变更的内涵"><a href="#4-5-4-执行流程变更的内涵" class="headerlink" title="4.5.4 执行流程变更的内涵"></a>4.5.4 执行流程变更的内涵</h3><ul><li>词法作用域是互不相交的，正是作用域互不相交的特性构造了代码结构化的层次，并消除了一些错误隐患</li><li>词法作用域间可以存在平行或包含关系。高级别可以嵌套低级别的词法作用域，反之则不成立</li><li>高级别的流程变更子句（或语句）可以跨越低级别的作用域，反之则不成立</li></ul><h2 id="4-6-层次结构程序设计"><a href="#4-6-层次结构程序设计" class="headerlink" title="4.6 层次结构程序设计"></a>4.6 层次结构程序设计</h2><p>JS的对象其实只是属性包，所谓属性，本质上是另一个”名字系统“，在这个新的名字系统中，仍然存在着变量或词法标识符类似的作用域问题，并且也受相似的规则约束</p><p>封装、继承与多态是面向对象解决”结构性问题“的三种具体手段</p><ul><li>封装与继承是对数据（即对象性质）的结构化，分别展示数据的内聚与外延</li><li>多态是对象性质在继承关系上的表现</li></ul><p>当对象性质分成属性与方法之后，逻辑（方法）之于数据（属性）的可见性问题也就出现了，并且这种可见性必然在内聚与外延的两个方向上同时出现</p><h3 id="4-6-1-属性的可见性"><a href="#4-6-1-属性的可见性" class="headerlink" title="4.6.1 属性的可见性"></a>4.6.1 属性的可见性</h3><p>属性是对象的自有属性，方法也是属性的一种，它们是平等的，由于在传统上，JS并不存在”对象或类“这样的作用域，因此在对象方法中访问属性，与在其他域、其他环境中访问属性没有区别：</p><ul><li>得到该属性的引用，然后</li><li>使用属性存取运算符得到属性值</li></ul><p>并且由于所有的属性都是公开的，所以任何时候、任何环境下只要能获得这个对象的（的引用），就可以无差别的访问它的全部属性</p><p>符号具有隐匿名字的特性，但并不能隐匿可见性。当一个对象使用某个符号作为属性名时，用户代码至多也只是不知道其符号名而已</p><p>另一个与属性可见性相关的设计时属性描述符中的Enumerable性质，它影响属性在for…in语句中的可见性效果，但它并不实际影响属性的可访问性，所以与符号类似，也只能起简单的隐匿作用</p><h3 id="4-6-2-多态的逻辑"><a href="#4-6-2-多态的逻辑" class="headerlink" title="4.6.2 多态的逻辑"></a>4.6.2 多态的逻辑</h3><p>在传统的JS面向对象中，多态特性是非常脆弱的，主要表现为类型识别，包括<code>instanceof</code>关键字以及后来加入的<code>isPrototypeOf</code>方法，从ES6之后还加入了super属性，才彻底解决了实现多态时，调用父类方法的问题</p><h4 id="4-6-2-1-super是对多态逻辑的绑定"><a href="#4-6-2-1-super是对多态逻辑的绑定" class="headerlink" title="4.6.2.1 super是对多态逻辑的绑定"></a>4.6.2.1 super是对多态逻辑的绑定</h4><p>super明确地指向继承关系中的父级，然而我们知道JS的继承树是可以重置的，访问super是一个动态的逻辑，而不是一个确定的成员</p><h4 id="4-6-2-2-super是一个作用域相关的绑定"><a href="#4-6-2-2-super是一个作用域相关的绑定" class="headerlink" title="4.6.2.2 super是一个作用域相关的绑定"></a>4.6.2.2 super是一个作用域相关的绑定</h4><p>super关键字是上下文受限的，并且是词法作用域（静态）绑定的，这个关键字只能使用在类声明（含类表达式）和对象字面量风格的声明中，并且只能出现在方法或静态方法声明内部。这意味着super必须作用于某个方法的“函数作用域”中。且如果该方法时类声明中的方法，则该函数作用域还将是“类作用域”的子集作用域</p><h3 id="4-6-3-私有作用域的提出"><a href="#4-6-3-私有作用域的提出" class="headerlink" title="4.6.3 私有作用域的提出"></a>4.6.3 私有作用域的提出</h3><p>从ES6提出类继承以来，类的声明中只能包括方法和存取器属性</p><p>TS中包含私有成员声明语法</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>labuladong的算法小抄</title>
    <link href="undefined2020/07/algo/"/>
    <url>2020/07/algo/</url>
    
    <content type="html"><![CDATA[<h1 id="labuladong的算法小抄"><a href="#labuladong的算法小抄" class="headerlink" title="labuladong的算法小抄"></a>labuladong的算法小抄</h1><p>今天打算开始猛补算法，这个文档写的超级棒！冲冲冲！</p><p>戳我<a href="https://labuladong.gitbook.io/algo/" target="_blank" rel="noopener">https://labuladong.gitbook.io/algo/</a> 👈</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>文档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome调试技巧</title>
    <link href="undefined2020/07/chrome-dev/"/>
    <url>2020/07/chrome-dev/</url>
    
    <content type="html"><![CDATA[<h1 id="Chrome调试技巧"><a href="#Chrome调试技巧" class="headerlink" title="Chrome调试技巧"></a>Chrome调试技巧</h1><p>今早偶然发现了一个很不错的说明文档，在这里记一下，我发现这个HEXO没有记小东西的地方欸~</p><p>戳我<a href="https://www.frontendwingman.com/" target="_blank" rel="noopener">https://www.frontendwingman.com/</a> 👈</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>chrome调试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记9</title>
    <link href="undefined2020/07/green9/"/>
    <url>2020/07/green9/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript语言的结构化"><a href="#JavaScript语言的结构化" class="headerlink" title="JavaScript语言的结构化"></a>JavaScript语言的结构化</h1><p>程序是可被组织的元素。</p><p>然而如果程序是可被组织的，那么“结构化”其实就只是组织的手法之一，这意味着后者——结构化——只是“程序是什么”的一个解，而绝非唯一解</p><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>对计算过程的认识不同产生了不同的计算模型，基于这些计算模型进行的分类，是计算机语言的主要分类方式之一。这种分类法中，一般将语言分为四大类：命令式语言、函数式语言、逻辑式语言、面向对象程序设计语言。如果从程序本质的角度来看分为两类：命令式语言和说明式语言</p><p>结构化是命令式语言的主要实现手段</p><p>命令式语言的核心就在于“通过运算去改变内存（中的数据）”</p><p>面向对象语言式结构化编程的延申</p><p>进一步抽象：接口</p><h2 id="4-2-基本的组织元素"><a href="#4-2-基本的组织元素" class="headerlink" title="4.2 基本的组织元素"></a>4.2 基本的组织元素</h2><h3 id="4-2-1-标识符"><a href="#4-2-1-标识符" class="headerlink" title="4.2.1 标识符"></a>4.2.1 标识符</h3><p>总是可以将源代码文本视为由空白字符等隔开的词法记号（tokens）序列。</p><p>在Tokens中。由语言预设的标点符号和部分用作保留字的标识符名是确定了书写格式的，例如：++、if和function等，此外都可以由用户代码来定义书写，包括标识符、字面量和模板</p><p>尽管书写的语法不同，但总的来说，这三种代码定义的Tokens都是一系列字符的有序书写，只是：</p><ul><li>标识符只表明一个名字</li><li>字面量表明由字面含义决定的值</li><li>模板表明一个可计算结果的字符串值</li></ul><h3 id="4-2-2-表达式"><a href="#4-2-2-表达式" class="headerlink" title="4.2.2 表达式"></a>4.2.2 表达式</h3><p>表达式是0-1个运算符和至少一个操作数的有序书写</p><p>事实上表达的是：名字和值之间进行计算，并返回名字与值。</p><p><code>,</code>连续运算符，可以连续运算，返回最后一个有效值</p><p>JS概念中，表达式不能独立语句存在。即使单个表达式，可以被称为表达式语句。</p><h4 id="4-2-2-1-字面量"><a href="#4-2-2-1-字面量" class="headerlink" title="4.2.2.1 字面量"></a>4.2.2.1 字面量</h4><p>数组、对象、正则表达式等</p><h4 id="4-2-2-2-初始器"><a href="#4-2-2-2-初始器" class="headerlink" title="4.2.2.2 初始器"></a>4.2.2.2 初始器</h4><pre><code class="js">var x = [1] // 初始器var x = 1 // 字面量</code></pre><p>ECMAScript希望在字面量表示中不包含运算过程，而初始器是可以包含运算过程的。所以ES5中只明确了5中字面量语法，这些字面量在编译期就确知的：null、true\false、数值、字符串、正则表达式。数组和对象就必须是一个运算的结果</p><p>本书也将初始器称为“字面量风格的”，在这种情况主要是强调它们是独立的、原子的、可参与计算的。</p><p>受到这一约定叙述风格影响的语法元素。都是有着自己的运算过程，但又表现为字面量风格的值的。包括数组、对象、函数、正则、模板</p><h3 id="4-2-3-语句"><a href="#4-2-3-语句" class="headerlink" title="4.2.3 语句"></a>4.2.3 语句</h3><p>标识符表达的名字，字面量和模板表达的是值，这些Token最后有两个演进的方向</p><ul><li>是在表达式通过名字来引用值，并进一步的做值运算。这即是JS中函数式语言特性的由来</li><li>通过语句来串联名字和值，并最终表述为将值置于名字。这既是JS中命令式（含过程式和面向对象的）语言特性的由来</li></ul><p>JS语句分为声明语句和非声明语句两类，所有的声明语句都是静态词法分析的，而非声明语句则是动态执行的（即用来叙述计算逻辑的）</p><p>对声明语句来说，它要么用于声明标识符名字，要么用于声明名字与值得关系，后者称为绑定</p><p>所谓函数本质上也只是在语句（甚至是表达式或者标识符）这个层面得组织元素，它是典型得直接绑定名字和值得语法结构</p><h3 id="4-2-4-模块"><a href="#4-2-4-模块" class="headerlink" title="4.2.4 模块"></a>4.2.4 模块</h3><p>模块的出现并不是解决具体编程能力的问题</p><p>模块在语义上的成功之处，在于它是平衡“对功能的展示和对细节的屏蔽”两种需求所能带来的最小可能结果</p><h3 id="4-2-5-组织的原则"><a href="#4-2-5-组织的原则" class="headerlink" title="4.2.5 组织的原则"></a>4.2.5 组织的原则</h3><p>事实上这些原则可以只包括三部分。即：逻辑的、值得和形式结构的，前两者用于约束一个最小可计算系统，后者用于让这个计算系统在形式上具有确定性</p><h4 id="4-2-5-1-原则一：抑制数据的可变性"><a href="#4-2-5-1-原则一：抑制数据的可变性" class="headerlink" title="4.2.5.1 原则一：抑制数据的可变性"></a>4.2.5.1 原则一：抑制数据的可变性</h4><p>数据得可变性称为状态。如果系统是无状态的，那么该系统存在两种可能，一种是绝对静态，因为没有可变性而没有状态，另一种是绝对连续动态的，因而没有有意义的瞬时状态。</p><p>Promise为核心的并行语言特性，实际上就是一个三状态数据的可编程系统，另一方面JS建议使用let/const来代替var本质上就是在控制数据的可变性（作用域），以便达到在该范围内减少状态总数的目的</p><h4 id="4-2-5-2-原则二：最小逻辑和最大复用"><a href="#4-2-5-2-原则二：最小逻辑和最大复用" class="headerlink" title="4.2.5.2 原则二：最小逻辑和最大复用"></a>4.2.5.2 原则二：最小逻辑和最大复用</h4><p>将尽可能多且明确的逻辑内聚，以得到更大粒度的复用单元。仍然是Promise和Generator，它们在向外暴露明确的一致性的接口的同时，是将其内部封装的语义和逻辑整体作为复用单元的。</p><h4 id="4-2-5-3-原则三：语法在形式上的清晰与语义一致性"><a href="#4-2-5-3-原则三：语法在形式上的清晰与语义一致性" class="headerlink" title="4.2.5.3 原则三：语法在形式上的清晰与语义一致性"></a>4.2.5.3 原则三：语法在形式上的清晰与语义一致性</h4><p>从根本上来说Promise的语法存在一个及其致命的问题，<code>.catch()</code>借用了<code>try...catch</code>的语义，但是触发的主体并不相同，<code>.catch</code>是上一个promise，例如<code>.then</code>，而并不是最初的promise，这一点和触发<code>try...catch</code>的触发是在<code>try</code>语句块中有很大的不同，这两个逻辑存在“异常发生者与发出的位置”的不一致，于是给使用者带来了困扰</p><h2 id="4-3-声明"><a href="#4-3-声明" class="headerlink" title="4.3 声明"></a>4.3 声明</h2><p>声明和声明式编程是无关的，是不同的概念</p><p>JS的所有声明都针对标识符名字，以表明改名字在三个方面的性质：标识、值和确定性</p><h3 id="4-3-1-声明名字"><a href="#4-3-1-声明名字" class="headerlink" title="4.3.1 声明名字"></a>4.3.1 声明名字</h3><p>所有声明语句都至少包括一个名字的声明</p><p>在声明是名字不绑定值得，称为后绑定</p><p>同时声明名字和值得时候，具体得绑定操作是在JS引擎在一个“置值过程”中完成的</p><p>一些名字声明和绑定过程是同时发生并交由引擎在“初始化环境”时完成得。这个过程对用户代码是不可见的，例如函数声明</p><h3 id="4-3-2-确定性"><a href="#4-3-2-确定性" class="headerlink" title="4.3.2 确定性"></a>4.3.2 确定性</h3><p>JS中除了const和namespace之外得所有语句声明得名字都是使用<code>MutableBinding</code>来创建的，因此我们总是可以重写标识符。这是JS动态语言特性的体现</p><p>然而函数表达式式字面量风格的值，而非语句，对于此，JS约定，所有类型的函数表达式——在它作为独立语法元素（表达式的操作数）的环境中，是不可置值得</p><pre><code class="js">function foo() {  foo = 100;  console.log(foo) // 100}foo() (function foo() {  foo = 100;  console.log(foo) // [Function: foo]})();</code></pre><h3 id="4-3-3-顶层声明"><a href="#4-3-3-顶层声明" class="headerlink" title="4.3.3 顶层声明"></a>4.3.3 顶层声明</h3><p>JS代码中的顶层声明是被特殊处理的，所谓顶层声明是指一个块中所有声明语句或其第一层具名函数中的声明。</p><p>顶层声明包括“顶层词法声明”和“顶层变量声明”两种。</p><p>主要就是var的变量提升的问题，函数和var同理</p><h2 id="4-4-语句与代码分块"><a href="#4-4-语句与代码分块" class="headerlink" title="4.4 语句与代码分块"></a>4.4 语句与代码分块</h2><p>排除所有用于声明的语句之后，剩下的所有非声明语句，都是过程叙述性质的</p><ul><li>陈述一个过程<ul><li>陈述将被组织的元素</li><li>陈述上述元素之间的结构方法</li></ul></li><li>表达经过上述陈述语句陈述过程之后的结果值</li></ul><h3 id="4-4-1-块"><a href="#4-4-1-块" class="headerlink" title="4.4.1 块"></a>4.4.1 块</h3><p>如果将一段代码理解为一个形式上的块（x），那么块x中除去简单语句（它们不构成自己的形式分块），其他部分也是分块的：</p><ul><li>简单语句是该块x的成员</li><li>其他分块是子集的块</li></ul><h4 id="4-4-1-1-简单语句"><a href="#4-4-1-1-简单语句" class="headerlink" title="4.4.1.1 简单语句"></a>4.4.1.1 简单语句</h4><p>可以将大多数表达式语句、空语句和debugger语句等归为一类，称为简单语句</p><p>简单语句自身并不构成代码的形式分块</p><h4 id="4-4-1-2-单值表达式"><a href="#4-4-1-2-单值表达式" class="headerlink" title="4.4.1.2 单值表达式"></a>4.4.1.2 单值表达式</h4><p>一个块意味着一个独立的计算环境，可以有自己的内部标识符列表等，这可以理解为对“结构化编程”中信息隐蔽的体现。由于在概念上，表达式本身的计算环境依赖于它所在的语句，因此表达式本身是不需要分块的。进一步的，表达式作为简单语句也是没有分块的</p><p>但是JS中的值可以构成单值表达式，并进一步构成单值表达式语句，因为单值中的“字面量风格的值”本身是需要一个独立的计算过程与环境的，但是即便如此，这些单值表达式所在的“简单语句本身”也是没有对应形式的分块的</p><h3 id="4-4-2-块与语句的语法结构"><a href="#4-4-2-块与语句的语法结构" class="headerlink" title="4.4.2 块与语句的语法结构"></a>4.4.2 块与语句的语法结构</h3><p>多数语句都能用于组织逻辑，这包括全部的循环、分支和多重分支语句，以及各种控制结构子句、异常语句等。这些语句许多都是分块的，并且支持在块中包括更多的执行逻辑，以及更多子级的块。</p><h4 id="4-4-2-1-语义上的代码分块"><a href="#4-4-2-1-语义上的代码分块" class="headerlink" title="4.4.2.1 语义上的代码分块"></a>4.4.2.1 语义上的代码分块</h4><p>JS的语法设计中的块语句和with语句相对比较特殊，这在于它们本身的语义就是用于描述分块形式的</p><p>块语句<code>{}</code>在语义上就是顺序地组织一批语句，因此它可以直接描述三种基本逻辑中的顺序逻辑，并且——在语法性质上——它的整个块仍然是“一个”语句</p><h4 id="4-4-2-2-分支逻辑中的代码分块"><a href="#4-4-2-2-分支逻辑中的代码分块" class="headerlink" title="4.4.2.2 分支逻辑中的代码分块"></a>4.4.2.2 分支逻辑中的代码分块</h4><p>我们通常是利用“块语句是一个语句”的性质来得到一个形式分块，并“自然的”形成常见的代码风格的</p><p>但是if语句本身并没有一个代码的形式分块。因为语法设计上不必要</p><blockquote><p>一般if语句的形式分块是由<code>{}</code>创建的，并不是if语句自有的</p></blockquote><h4 id="4-4-2-3-多重分支逻辑中的代码分块"><a href="#4-4-2-3-多重分支逻辑中的代码分块" class="headerlink" title="4.4.2.3 多重分支逻辑中的代码分块"></a>4.4.2.3 多重分支逻辑中的代码分块</h4><p>多重分支具有一个形式分块，并且所有分支都共享这个自有的块</p><p>可以在各分支中使用自己独立的块语句和let/const声明，或者使用switch语句外部的声明</p><h4 id="4-4-2-4-循环逻辑中的代码分块"><a href="#4-4-2-4-循环逻辑中的代码分块" class="headerlink" title="4.4.2.4 循环逻辑中的代码分块"></a>4.4.2.4 循环逻辑中的代码分块</h4><p>只有在循环语句的循环条件中使用let/const声明了新名字时，才会存在代码分块</p><p>包括for…of、for await …of和for…in等在内的所有for循环，只要在循环条件中使用let/const声明了新名字时，那么就具有一个自有的形式分块，否则都没有这一特性</p><p>更进一步while/do…while循环也都不具备这样的特性，因为它们不具备“声明名字”的语义</p><p>使用let声明，每次循环体回创建一个新的环境避免重复声明的问题，所以如果不是循环体内具有并行机制，建议不要使用let/const</p><h4 id="4-4-2-5-异常中的代码分块"><a href="#4-4-2-5-异常中的代码分块" class="headerlink" title="4.4.2.5 异常中的代码分块"></a>4.4.2.5 异常中的代码分块</h4><p>在try语句的语法中，所有<code>{}</code>都是标准的块语句语法的形式分块，由于catch\finally块必须至少存在一个，所以try语句拥有的形式分块大概有两到三个</p><p>每个形式分块都是独立执行的，与其他块无关，因此可以在不用的块使用let声明相同的名字</p><h3 id="4-4-3-块与声明语句"><a href="#4-4-3-块与声明语句" class="headerlink" title="4.4.3 块与声明语句"></a>4.4.3 块与声明语句</h3><h4 id="4-4-3-1-只能在块中进行数据声明"><a href="#4-4-3-1-只能在块中进行数据声明" class="headerlink" title="4.4.3.1 只能在块中进行数据声明"></a>4.4.3.1 只能在块中进行数据声明</h4><pre><code class="js">while(false) let i = 0;</code></pre><p>因为JS引擎无法在while语句的相应位置初始化一个用于注册let/const所声明名字的环境，因此在所有的单语句中都不能使用let/const来进行数据声明</p><h4 id="4-4-3-2-能同时声明块的声明语句"><a href="#4-4-3-2-能同时声明块的声明语句" class="headerlink" title="4.4.3.2 能同时声明块的声明语句"></a>4.4.3.2 能同时声明块的声明语句</h4><p>语句可以在声明变量名的同时声明一个形式分块，例如函数声明（语句）</p><p>于此类似import语句也具备这一性质</p><p>函数所声明的形式分块包括它的函数名和参数名，并且它的函数名将会在“所在的块”中进行一次等级，而模块所声明的形式分块则另据特殊性，因为模块的作用机制约定——同一模块的多次import之间会共享同一个块（以及其环境），因此事实上它的形式分块不是由import语句来创建的，而是由JS引擎在装配模块的过程中创建的</p><blockquote><p>函数表达式和函数声明语句的主要不同，在于后者会将在“所在的块”中登记函数名，这也是不存在“声明匿名函数的语句”这样的语法的原因</p></blockquote><h4 id="4-4-3-3-声明语句与块的组织"><a href="#4-4-3-3-声明语句与块的组织" class="headerlink" title="4.4.3.3 声明语句与块的组织"></a>4.4.3.3 声明语句与块的组织</h4><p>更多的函数、语句与模块构成了JS文件</p><p>在Es6之前JS还没有模块和程序的概念，而是所有的块都视为有顺序关系的代码片段，这个时期的JS并没有约定块何时以及如何装载的引擎中，因此引擎通常对载入的每个代码先做语法分析，而后从第一条语句开始执行——即使这条语句看起来并不合理，JS进行不了有效的、可预期得分析</p><p>但从es6开始，JS提出了模块的概念，这些模块通常是拓展名为.js的JS文件，此时：</p><ul><li>所有声明语句，要么是在声明标识符，要么就是在声明块</li><li>JS约定所有的声明都必须在语法分析期处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记8</title>
    <link href="undefined2020/07/green8/"/>
    <url>2020/07/green8/</url>
    
    <content type="html"><![CDATA[<h2 id="3-6-运行期侵入和元编程系统"><a href="#3-6-运行期侵入和元编程系统" class="headerlink" title="3.6 运行期侵入和元编程系统"></a>3.6 运行期侵入和元编程系统</h2><p>到现在为止，我们将JS中有关面向对象编程的一切都放在原型继承的体系下来讨论，这一体系的基本特点是：属性就是一切，继承的本质就是对自有属性表的管理</p><p>但接下来不同，JS提供了多种混乱且杂糅的技术，允许开发人员在运行期侵入对象，具备了影响几乎所有对象相关运算符和语句的能力。这些手段渐渐称为了一个全新的技术内核，从而使元编程在JS语言中若隐若现</p><h3 id="3-6-1-关于运行期侵入"><a href="#3-6-1-关于运行期侵入" class="headerlink" title="3.6.1 关于运行期侵入"></a>3.6.1 关于运行期侵入</h3><p>早起的JS并没有提供运行期侵入的语法特性，有一些看起来类似的特性，也渐渐被识别出来并归类到动态语言特性中去了，例如<code>valueOf()</code>和<code>toString()</code>带来的动态类型特性，最早真正用于运行期侵入的是一个一直一来都未被规范的语法元素：对象的<code>__proto__</code>属性，它可以让开发人员直接操作（包括重写）对象的原型，进而影响instanceof运算符。</p><p><code>__proto__</code>属性反映了我们了解和影响JS内部运行逻辑的迫切需求，有些语言机制在不引入“内部属性”这一个概念的时候是很难讲清楚的，这些内部属性通常记作<code>[[internalPropertyName]]</code>。我们在前面的叙述中用到过三种内部属性，包括：</p><ul><li>[[HomeObject]]: 方法的主对象</li><li>[[Namespace]]: 名字空间对象</li><li>[[Extensible]]: 可扩展标记</li></ul><h4 id="3-6-1-1-运行期侵入的核心机制"><a href="#3-6-1-1-运行期侵入的核心机制" class="headerlink" title="3.6.1.1 运行期侵入的核心机制"></a>3.6.1.1 运行期侵入的核心机制</h4><p>对象在JS内部被描述为具有一些<strong>“内部槽”</strong>的结构体，操作这个结构体的方法被称为<strong>“内部方法”</strong>，并且基于此提供了处理对象各种行为的确定逻辑，然后JS对外公布了使用这些内部槽和内部方法的一组界面，从而赋予了开发人员侵入运行期（的处理逻辑）的能力</p><p>就目前来说，适用于基本对象的内部方法一共有11个，另外，适用于函数的内部方法有两个，这也就是JS的反射机制(Reflect和Proxy类)只有13个方法的原因，其中<code>Reflect</code>对象提供直接调用这些内部方法的能力、而Proxy则在这些内部方法外包裹了一层拦截器，以影响那些内部行为</p><p>基本对象的内部槽有且仅有两个，分别是[[prototype]]和[[Extensible]]。对象还持有一个自有属性表，当[[Extensible]]为true时，表明这个表可以增删和修改，当访问属性时。如果在自有属性表没找到指定属性，且[[prototype]]为非null值就表明可以上溯到该原型对象的自有属性表查找，直接操作这两个槽的方法有4个</p><table><thead><tr><th align="center">内部槽</th><th align="center">操作</th><th align="center">行为</th></tr></thead><tbody><tr><td align="center">[[prototype]]</td><td align="center">Object.getPrototypeOf(obj)</td><td align="center">取obj的[[prototype]]值</td></tr><tr><td align="center">[[prototype]]</td><td align="center">Object.setPrototypeOf(obj)</td><td align="center">置obj的[[prototype]]值</td></tr><tr><td align="center">[[Extensible]]</td><td align="center">Object.isExtensible(obj)</td><td align="center">取obj的[[Extensible]]值</td></tr><tr><td align="center">[[Extensible]]</td><td align="center">Object.preventExtensions(obj)</td><td align="center">置obj的[[Extensible]]值</td></tr></tbody></table><p>函数也会多出来两个内部槽[[Realm]]和[[ScriptOrModule]],[[Realm]]是指这个函数对象所在的区域（可以看作可执行环境的一个静态映像），而[[ScriptOrModule]]则指向初始化该函数的结构：脚本快、模块或者null(例如它是动态创建的)。但是JS并不提供任何直接访问函数对象的这些内部槽的任何方法，除此之外，它作为一个对象，即理解为<code>Function</code>类的一个实例，就和普通对象没有什么不同了。</p><h4 id="3-6-1-2-可被符号影响的行为"><a href="#3-6-1-2-可被符号影响的行为" class="headerlink" title="3.6.1.2 可被符号影响的行为"></a>3.6.1.2 可被符号影响的行为</h4><p>JS公布了一组面向内部机制的的<strong>符号属性</strong>，以访问这些<strong>内部槽</strong>。符号所指代的属性是被声明在对象的属性表中的，而并不是上述的内部槽。通过符号属性来影响内部机制的方法存在很大的局限性，并且与后边要将到的反射机制迥然不同</p><h5 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h5><p>仅对原生的objct.prototype.toString方法有效，如果子类覆盖了该方法，则新方法未必会读取该属性</p><pre><code class="js">var obj = {  [Symbol.toStringTag]: &#39;something&#39;};console.log(obj.toString()); // [object something]</code></pre><h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>toPrimitive指向的函数需要将target对象转换为值数据的情况下就会被调用，例如<code>&#39;1&#39; + target</code>其界面的hint值用于表明试图转换为值的类型，包括’number’、’string’或使用’default’表示上述二者之一（皆可）</p><pre><code class="js">var obj = {  [Symbol.toPrimitive](hint) {    if(hint == &#39;number&#39;) return NaN;    return &#39;invalid&#39;  }}console.log(&#39;&#39;+obj) // &#39;invalid&#39;console.log(+obj) // NaN</code></pre><h5 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h5><p>hasInstance指向一个函数，在使用<code>obj instanceof target</code>这样的语法时，才会由引擎去访问，调用该函数并以其返回值作为运算的结果。并且事实上，JS中的<code>Function.prototype</code>就默认有一个这样的属性，所以我们总是可以对所有函数使用instanceof运算</p><h5 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h5><p>unscopables指向一个对象，该对象的每一个属性指明是否从<code>with</code>闭包中强制排除对应的<code>target.xxx</code>属性，这是因为<code>with(target)</code>语句在试图将属性名作为名字访问——需要用过<code>[[get]]</code>行为去访问target的指定属性——之前会用查表得方式查询<code>unscopables</code>对象</p><pre><code class="js">var f = new Function;var constructor = null; // 在with之外得标识符// 会访问f.prototype.constructorwith(f.prototype) console.log(f === constructor); // true// 排除f.prototype[Symbol.unscopables] = {constructor: true};// 会访问with外的标识符with(f.prototype) console.log(f === constructor); // false</code></pre><h5 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h5><p>isConcatSpreadable是一个布尔值，仅当target是一个数组或者类数组的集合对象并且试图使用<code>concat</code>来链接它时才有意义，值为true时就一个一个链接进入，为false就把当前数组作为一个整体放进去</p><h5 id="Symbol-match-Symbol-replace-Symbol-search-Symbol-split"><a href="#Symbol-match-Symbol-replace-Symbol-search-Symbol-split" class="headerlink" title="Symbol.match Symbol.replace Symbol.search Symbol.split"></a>Symbol.match Symbol.replace Symbol.search Symbol.split</h5><p>这四个符号都指向函数，如果目标对象使用了其中之一，那么会使对应的字符串操作收到响应的影响，以<code>str.split()</code>为例，假设我们要用一个一般对象（作为目标对象）来分隔字符串，那么只需要为它的Symbol.split为名字的属性设置一个分隔方法就可以了</p><pre><code class="js">var s = {}s[Symbol.split] = function(str, limit) {  return str.split(&#39; &#39; , limit)}var str = &#39;hello world&#39;console.log(str.split(separator));// 或者class S {  [Symbol.split](str, limit) {    return str.split(this.separator || &#39; &#39;, limit)  }}var tor = new S();console.log(&#39;hello world&#39;.split(tor))tor.separator = &#39;,&#39;console.log(&#39;hello,world&#39;.split(tor))</code></pre><p>这也是为什么split的第一个参数可以是正则表达式的原因</p><pre><code class="js">console.log((new regExp)[Symbol.split])// [Function: [Symbol.split]]</code></pre><p>当obj[Symbol.match]不是一个undefined值，并且可以转换为布尔值true时，JS会尝试将对象理解为一个正则表达式，如果出问题就会报错</p><h5 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h5><p>最后需要特别指出的是<code>species</code>符号，它指向一个构造器函数，主要影响JS内部隐式创建对象的行为，例如使用如下代码时</p><pre><code class="js">var newArray = arr.slice(0, 2);</code></pre><p>就会产生一个新的Array()对象，并且将在隐式创建这个新对象时访问属性</p><pre><code class="js">arr.constructor[Symbol.species]</code></pre><p>来决定使用哪个构造器。</p><h4 id="3-6-1-3-内部方法与反射机制"><a href="#3-6-1-3-内部方法与反射机制" class="headerlink" title="3.6.1.3 内部方法与反射机制"></a>3.6.1.3 内部方法与反射机制</h4><p>对象可以用自己的处理过程来覆盖内部方法，这称为自有内部方法。JS在调用内部方法时，会优先使用对象自有的方法。JS许多内建的对象许多都是这样的，当这些内建对象的构造器创建一个实例时邮寄换传入一张表，来覆盖内部方法。</p><p>其中反射机制中的Proxy对象提供了覆盖全部十三种内部方法的能力，从而实现了对任意对象的侵入。一个代理对象（Proxy）可以代理一个目标对象的全部行为，并通过在助手对象<code>handler</code>上的陷阱来响应”在代理对象上发生的“指定行为。代理对象就好像在拦截目标对象之前的防火墙</p><p>JS并不直接调用<code>handler.xxx</code>这样的陷阱方法，而是调用Proxy()实例的自有内部方法，并由后者来决定如何使用陷阱方法，对于proxy对象的自有内部方法，它们都有着基本相同的逻辑</p><p>虽然Proxy的侵入路径很好，但是也会出现一些问题</p><p>问题一：部分JS内部检测会绕过代理，譬如new运算会检测目标函数是否是构造器，这是通过检查其[[constructor]]内部方法槽是否有值来实现的，即使在Proxy里边设置了代理，但是仍然会被绕过导致某些情况下的错误，例如代理的对象是箭头函数</p><p>问题二：这些方法内部也是互相调用的，并非原子操作，进而带来了递归调用的可能，会破坏系统的稳定性</p><p>非原子操作：<code>[[DefineOwnProperty]]</code> <code>[[Delete]]</code> <code>[[HasProperty]]</code> <code>[[Get]]</code> <code>[[Set]]</code></p><h4 id="3-6-1-4-侵入原型"><a href="#3-6-1-4-侵入原型" class="headerlink" title="3.6.1.4 侵入原型"></a>3.6.1.4 侵入原型</h4><p>Object是JS对象系统的基类，然而我们并不能重置它的原型，这是ECMA规范对Object.prototype的一点限制，确保它总是由宿主或者脚本引擎来进行初始化。且一旦初始化之后，就不可已被改变（非可变原型）具体的做法就是让Object.prototype的自有内部方法[[SetPrototypeOf]]指向一个特定的逻辑：</p><ul><li>如果置值等有既有的值，返回true</li><li>置初值之外的任何值，均返回false</li></ul><p>处于同样的原因，JS也将Object.prototype属性的性质设置为不可写和不可重置</p><p>所以对于Object及其子类，只剩下一种侵入方法：拓展Object.prototype属性（包括添加和更新），从而影响所有以它为祖先类的子类和子类实例。也是利用JS的原型继承特性进行侵入的、原生的、传统的手段：</p><pre><code class="js">function MyObject() {}var obj = new Object;var obj2 = new MyObject;console.log(Object.isExtensible(Object.prototype)); // true// 拓展Object.prototypeObject.prototype.x = 100;console.log(obj.x) // 100console.log(obj2.x) // 100</code></pre><p>当然也可以给Object.prototype添加前边所讲述的符号属性，例如使用Symbol.iterator来让所有对象都可迭代</p><p>这显然不够。事实上我们可以做的更多——只是这样的操作不能在Object.prototype上做罢了。比如侵入它的子类的一个原型，我们有机会在子类和基类之间插入一个代理，从而完全透明的侵入这个子类</p><pre><code class="js">function intrudeOnPrototype(Class, handler) {  var orginal = Object.getPrototypeOf(Class.prototype);  var target = Object.create(orginal)  var {proxy, revoke} = Proxy.revocable(target, handler);  Object.setPrototypeOf(Class.prototype, proxy)  return () =&gt; revoke(Object.setPrototypeOf(Class.prototype, orginal))}var str = new String(&#39;OldString&#39;);var recovery = intrudeOnPrototype(String,{  get: function(target, prop) {    if(prop == &#39;t&#39;) return 100;    return Reflect.get(...arguments);  }});var str2 = new String(&#39;NewString&#39;);// 原型没有变化console.log(Object.getPrototypeOf(str) == Object.getPrototype(str2));  // trueconsole.log(str.t) // 100console.log(str2.t) // 100// Object没有受到影响console.log((new Object).t) // undefined// 重置recovery();console.log(str.t) // undefinedconsole.log(str2.t) // undefined</code></pre><p>在这个例子中，我们需要注意到一个事实，String.prototype的原型就是Object.prototype</p><p>所以关键在于第二行得到的orginal变量，也就是Object.prototype在代码全程没有被修改，而且在第四行代码中，revecable()创建代理其实是以orginal为原型的实例target——所以事实上也没有修改String.prototype，却完成了侵入，更进一步可以针对target来使用其他的侵入手段，也是安全的，可撤销的</p><h3 id="3-6-2-类类型与元类继承"><a href="#3-6-2-类类型与元类继承" class="headerlink" title="3.6.2 类类型与元类继承"></a>3.6.2 类类型与元类继承</h3><p>运行期侵入只是元编程的冰山一角。事实上，深入理解语言机制，可以让我们在更多方面进行拓展，例如构建自己的对象系统或者自己的继承体系，这其中就包括在JS中没有显式支持的元类和元类继承</p><p>这里所说的类（class），是指用class关键字声明的类，包括静态类和类表达式</p><p>而所谓的元类（meta class），是指能产生类的类</p><h4 id="3-6-2-1-原子"><a href="#3-6-2-1-原子" class="headerlink" title="3.6.2.1 原子"></a>3.6.2.1 原子</h4><p>最小颗粒度的运算对象显然是值，包括undefined、boolean、string、number和Symbol。它们都是ECMA所约定的原始值。但如果只考虑JS的对象系统，那么它的原子就是<code>Object.create(null)</code></p><p>这种atom对象具有一般对象的全部性质，也适用于所有对象的操作或运算；它比空白对象更原始，却又不像null一样表示对象类型中的“无值”，并且，atom对象是不受Object.prototype影响的，因为它甚至都不是Object实例</p><pre><code class="js">type atom // &#39;object&#39;atom instanceof Object // false</code></pre><p>那么最小粒度的类又是什么样子的呢？显然，它应该是以atom为原型的类：</p><pre><code class="js">var Atom = new FunctionObject.setPrototypeOf(Atom.prototype, null)</code></pre><p>原子类仍然不是元类，这个原子类构造出来的仍然是对象实例——这些实例与上例中的atom有相同的性质，这也意味着我们有三种方式来得到atom实例：</p><pre><code class="js">// 方法一var atom = Object.create(null)// 将任意对象的原型置为nullvar atom = Object.setPrototypeOf(new Object, null)// 方法三实例的原型不是null而是另一个atomvar atom = new Atom;</code></pre><h4 id="3-6-2-2-元与元类"><a href="#3-6-2-2-元与元类" class="headerlink" title="3.6.2.2 元与元类"></a>3.6.2.2 元与元类</h4><p>现在让我们来考虑元类的问题，由于类是函数（构造器），因此所谓元类必须是能“产生函数的函数”，基于这一定义，可以这样来得到它：</p><pre><code class="js">class Meta extends Function {  // ...}</code></pre><p>这的确是可行的，但是我们考虑到元类本身也应当是一个原子，并且——如同在概念上所定义的——它应该能产生一个类，所以更高的处理方法是这样的</p><pre><code class="js">// 元（元语言、元编程体系的基类型 v1.0）class Meta extends null {  constructor() {    return Object.setPrototypeOf(class extends null{      constructor() {        return Object.create(new.target.prototype);      }    }, new.target)  }}</code></pre><p>那么Meta和Atom的关系是什么？</p><p>留意第四行代码中的一个类表达式（字面量风格声明的值），是一个父类为null，匿名的类，它实际与前面的原子构造器有相同的语义和相同的效果</p><p>因为Meta的构造方法返回的实例就是这样的一个类表达式，即原子函数，即Atom。所以 ，我们也就得到了Atom（原子构造器、原子类）的第二种声明方式：</p><pre><code class="js">// 原子类var Atom = new Meta;</code></pre><p>考虑到要将Meta作为元编程的原子模型，它自己也必须是最小粒度的，因此它的原型也是Atom。</p><pre><code class="js">Object.setPrototypeOf(Meta, null)</code></pre><p>于是我们就有了两个继承体系，一个是以Atom为基类的对象继承系统，另一个是以Meta为基类的类继承系统，为了和JS已有的构造器名字有所区别</p><pre><code class="js">// 元类// 仅用于建立一层抽象语义class MetaClass extends Meta {}// 元对象（类）// 隐含的声明了MetaObject拓展自Atom类class MetaObject extends new MetaClass {}</code></pre><p>注意在这两个声明中，MetaClass只是对Meta的一个简单继承，用于建立一层抽象概念上的子模型。因此new MetaClass 和new Meta的结果实际上是一样的，只有语义上有区别</p><p>因此。事实上MetaObject就是Atom的子类</p><h4 id="3-6-2-3-类类型系统"><a href="#3-6-2-3-类类型系统" class="headerlink" title="3.6.2.3 类类型系统"></a>3.6.2.3 类类型系统</h4><p>我们说MetaObject是Atom的子类，即MetaClass的实例，然而下边的结果和我们的预期相反</p><pre><code class="js">MetaObject instanceof MetaClass // false</code></pre><p>问题出在运算符instanceof的一项约定，当它的右操作数是一个函数时，则使用该函数的.prototype来检查原型链，因为在这个表达式中，函数指代的是类（构造器），它之于对象实例的原型是Constructor.prototype（而不是构造器自身）</p><p>之前我们讲到过可以通过Symbol.hasInstance来实现：对象构建自对象这样的语义，同样我们也可以用这个符号来实现：函数构建自函数</p><pre><code class="js">class Meta extends null {  constructor() {    return Object.setPrototypeOf(class extends null{      constructor() {        return Object.create(new.target.prototype);      }      // 使instanceof恢复到默认      static [Symbol.hasInstance](obj) {        return Object.prototype.isPrototypeOf.call(this.prototype, obj);      }    }, new.target)  }  // 让元及其子类在instanceof运算中以自身作为操作数  static [Symbol.hasInstance](obj) {    return Object.prototype.isPrototypeOf.call(this, obj);  }}Object.setPrototypeOf(Meta, null);class MetaClass extends Meta {}class MetaObject extends MetaClass {}</code></pre><p>于是我们得到了一个对JS元编程的全新拓展，即所谓的“类类型系统”，主要用于定义类以及操作类的类型信息。由于它是指从MetaClass开始拓展的类型系统，因此也可以称为“元类类型系统”。现在在这个系统中，我们已经可以开始创建第一个对象了：它是一个简单的、所谓更加空白的对象，没有任何自有属性</p><pre><code class="js">MetaObject instanceof MetaClass // trueMetaClass instanceof Meta // true// 对象var obj = new MetaObjectobj instanceof MetaObject // true// obj不是Object()或其子类的实例obj instanceof Object // false// obj 是对象typeof obj // &#39;object&#39;</code></pre><h4 id="3-6-2-4-类类型的检查"><a href="#3-6-2-4-类类型的检查" class="headerlink" title="3.6.2.4 类类型的检查"></a>3.6.2.4 类类型的检查</h4><p>新的类类型系统不尽带来了它的最终产物“原子对象”，还带来了一个新的概念：类类型。这在本质上是对类的衍生和系统化做出了另一种规范：在旧式的类继承中。类是由父类拓展而来的，而在类类型的体系中，类是由类类型创建出来的</p><blockquote><p>已经看不懂了，不浪费时间了，找时间看完元类型再继续回来看</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记7</title>
    <link href="undefined2020/07/green7/"/>
    <url>2020/07/green7/</url>
    
    <content type="html"><![CDATA[<h3 id="3-4-3-构造对象系统的方法"><a href="#3-4-3-构造对象系统的方法" class="headerlink" title="3.4.3 构造对象系统的方法"></a>3.4.3 构造对象系统的方法</h3><p>JS的原型继承并不是唯一构造系统的方法，由语言提供的、原生支持的方法还包括类抄写、类继承、以及直接创建对象等，其他可以在ECMAScript语言基础上拓展的方法包括元继承、元类继承等</p><h4 id="3-4-3-1-类抄写"><a href="#3-4-3-1-类抄写" class="headerlink" title="3.4.3.1 类抄写"></a>3.4.3.1 类抄写</h4><p>子类的构造逻辑：先向父类传入this引用以抄写父类方法，再向子类传入this引用抄写子类方法，后者覆盖前者的同名成员。整个构造过程都是在不断的从“类构造器”向this引用抄写成员，所以被称为类抄写</p><p>这种方法也有好处。由于这种方法是通过不断修改实例（this）的成员来得到对象的，因此所有的属性都在实例（this）的自有属性表中，进一步的推论是访问任何成员都不必回溯原型链，因而效率更高</p><p>类抄写的第二个问题是系统并不维护原型继承链。因此在类抄写构建的系统中，不能用<code>instanceof</code>来检测继承关系</p><h4 id="3-4-3-2-原型继承"><a href="#3-4-3-2-原型继承" class="headerlink" title="3.4.3.2 原型继承"></a>3.4.3.2 原型继承</h4><p>存在缺陷；</p><ul><li>在维护构造器引用和外部原型链之间无法平衡</li><li>没有提供调用父类方法的机制</li></ul><p>还是一个典型的时间换空间的方案：继承层次中临近的成员访问更快，而试图访问一个不存在的成员耗时最久</p><h4 id="3-4-3-3-类继承"><a href="#3-4-3-3-类继承" class="headerlink" title="3.4.3.3 类继承"></a>3.4.3.3 类继承</h4><p>类继承是对原型继承的增强，也是一种再实现</p><p>从纯粹概念上说，“原型也是对象实例”是一个极为关键的性质，这是它与类继承体系本质上的不同，对于类继承来说，类不必是对象，因此类也不必具有对象的性质，类可以是一个内存块，也可以是一段描述文本，而不必是一个有对象特性的结构</p><ul><li>类的实例是创建自基类的</li><li>类构造方法的调用顺序是逆向的</li></ul><h4 id="3-4-3-4-直接创建对象"><a href="#3-4-3-4-直接创建对象" class="headerlink" title="3.4.3.4 直接创建对象"></a>3.4.3.4 直接创建对象</h4><p>脱离传统的new运算直接创建对象，是对原型继承模型的简化</p><p>无论是经典的原型继承还是class来声明的类继承，都会用new运算调用一次构造器函数，“构造”这一过程既包括对原型链的维护，也包括对新实例的修饰——甚至可以使用<code>Reflect.construct()</code>来代替<code>new</code>运算，以便更加细致的控制构造过程中<code>new.target</code>和所创建实例的<code>constructor</code>的值。</p><p>new运算的可替代性，让我们注意到一个事实，所谓原型继承，其本质只是“复制原型“，即以原型为模板复制一个新的对象，构造函数与<code>new</code>运算等过程所附加的效果，其实对复制原型来说是无意义的</p><p>其构造器函数对实例的这种修饰作用——对于原型继承来说——可有可无。于是就出现了<code>Object.create</code>这样的一种简单的方法，它将”构造器函数“从对象创建过程中赶了出去，在这种机制中，对象变成了简单的”原型继承+属性定义“，而不再需要”构造器“这样一层语义</p><p><code>Object.create()</code>只是能避免使用构造器来设置新实例原型的一种方法。它没有了在构造器修饰对象实例的这一过程，但和class声明一样，在本质上仍然是原型继承</p><h4 id="3-4-3-5-如何选择继承的方式"><a href="#3-4-3-5-如何选择继承的方式" class="headerlink" title="3.4.3.5 如何选择继承的方式"></a>3.4.3.5 如何选择继承的方式</h4><p>类抄写与原型继承正好是互补的两种方案</p><ul><li>类抄写时成员访问效率更高，但内存占用更大；而原型继承反之</li><li>类抄写不依赖内部原型链来维护继承关系，因此也不能通过<code>instanceof</code>来做这种检测；原型继承却维护着这种继承关系也可以用于检测</li></ul><p>JS根本上是针对小型系统和轻量应用环境设计的，它兼具“动态、函数式、原型继承”等多种语言特性，在灵活多变的同时也带来了一种混杂的程序设计语言知识体系，其结果是易学难精，而且越是深入底层越容易感到混乱，它虽然能组织大型对象系统，但又对大型对象系统的封装和多态处理的不够，所以在大型应用中常常束手束脚，心有余而力不足，这也是ES6之后在类继承语言特性设计上所主要需要解决的问题，包括更强的封装特性，以及类静态语法注解等等</p><p>在继承方式的选择上，仍应择需而用：其一，在大型系统上必须采用类继承的思想，继承关系的确定性和支持静态语法检测等特性，可以帮助开发者最终简化构建大型系统开发和业务逻辑的实现，并提供足够的系统稳定性，=；其二，在小型结构或者体系的局部使用原型继承的思路，既可以有优美的实现和高效的性质，也可以深入地理解JavaScript中混合不同语言特性的精髓</p><h3 id="3-4-4-内置的对象系统"><a href="#3-4-4-内置的对象系统" class="headerlink" title="3.4.4 内置的对象系统"></a>3.4.4 内置的对象系统</h3><p>标准规范下的JS有38个内置对象，包括7个在语法形式上具有字面量风格的声明，其中三种字面量(Number、Boolean、String)定义的是值类型数据，可以通过包装类转换至相应的对象类型。</p><p>特殊类型<code>Global</code>它只有一个全局存在的单例，即所谓的<code>global</code>。由于没有任何规范要求在JS环境中存在一个名为<code>global</code>的变量并指向上述对象，或者显式地定义其构造器函数<code>Global()</code>，因此唯一能在所有引擎中通用的、得到<code>global</code>对象的方法，是借用<code>Function</code>对象来实现的</p><pre><code class="js">var global = (new Function(&#39;return this&#39;))();</code></pre><p>一旦得到这个对象，就可以列举这个对象中的全局名字，这些名字就是你可以访问的整个内置对象系统，以及所有“泄露”到全局的变量（它们也作为global的属性，以便作为一个全局可以访问的标识符来使用）</p><p>理解<code>Global()</code>类与<code>global</code>对象，是理解JS内置对象系统的起点，它既代表了这个系统中逻辑执行的最终范围，也代表了这个系统的全体。因此下边的代码在语义和执行效果上是一致的</p><pre><code class="js">new Object()new global.Object()</code></pre><h4 id="3-4-4-1-早期规范中的对象"><a href="#3-4-4-1-早期规范中的对象" class="headerlink" title="3.4.4.1 早期规范中的对象"></a>3.4.4.1 早期规范中的对象</h4><p>与<code>global</code>对象类似，<code>Arguments</code>也是在早起就被规范过的对象，并且也没有一个显式声明过的构造器，<code>Arguments()</code>实例总是由函数引擎在函数调用时动态创建并添加在函数闭包中的，因此能在函数执行代码中直接使用<code>arguments</code>这个标识符，它看起来像是一个数组，但是并非数组对象</p><p>另一个早起规范过的对象是<code>Error()</code>构造器，它用于创建一个可以用throw语句抛出的错误对象</p><p>此外，最常见的对象是<code>Date()</code>构造器，JS中的时间是从19700101:00:00为相对基点的毫秒数</p><p>还有一个就是<code>Math</code>，它不是构造器，而是作为全局单例对象提供了一些数学运算相关的方法</p><p>有且仅有一个对象不在<code>global</code>所代表的对象系统中，即不能由它们的类或者子类创建，这就是<code>null</code>对象，JS中的<code>Null</code>作为类型只有一个字面量形式的<code>null</code>值，并且它也是一个对象，与<code>null</code>作为对象不同的是，<code>undefined</code>是一个值，但是被定义在了<code>global</code>中</p><pre><code class="js">Object.getOwnPropertyDescripter(global, &#39;undefined&#39;)/*value: undefined,writable: false,enumerable: false,configurable: false*/</code></pre><h4 id="3-4-4-2-集合对象"><a href="#3-4-4-2-集合对象" class="headerlink" title="3.4.4.2 集合对象"></a>3.4.4.2 集合对象</h4><p>JS提供两种集合(Collection Types)对象，其中索引集合包含数组和类型化数组，而键值集合包括Map、WeakMap、Set、WeakSet。此外，JS也设计了语句<code>for..of</code>用于列举集合中的成员</p><p>但是数组本质上和对象没啥不同，我们也不认为<code>Array()</code>对象的各个元素在具体引擎中进行存储时有着内存地址的连续性，因此JS的数组时异质、交错和稀疏的，可以存在不连续的下标，以及保存任意类型的元素</p><p>由于存储的不连续性，以及元素的不一致，因此有着巨大的性能问题，所以JS也提供了类型化数组</p><p>数组本质上时提供集合元素有序访问的，而键值集合(Keyed Collections)则是无序的，其中<code>Map()</code>对象是一个键值对的集合，其<code>get()/set()、delete()、has()</code>等主要运算时面向键值对的key的，而<code>Set()</code>对象则强调集合中的元素值无重复，主要运算<code>add()、delete()、has()</code>等都是操作元素的值的。</p><h4 id="3-4-4-3-结构化数据对象"><a href="#3-4-4-3-结构化数据对象" class="headerlink" title="3.4.4.3 结构化数据对象"></a>3.4.4.3 结构化数据对象</h4><p>所有的<code>TypedArray</code>对象其实都是结构化的数据(Structured Data)，它们本身也都是基于<code>ArrayBuffer()</code>对象来实现的</p><h4 id="3-4-4-4-反射对象"><a href="#3-4-4-4-反射对象" class="headerlink" title="3.4.4.4 反射对象"></a>3.4.4.4 反射对象</h4><p>通过反射(Reflection)机制，可以访问、检测和修改对象的内部状态和行为，其中，反射对象<code>Reflect</code>用于提供反射机制的一个常用界面——但它不是使用反射机制的唯一方法。Reflect对象的功能可以通过其他方法或者语法实现</p><table><thead><tr><th>Reflect.xxx方法</th><th>可替代方法</th><th>备注</th></tr></thead><tbody><tr><td>apply(target, …)</td><td>target.apply()</td><td>调用函数</td></tr><tr><td>construct(target, args, …)</td><td>new target(…args)</td><td>创建实例（注1）</td></tr><tr><td>getPrototypeOf(target)</td><td>Objcet.getPrototypeOf(target)</td><td>读原型</td></tr><tr><td>setPrototypeOf(target)</td><td>Objcet.setPrototypeOf(target)</td><td>写原型</td></tr><tr><td>get(target, prop, …)</td><td>target[prop]</td><td>属性读</td></tr><tr><td>set(target, prop, …)</td><td>target[prop] = xxx</td><td>属性写</td></tr><tr><td>has(target, prop)</td><td>prop in target</td><td>属性检查</td></tr><tr><td>deleteProperty(target, prop)</td><td>delete target[prop]</td><td>属性表删除</td></tr><tr><td>defineProperty(target, …)</td><td>Object.defineProperty()</td><td>属性表增加</td></tr><tr><td>getOwnPropertyDescriptor(…)</td><td>Object.getOwnPropertyDescriptor()</td><td>属性表列举</td></tr><tr><td>ownKeys(target)</td><td>（注2）</td><td>属性表列举</td></tr><tr><td>isExtensible(target)</td><td>Object.isExtensible(target)</td><td>属性表管理（禁止拓展）</td></tr><tr><td>perventExtensions(target)</td><td>Objcet.perventExtensions(target)</td><td>属性表管理（禁止拓展）</td></tr></tbody></table><blockquote><p>注1：考虑到在构造器中<code>new.target</code>的设置该方法没办法通过Shim代码完整实现</p></blockquote><blockquote><p>注2：该方法返回全部自有的字符串键名和符号键名的属性，可以用如下类似代码代替</p></blockquote><pre><code class="js">function Reflect_ownKeys(target) {  return Objcet.getOwnPropertySymbols(target)    .concat(Objcet.getOwnPropertyNames(target))}</code></pre><p><code>Reflect</code>对象用于调用对象的行为，于此不同<code>Proxy</code>类从另一个角度来实现反射，它用于改变对象的行为。Proxy可以代理目标对象的全部行为，并通过助手对象<code>handler</code>上的陷阱来响应“在代理对象上发生的”指定行为。这些行为的界面和<code>Reflect</code>是一致的，也就是说每个可被反射的<code>Reflect.xxx</code>方法都由一个对应的、可声明为<code>handler.xxx</code>的陷阱</p><h4 id="3-4-4-5-其他"><a href="#3-4-4-5-其他" class="headerlink" title="3.4.4.5 其他"></a>3.4.4.5 其他</h4><p>JS提供了一类称为“控制抽象”的对象，包括迭代器、生成器、Promise类</p><h3 id="3-4-5-特殊效果的继承"><a href="#3-4-5-特殊效果的继承" class="headerlink" title="3.4.5 特殊效果的继承"></a>3.4.5 特殊效果的继承</h3><p>一些内置对象具有特殊效果，譬如一些值可以在调用一些方法的时候当作对象处理，或者函数对象可以执行等等</p><p>使用一般原型继承会导致子类失去特殊效果，使用类继承就可以了</p><h2 id="可定制的对象属性"><a href="#可定制的对象属性" class="headerlink" title="可定制的对象属性"></a>可定制的对象属性</h2><p>在完全不考虑对象如何实现和存储的情况下，仅其语义而言：对象，就是一组（零到任意多个）属性的集合，即所谓的“对象是属性包”。所以属性的性质也并不用于描述该属性的类型或者作用，而主要描述这个属性和集合之间的关系，这些关系有三种：<code>Writable</code>（可写）、<code>Enumerable</code>（可枚举）、<code>Configurable</code>（可配置）。除此之外一个属性本身还具有两种性质：Name、Value，即名字和值。</p><h3 id="3-5-1-属性描述符"><a href="#3-5-1-属性描述符" class="headerlink" title="3.5.1 属性描述符"></a>3.5.1 属性描述符</h3><p>在使用字面量时，其实是用“名称、值”的方式快速地定义了上述属性性质的一个简化版</p><pre><code class="js">obj = {  name: &#39;value&#39;}</code></pre><p>而JS内部使用属性描述符的不同，可以分成两类：</p><ul><li>数据属性： a named data property,兼容ES3的一般属性，如上例中的obj.name</li><li>存取属性： a named accessor property, 用 get/set 定义的属性</li></ul><h4 id="3-5-1-1-数据描述符"><a href="#3-5-1-1-数据描述符" class="headerlink" title="3.5.1.1 数据描述符"></a>3.5.1.1 数据描述符</h4><p>仍以上例为例，它的描述符如下</p><pre><code class="js">{  value: &#39;value&#39;, // 数据描述，默认undefined  writable: true, // 是否可写,默认true，  enumerable: true, // 是否可列举，默认true  configurable: true // 是否可重新配置，默认true}</code></pre><h4 id="3-5-1-2-存取描述符"><a href="#3-5-1-2-存取描述符" class="headerlink" title="3.5.1.2 存取描述符"></a>3.5.1.2 存取描述符</h4><p>带读写器的存取描述符与上述的数据描述符只能存在一种，而不可能同时存在，其格式为</p><pre><code class="js">{  get: function() {}, // 默认undefined  set: function(new_value) {}, // 默认undefined  enumerable: true,  configurable: true}</code></pre><p>必须具有get或者set两种方法之一，并且方法内可以通过this获取对象本身，也就获取到了访问对象本身其他成员或者调用它们的方法。</p><p>由于this指向对象本身，所以有可能间接的访问到当前属性，造成死锁，应注意避免</p><blockquote><p>在使用Object.defineProperty、Object.defineProperties 或 Object.create 函数的情况下添加数据属性，writable、enumerable和configurable默认值为false。</p></blockquote><h4 id="3-5-1-3-隐式创建的描述符：字面量风格的对象或者类声明"><a href="#3-5-1-3-隐式创建的描述符：字面量风格的对象或者类声明" class="headerlink" title="3.5.1.3 隐式创建的描述符：字面量风格的对象或者类声明"></a>3.5.1.3 隐式创建的描述符：字面量风格的对象或者类声明</h4><p>字面量声明对象风格中不存在对Enumerable和Configurable的定义，所以总是使用默认值true</p><p>在字面量声明过程中，只存在两种方式而且不能共存，分别是数据描述和存取描述</p><p>存取描述中只有<code>set</code>或者只有<code>get</code>就表明该属性是只写或者只读的，两个都有就可读写</p><p>使用类声明（包括字面量风格的类表达式声明）时，属性的描述符创建规则与上述一致，需要指出的是，类静态成员会声明为类的属性，而一般成员会声明为类的原型的属性</p><h3 id="3-5-2-定制对象属性"><a href="#3-5-2-定制对象属性" class="headerlink" title="3.5.2 定制对象属性"></a>3.5.2 定制对象属性</h3><p>在3.1.3对象成员中，我们将对象、类的属性从继承性的角度分为了两类</p><ul><li>自有属性： own properties，该属性创建于对象的自由属性表中</li><li>继承属性： inherited properites，该属性是父类原型上的自有属性（即创建于原型对象的自有属性表中）</li></ul><p>从子类对象的角度更加细分的来看，覆盖属性覆盖了父类原型上的同名属性，也是一种（子类自有）的自有属性，最后还有一类自有属性被称之为内部属性它是每个对象实例内部的、自有的属性，部分内部属性是可以被继承的，或者可以被某些公开方法影响的，因此子类实例也可以覆盖它们</p><h4 id="3-5-2-1-给属性赋值"><a href="#3-5-2-1-给属性赋值" class="headerlink" title="3.5.2.1 给属性赋值"></a>3.5.2.1 给属性赋值</h4><p>包括四种情况</p><p>情况一：属性不存在，隐式创建一个数据描述符</p><p>情况二：属性是当前对象自有的，只要是可写的就正常赋值，否则什么都不做或者在严格模式下报错</p><p>情况三：属性是继承的，而且是数据描述符，就在自有属性表创建数据描述符，然后按默认初始化，赋值</p><p>情况四：属性是使用的存取描述符，无论读写的性质是什么都不会新建属性描述符，子类继承了这样的一个属性也会忠实的调用（继承来的、原型中的）读写器</p><h4 id="3-5-2-2-使用属性描述符"><a href="#3-5-2-2-使用属性描述符" class="headerlink" title="3.5.2.2 使用属性描述符"></a>3.5.2.2 使用属性描述符</h4><p>在JS中不能直接修改属性描述符的性质以影响源对象，因为属性描述符只是复制了对象属性的内部性质，而不是这些性质的直接引用</p><p>创建属性的方法</p><p><code>Object.defineProperty(obj, name, descriptor)</code>为对象声明一个属性</p><pre><code class="js">Object.defineProperty(obj1, &#39;a_name&#39;, {  get: function() {},  configurable: false})</code></pre><p><code>Object.defineProperties(obj, descriptors)</code>为对象声明一组属性</p><pre><code class="js">Object.defineProperties(obj1, {  &#39;a_name&#39;: {    get: function() {},    configurable: false  },  &#39;b_name&#39;: {    get: function() {},    configurable: false  }})</code></pre><p><code>Object.create(prototype, descriptors)</code>创建对象并并为对象声明一组属性</p><p>如果在子类中尝试定义父类的同名属性，该属性将变成子类对象中的”自有属性“，但不同的是，“重新定义属性”这个操作于原型中该属性是否可写或者是否允许修改性质是无关的，事实上，无法阻止子类对父类同名属性的重定义，也没有办法避免重定义带来的逻辑问题，关于这一点，可以简单的总结为：<strong>属性的性质不可继承</strong></p><h4 id="3-5-2-3-取属性或属性列表"><a href="#3-5-2-3-取属性或属性列表" class="headerlink" title="3.5.2.3 取属性或属性列表"></a>3.5.2.3 取属性或属性列表</h4><p>JS定义了一组非常丰富的方法来操作这些属性</p><table><thead><tr><th align="center">分类</th><th align="center">Objcet.xxx方法或者语法元素</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">取属性描述符</td><td align="center">getOwnPropertyDescruotors(obj)</td><td align="center">取所有描述符，含名字、值和性质</td></tr><tr><td align="center">取属性描述符</td><td align="center">getOwnPropertyDescriptor(obj, name)</td><td align="center">取指定属性名的描述符</td></tr><tr><td align="center">取属性名</td><td align="center">getOwnPropertyNames(obj)</td><td align="center">取对象自有的、字符串的属性名数组</td></tr><tr><td align="center">取属性名</td><td align="center">getOwnPropertySymbols(obj)</td><td align="center">取对象自有的、符号的属性名数组</td></tr><tr><td align="center">取属性名</td><td align="center">keys(obj)</td><td align="center">取对象自有的、可见的属性名数组</td></tr><tr><td align="center">取属性名</td><td align="center">for…in</td><td align="center">列举可见的属性名</td></tr><tr><td align="center">取属性值</td><td align="center">for…of</td><td align="center">列举成员中的数组元素</td></tr><tr><td align="center">取属性值</td><td align="center">values(obj)</td><td align="center">取对象自有的、可见的属性值数组</td></tr><tr><td align="center">取属性值</td><td align="center">entries(obj)</td><td align="center">取对象自有的、可见的名值对数组</td></tr><tr><td align="center">取属性值</td><td align="center">.和[]运算符，以及解构赋值等</td><td align="center">（按属性名取值）</td></tr></tbody></table><h3 id="3-5-3-属性表的状态"><a href="#3-5-3-属性表的状态" class="headerlink" title="3.5.3 属性表的状态"></a>3.5.3 属性表的状态</h3><p>对象有一个内部属性<code>[[Extensible]]</code>用来影响其自有属性表的相关行为，该属性的默认值是<code>true</code>，表明一个对象是可以被添加或者删除的，于此相关，还有两组与操作自有属性表的方法</p><table><thead><tr><th align="center">分类</th><th align="center">Objcet.xxx方法</th><th align="center">说明</th><th align="center">对自有属性表的操作</th></tr></thead><tbody><tr><td align="center">状态维护</td><td align="center">preventExtensions(obj)</td><td align="center">使实例obj不能添加新属性，也不可重置原型</td><td align="center">禁止表add</td></tr><tr><td align="center">状态维护</td><td align="center">seal(obj)</td><td align="center">使实例obj不能添加新属性，也不能删除既有属性</td><td align="center">禁止表add/delete</td></tr><tr><td align="center">状态维护</td><td align="center">freeze(obj)</td><td align="center">使实例obj所有属性只读，且不能添加新属性，也不能删除既有属性</td><td align="center">禁止表add/delete/update （冻结表）</td></tr><tr><td align="center">状态检查</td><td align="center">isExtensible(obj)</td><td align="center">返回[[Extensible]]值</td><td align="center">是可增加属性项的</td></tr><tr><td align="center">状态检查</td><td align="center">isSealed(obj)</td><td align="center">返回seal状态</td><td align="center">密封的（禁止删除的）</td></tr><tr><td align="center">状态检查</td><td align="center">isFrozen(obj)</td><td align="center">返回freeze状态</td><td align="center">冻结的</td></tr></tbody></table><p>seal和freeze的状态不是直接的状态值，而是基于[[Extensible]]和现有的自有属性（的性质）计算出来的、动态的值：</p><ul><li>seal是[[Extensible]]为false，所有自有属性的configurable性质为false</li><li>seal是[[Extensible]]为false，所有自有属性的configurable和writable性质为false</li></ul><p>对于一个自有属性表为空的对象使用<code>preventExtensions</code>将同时导致它密封和冻结</p><p>存取属性并不受freeze状态的“置属性只读”的影响</p><p>当父类（原型）冻结或者指定属性只读，赋值运算会失效，但能用重新声明属性的方法达到与赋值运算相同的效果</p><blockquote><p>属性表的性质不可继承</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记6</title>
    <link href="undefined2020/07/green6/"/>
    <url>2020/07/green6/</url>
    
    <content type="html"><![CDATA[<h4 id="3-2-1-2-构造复制？写时复制？还是读遍历？"><a href="#3-2-1-2-构造复制？写时复制？还是读遍历？" class="headerlink" title="3.2.1.2 构造复制？写时复制？还是读遍历？"></a>3.2.1.2 构造复制？写时复制？还是读遍历？</h4><p>假设每构造一个实例，都从原型中复制出一个实例来，新的实例占用了和原型相同的内存空间，这确实可以使<code>obj1 obj2</code>等与它们的原型“完全一致”，但是也非常的不经济——因为内存的占用会急剧增加</p><p>另一个策略来自一种欺骗系统的技术：写时复制。这种欺骗的典型示例就是操作系统中的动态链接库(DDL)，它的内存中总是写时复制的，这种机制先指明<code>obj1</code>和<code>obj2</code>与原型的引用关系，系统将这种关系理解为“两个对象都等同于它们的原型”，读的时候直接去读原型，接下来，写对象的属性的时候，我们就复制出原型的映像出来，并使以后的操作指向该映像就行了，优点是：之后第一次写的时候会用一些代码来分配内存，之后就不会有这些开销了，因为访问映像和访问原型的效率是一样的，但是对于经常读写的系统中，这种方法并不比上一种更经济</p><p>JS采用第三种方法：把写复制的粒度从整个原型变成了成员。这种方法是：仅当写某个实例的成员时，才将成员的信息复制到实例映像中。这样一来，在读取该对象的时候，仍然和上一种一样，但是在写的时候，实例会产生一个写的属性值，放在实例的成员列表中，所以现在对象仍然是一个指向原型的引用，操作过程中也没有与原型大小相同的实例被创建出来。这样写操作就很经济了，不过所有的对象实例都需要维护一张成员列表。这张成员表指向实例中发生了修改的成员名、值与类型。称为对象的<strong>自有属性表</strong>(own proprties)。这张表是否与原型一致并不重要，只需要遵循以下两条规则：</p><ul><li>规则1：保证优先读取对象的自有属性表</li><li>规则2：如果在上述自有属性表中没有指定属性，则尝试遍历整个对象的原型链，知道原型为空(null)或者找到该属性</li></ul><p>JS提供了两个方法<code>Object.getOwnPropertyDescriptor()</code>和<code>Object.getOwnPropertyNames()</code>来访问该表。而且在为某个属性置值时本质上就是在这个自有属性表中创建一项，以覆盖原型中同名的属性</p><p>那么可以推论：所谓”空白对象“，是指在它的原型链上所有的自有属性表都为空的对象。而所谓”原型链“，就是对象所有父类和祖先类的原型所形成的，可以上溯访问的链表。</p><h4 id="3-2-1-3-构造过程：从函数到构造器"><a href="#3-2-1-3-构造过程：从函数到构造器" class="headerlink" title="3.2.1.3 构造过程：从函数到构造器"></a>3.2.1.3 构造过程：从函数到构造器</h4><p>上边的规则只是讲述了”怎么得到对象“，而这并不是构造的全过程，例如。我们没有解释”函数作为一个构造器，都做了什么？”</p><p>其实函数首先只是函数，即使存在<code>prototype</code>成员，但是从事指向一个标准的Object构造器的实例——空白对象，不过实例的<code>constructor</code>属性总是指向当前函数，可以理解为如下代码</p><pre><code class="js">function asConstrucor(f) {  return Object.assign(f, {    prototype: {&#39;constructor&#39;: f}  });}aClass = asConstructor(new Function);</code></pre><p>正常函数的<code>prototype</code>其实与一个用<code>new Object</code>创建的空白对象没有本质区别，但是但函数有了<code>prototype</code>这个属性之后，就变成了一个“构造器”。于是当用户使用<code>new</code>运算创建一个实例的时候，引擎就再构造一个对象，，并使该对象的原型链指向这个<code>prototype</code>就可以了</p><h4 id="3-2-1-4-内置属性和方法"><a href="#3-2-1-4-内置属性和方法" class="headerlink" title="3.2.1.4 内置属性和方法"></a>3.2.1.4 内置属性和方法</h4><p>JS对象实例本身并没有什么特别的性质，对象的行为来源于引擎对原型以及属性表的理解，例如所谓“空白对象”只不过时下边这个结构</p><ul><li>“原型”指向<code>Object.prototype</code></li><li>“属性表”指向一个空表</li></ul><pre><code class="js">var empty = {}var proto = Object.getPrototyprOf(empty)var props = Object.getOwnPropertyNames(empty)// 显示true，原型指向Object.prototypeconsole.log(proto === Object.prototype);// 显示0 属性表为空console.log(props.length)</code></pre><p>而这样的空白对象看起来更干净，是因为原型链上没有显示成员：</p><pre><code class="js">// 续上例// 显示非零值，表明原型链Object.prototype的属性表不是空的var propsInChain = Object.getOwnPropertyDescriptors(Object.prototype)console.log(Object.keys(propInChain).length)// 显示0，表明没有显式成员var enumerabledMembers = Object.values(propsInChain).filter(descripter =&gt; decsripter.enumerable);console.log(enumerabledMembers)</code></pre><p>进一步的推论是：所有“实例”之所以具有对象的某些属性（以及相关的对象特征），是因为它们的共同原型<code>Object.prototype</code>具有这些属性</p><pre><code class="js">// Object.prototype的成员Object.getOwnPropertyNames(Object.prototype)// 构造器（函数）所具有的特殊成员Object.getOwnPropertyNames(Function)Object.getOwnPropertyNames(Function.prototype)// Object作为基类的类方法Object.getOwnPropertyNames(Object)</code></pre><h4 id="3-2-1-5-原型为null，“更加空白”的对象"><a href="#3-2-1-5-原型为null，“更加空白”的对象" class="headerlink" title="3.2.1.5 原型为null，“更加空白”的对象"></a>3.2.1.5 原型为null，“更加空白”的对象</h4><p>原型为<code>null</code>是原型继承中的特例，它有两种情况<code>Constructor.prototype</code>的值为<code>null</code>，<code>Object.getPrototypeOf(obj)</code>的值为<code>null</code></p><p>当以函数作为构造器来使用的时候，如果它的<code>prototype</code>是非对象值或者<code>null</code>的时候，创建出来的实例其实是从<code>new object</code>创建出来的，也就是说<code>Object.getPrototypeOf(obj).constructor === Object</code></p><p>不过有趣的是，尽管新实例不是由原型为非对象值的函数创建的，但是<code>new</code>运算仍然会把它作为this调用一次该函数</p><pre><code class="js">Object.setPrototypeOf(obj, null);// 它仍然是对象，但是没有继承来的任何属性(原型是null)，也不再是Object的实例console.log(typeof obj) // &#39;object&#39;console.log(&#39;toString&#39; in obj) // falseconsole.log(obj instanceof Object) // falseobj.showMe() // 能访问自有属性以及方法</code></pre><p>简单的来说，这样的对象是一个只有一级（没有原型链）的属性包——只有一个自有属性表。比起空白对象，它更加空白，连Object的内置属性都没有，不过它仍然具有对象的一切性质，包括作为其他对象的原型，或者使用<code>Object.defineProperty()</code>等方法来操作它。</p><p>与直接向<code>Constroctor.prototype</code>属性设置不同，<code>Object.setprototypeOf()</code>不接受任何对象或者null值以外的值</p><h3 id="3-2-2-原型链的维护"><a href="#3-2-2-原型链的维护" class="headerlink" title="3.2.2 原型链的维护"></a>3.2.2 原型链的维护</h3><p>原型链：对象所有父类和祖先类原型所形成的、可上溯访问的链表</p><p>这个链表在多数情况下对于“对象实例”来说不可见</p><h4 id="3-2-2-1-外部原型链与constructor属性"><a href="#3-2-2-1-外部原型链与constructor属性" class="headerlink" title="3.2.2.1 外部原型链与constructor属性"></a>3.2.2.1 外部原型链与<code>constructor</code>属性</h4><p>基于传统原型继承风格实现的对象系统是这样的</p><pre><code class="js">function MyObject() {}function MyobjectEx() {}// 构建外部原型链MyObjectEx.prototype = new MyObject();// 但是这样会导致创建的子类的实例的constructor指向了MyObjcet，所以需要显式的覆盖一下MyobjectEx.prototype.constructor = MyObjctEx</code></pre><blockquote><p>由于覆盖了原型的constructor属性，原型与父类之间的关系，即原型链就被切断了，因此在早期的JS中，外部原型链和有效的constructor属性只能二选一</p></blockquote><p>有一些框架提出了编写构造器函数的模式，可以兼二者之利</p><pre><code class="js">function MyObject() {}function MyObjectEx() {  this.constructor = MyObjectEx;  // ...}MyObjectEx.prototype = new MyObject()</code></pre><p>这样一来<code>MyObjectEx</code>创建的实例的constructor都正确的指向<code>MyObjectEx</code>，而原型的constructor则指向<code>MyObject</code>，但是因为每次实例化都需要重写constructor所以效率很低</p><h4 id="3-2-2-2-使用内部原型链"><a href="#3-2-2-2-使用内部原型链" class="headerlink" title="3.2.2.2 使用内部原型链"></a>3.2.2.2 使用内部原型链</h4><p>维护一个原型链的必要性：面向对象的继承性约定：子类与父类具有相似性。为了保持这种一致性并且不被修改，（这也就是说子类必须具有父类的特性，这也是JS不能用delete删除从父类继承的成员的原因，尽管看起来像是“自有属性表”带来的特性，但是它确保了在重写成员、改变它的实现等的同时，在界面（Interface）上保持和父类的必然一致），ECMAScript约定对象实例内部必须持有该对象的原型。并且，ECMAScript还进一步规范了存取这个内部原型的标准方法<code>Object.getPrototypeOf()</code>和<code>object.setPrototypeOf()</code></p><h3 id="3-2-3-原型继承的实质"><a href="#3-2-3-原型继承的实质" class="headerlink" title="3.2.3 原型继承的实质"></a>3.2.3 原型继承的实质</h3><p>修改原型是JS中最常用的构建对象系统的方法，它的好处是可以在实例构造之后“动态地”影响到这些实例。也就是说，对象实例的特性不但可以在new运算中通过构造来得到，也可以在此后通过修改原型来持续获得</p><p>JS原型继承的实质便是对原型修改“效果的传递”。它基于以下两个事实</p><ul><li>原型：原型是一个对象</li><li>原型链：如果子类对象没有该属性，则将访问其原型的属性表</li></ul><h4 id="3-2-3-1-简单模型"><a href="#3-2-3-1-简单模型" class="headerlink" title="3.2.3.1 简单模型"></a>3.2.3.1 简单模型</h4><p>可以修改继承树上的任意分支(类)，以使得它们的原型具有某些属性和方法。</p><h4 id="3-2-3-2-如何理解继承来的成员"><a href="#3-2-3-2-如何理解继承来的成员" class="headerlink" title="3.2.3.2 如何理解继承来的成员"></a>3.2.3.2 如何理解继承来的成员</h4><p>在ES6种，重写操作被约定为针对自有属性表进行，因此写的结果决定于写该属性时的性质设置，而不再继承自父类，这样一来，我们就可以看到，一个在父类中不能被删除，列举且只读的成员在被重写之后，就变成了可删除，可列举和可读写的，也唯有如此，该成员的重写效果才能被清除——在删除重写的成员后，将重新沿用父类的值与性质。</p><h2 id="3-3-JavaScript的类继承"><a href="#3-3-JavaScript的类继承" class="headerlink" title="3.3 JavaScript的类继承"></a>3.3 JavaScript的类继承</h2><p>早期的JS中没有类，只是使用“构造器”来实现类的某些功能，直到ES6才正式支持类，但是仍然是基于原型的——这是一种很罕见的实现模型</p><h3 id="3-3-1-类是静态的声明"><a href="#3-3-1-类是静态的声明" class="headerlink" title="3.3.1 类是静态的声明"></a>3.3.1 类是静态的声明</h3><p>原型继承依赖程序的执行过程，是通过原型修改来实现继承特性的一种方法。在这种方法中，因为子类依赖父类的构造过程，所以子类必须晚于父类构造</p><p>由于JS的函数声明是早于代码的执行，所以在源代码中这样也是可行的：</p><pre><code class="js">// 原型继承关系(语句执行是有顺序关系的)MyObject.prototype = new Object()MyObjectEx.prototype = new MyObject()// 构造器函数(声明之间是没有顺序关系的)function MyObjectEX() {  // ...}</code></pre><p>JS的类继承，是通过类表明上述前两行的继承关系的语法，更准确的说类声明通过”声明语法“来将上述示例代码中的</p><ul><li>构造器（函数）声明</li><li>继承关系声明</li></ul><p>全部提前到了语法解析阶段，自此，JS的类不论是在构造方法上还是在继承关系上都没了执行顺序的限制了。</p><p>例如，一个模块中的类声明继承了另一个模块中的类，最后被同一个文件引用，是没有问题的，甚至引用顺序都无所谓，整个类继承树是由extends来决定的，各个模块之间的装载顺序并不影响继承关系的构建过程</p><p>类是静态的声明，意味着类继承关系的构建过程也是静态的，是在语法分析期就决定了的，于此相关的，这也意味着类声明语法中的方法或者属性存取器只是（对象方法的）声明，而不是函数，因此也就不能在声明内直接引用它们的名字</p><pre><code class="js">// 使用构造器语法function MyObject() {  console.log(typeof MyObject)}// 当使用类声明时class MyObjectEx {  constructor() {    // 是声明语法而并不是函数，所以constructor并不能视为函数名    console.log(typeof constructor); // undefined  }  foo() {    // 同上    console.log(typeof foo); // undefined  }}</code></pre><h3 id="3-3-2-super是全新的语法元素"><a href="#3-3-2-super是全新的语法元素" class="headerlink" title="3.3.2 super是全新的语法元素"></a>3.3.2 super是全新的语法元素</h3><p><code>super</code>是什么？它并不是一个变量或指向数据的标识符，例如，你在任何时候都不可能用<code>typeof super</code>来获取到它的类型，尽管我们知道它指向父类构造器。这是它与<code>this</code>这个关键字极大的不同之处</p><p><code>super</code>与<code>new</code>是类似的语法元素，有两种语法</p><pre><code class="js">// 语法1super(arguments)// 语法2super.propertyNamesuper[expression]</code></pre><p>可以使用在类声明或者字面量风格的对象声明中，仅在类声明中，它的第一种语法表明调用父类的构造方法</p><p>super在ECMA规范中并不被称为运算符，而只是被称为关键字，虽然它被放在表达式中讲述，但却在JS的语法分析阶段就是具有特殊意义的，另外虽然new被称为运算符，但是new.target的出现打破了这一认知</p><h4 id="3-3-2-1-super的使用"><a href="#3-3-2-1-super的使用" class="headerlink" title="3.3.2.1 super的使用"></a>3.3.2.1 super的使用</h4><p>super的出现是为了填补原型继承的一项众所周知的不足：无法有效调用父类方法。我们曾提到过维护原型链的必要性，其中，对象实例是通过访问<code>obj.constructor.prototype</code>来访问到其原型的方法的。正是出于这个目的。维护<code>obj.constructor</code>的有效性才成为原型继承的一种”与生俱来“的负担</p><pre><code class="js">MyObjectEx.prototype.aMathod = function () {  var thisClass = this.contructor;  var parentClass = thisClass.prototype.constructor;  parentClass.prototype[&quot;aMathod&quot;](); // 调用父类方法}</code></pre><h4 id="3-2-2-2-super指向什么"><a href="#3-2-2-2-super指向什么" class="headerlink" title="3.2.2.2 super指向什么"></a>3.2.2.2 super指向什么</h4><p>我们先来看一段代码</p><pre><code class="js">class MyObject {  static showMe() {    console.log(super.toString())  }}MyObject.showMe()// class MyObject {}</code></pre><p>super看上去指向了MyObject而不是它的父类Object，这是因为<code>super.xxx</code>在作为方法调用时，会隐式的传入当前方法中的<code>this</code>对象</p><p>在类的构造方法声明中，语义一：super指向父类构造器，this指向new创建的实例<code>super = MyObject.bind(this)</code>，语义二：在语法super.xxx中，super指向父类原型，在构造过程中this指向新创建的实例<code>super.toString = MyObject.prototype.toString.bind(this)</code> </p><p>在正常的方法中同语义二</p><p>语义三：在静态类方法中使用语法super.xxx，其super指向父类，this指向调用当前方法的类(构造器函数，本例中是MyObjectEx)<code>super.do() =&gt; MyObject.do.bind(this)</code></p><p>在静态成员的存取方法中同语义三</p><pre><code class="js">// 字面量风格的对象声明obj = {  foo() {    // 语义4；在方法声明中使用super.xxx时，super指向对象obj的原型，this指向调用本方法时的this对象    // 相当于super.toString = Object.getPrototypeOf(obj).toString.bind(this)    super.toString()  },  bar: function() {    // 不能引用super  }}</code></pre><h4 id="3-3-2-3-super对一般属性的意义"><a href="#3-3-2-3-super对一般属性的意义" class="headerlink" title="3.3.2.3 super对一般属性的意义"></a>3.3.2.3 super对一般属性的意义</h4><p>JS事实上允许用户代码通过<code>super.xxx</code>这一语法来引用父类中的与<code>xxx</code>同名的属性，而不仅仅是方法</p><pre><code class="js">class MyObject{}MyObject.prototype.x = 100class MyObjectEx extends MyObject {  foo() {    console.log(super.x)  }}obj = new MyObjectEx;// 实例1// - obj.foo() 通过super访问到的x值obj.foo() // 100// - obj 通过原型访问到的x值console.log(obj.x); // 100// 示例2// 修改对象实例x的值obj.x = 200;console.log(obj.x) // 200// 通过原型访问到的值是不变的obj.foo() // 100// 实例3// 修改原型的值MyObject.prototype.x = 300;// 通过super访问到的值受到影响obj.foo() // 300// 对象的自有属性(这里是覆盖了继承属性)不受影响console.log(obj.x) // 200</code></pre><p>所谓的同名属性仍然取决于super使用的位置，例如在类静态方法中，它就指向类的原型，在字面量风格的对象中，就指向对象的原型，（而不是类.prototype）</p><p>刚刚的这句话展现了<code>super</code>引用的一个重要事实，对于任何对象实例(obj)——包括它是函数或者构造器，在其方法内引用super.xxx时</p><ul><li>super总是绑定在<code>Object.getPrototypeOf(obj)</code>上</li><li>无论将来该<code>foo()</code>函数被用来做为哪个实际对象的方法例如</li></ul><pre><code class="js">var proto = {data: 1}var obj = {  foo() {    console.log(super.data)  }}Object.setPrototypeof(obj, proto)// obj2没有原型，那么能访问super么obj2 = Object.create(null)obj2.foo = obj.foo// 由于obj.foo声明总是将super绑定到原型，所以能调用到&quot;原型.foo”obj2.foo() // 1</code></pre><h4 id="3-3-2-4-super在两种继承关系中的矛盾"><a href="#3-3-2-4-super在两种继承关系中的矛盾" class="headerlink" title="3.3.2.4 super在两种继承关系中的矛盾"></a>3.3.2.4 super在两种继承关系中的矛盾</h4><p>super在语义设计上同时支持了类与原型继承——类方法和对象方法中各自的原型链——所导致的矛盾。这一矛盾表现为：对象方法中缺乏一个必要的语法词汇来表示“当前对象与它在类继承链上的parent”这样的关系</p><p>注：翻译成人话就是super会越过父类直接到父类的原型上，这个时候访问父类的像静态成员就比较麻烦，所以还给了一个封装好的函数来获取父类</p><pre><code class="js">// 对于对象me来说，得到构建他的类（父类）function PARENT(me) {  return Object.getPrototypeOf(me).constructor;}</code></pre><h4 id="3-3-2-5-super的动态计算过程"><a href="#3-3-2-5-super的动态计算过程" class="headerlink" title="3.3.2.5 super的动态计算过程"></a>3.3.2.5 super的动态计算过程</h4><p>JS中每一个对象都有一个<code>[[HomeObject]]</code>的内部槽（Internal slots），用来在方法执行的时候找到对应的<code>super</code>，它用于保存一个在语法分析阶段确定的、声明方法时所基于的对象（对于对象方法来说就是AClass.porotype，对类静态方法是AClass）至于“找到super”则是一个使用该内部槽进行动态计算的过程</p><p>这个计算依赖一些前提假设</p><ul><li>在语法分析阶段会保证<code>super</code>只出现在方法声明中</li><li>除箭头函数之外，其他函数（包括方法声明）都不会使用“词法this绑定”</li><li>并且因此，在执行环境栈中（自顶向下）找到的第一个“支持this绑定的环境”就必然对应于”当前正在执行的方法“，（执行环境栈顶部可能还有一些其他没绑定this的环境，例如语法块和with</li></ul><p>基于此，在方法执行时，引擎就可以从环境栈中得到它的执行环境，并且：</p><ul><li>得到“绑定的this”以及“对应的方法（函数）”</li><li>读取该方法的内部槽<code>[[HomeObject]]</code>得到它所基于的对象（例如base）；接下来</li><li>通过<code>Object.getPrototypeOf(base)</code>获取到super</li></ul><p>如此一来就得到了super和this</p><p>由于构造方法中this引用是要先调用<code>super()</code>才能创建的，所以构造方法虽然也是支持this绑定的环境，并且也能得到“当前正在执行的构造方法”，但是不能在调用super之前获取到有效的this值</p><p>进一步推想就可以知道：即使如上得到了“当前正在执行的构造方法”，但是构造方法语法上是对象方法——而非类静态方法，因此它的<code>[[HomeObject]]</code>记录的是<code>Class.prototype</code>无法用于找到父类(class的super)</p><p>因此在处理“调用父类构造器”语法时，是直接将“当前构造方法”用作base，并进一步调用<code>Object.getPrototypeOf(base)</code>来获取真正的super的，换言之，它等同于从类方法中取得的<code>[[HomeObject]]</code>槽。</p><p>由于super是动态计算的并于绑定给它的内部槽相关的，所以也可以通过重置<code>prototype</code>的方式来影响<code>super</code>例如在某些情况下，甚至不需要以属性存取的方式来调用方法</p><pre><code class="js">class MyObject extends Object {  static getTag() {    console.log(super.tag)  }}Object.tag = &quot;object&quot;MyObject.getTag() // &quot;object&quot;// 重置MyObject的prototype改变super的存取NewParent = new FunctionNewParent.tag = &#39;function&#39;Object.setPrototypeOf(MyObject, NewParent)MyObject.getTag() // &#39;function&#39;// 直接作为函数调用，super是绑定的foo = MyObject.getTagfoo() // &#39;function&#39;</code></pre><h3 id="3-3-3-类是用构造器（函数）来实现的"><a href="#3-3-3-类是用构造器（函数）来实现的" class="headerlink" title="3.3.3 类是用构造器（函数）来实现的"></a>3.3.3 类是用构造器（函数）来实现的</h3><p>除了在语法上帮助用户维护继承关系，以及提供<code>super</code>关键字便于用户访问父类之外，从本质上说，JS的类，是用构造器（函数）实现的，和一个一般的函数并无不同</p><pre><code class="js">class MyObject {}console.log(typeof MyObject) // &#39;function&#39;</code></pre><p>当类声明中没有构造方法的时候，会自动给你创建一个构造方法，如果这个类还有继承关系，则会在构造方法中调用<code>super()</code></p><p>所以只要是类，就总是或者隐式的存在一个对应的构造方法。因此在JS中，类作为标识符实际上就是“一个引用了该构造方法的函数”</p><pre><code class="js">MyClass === MyClass.prototype.constructor // true</code></pre><p>但是类继承和原型继承有很大的不同</p><p>在传统的原型继承中，子类的原型总是父类的一个实例，因此在子类声明中必须能够先调用父类的构造器（以创建原型），例如</p><pre><code class="js">function MyObjectEx() {}MyObjcetEx.prototype = new MyObject();</code></pre><p>而JS在类继承中并不通过如上的动态过程来构造原型链，而是简单的执行重置了原型的原型，如下</p><pre><code class="js">class MyObjctEx extends MyObject {}// 声明一个构造器function MyObjctEx() {}// 置原型的原型Object.setPrototypeOf(MyObjctEx.prototype, MyObjct.prototype)// 注：MyObjctEx.prototype.constructor 是自有属性，不需要再重写// 置类的原型Object.setPrototypeOf(MyObjctEx, MyObjct)</code></pre><blockquote><p>这里我没太搞懂啊，先置原型的原型理解了，但是又置类的原型不会把之前置原型的原型给覆盖掉么，但是用代码测试一下，并没有区别，，这里搞得很懵</p></blockquote><blockquote><p>研究了将近一个点，我的理解是，应该先置类的原型，再置原型的原型，这样才能正常继承，头大</p></blockquote><p>置类的原型之后super才可以为类静态声明找到它们的父类</p><p>接下来，我们进一步考察<code>new</code>运算符在传统的原型继承成的使用，例如：</p><pre><code class="js">// 如果要用原型继承方式调用父类方法，则需要维护原型链，并持有父类的构造器(例如base)function MyObjctEx() {  base.call(this)  this.aMathod = function () {    base.prototype.aMathod.call(this);    // ...  }  // ...} var obj = new MyObjctEx();</code></pre><p>在该实例中，则需要注意，在调用<code>base.call()</code>时的this实例就是存在的，这个this实例：</p><ul><li>实际上时使用MyObjctEx()构造器创建的，并且将以该实例作为this引用，</li><li>从MyObjctEx()开始并上溯至基类，将每个构造器当作函数来使用</li></ul><p>于此不同，对类来说，new运算符将使用它的基类来构造实例，更准确的说，new运算符将回溯它的继承链并使用顶端的原生构造器开构造实例，这个过程类似于</p><pre><code class="js">// 本例是如下代码的模拟效果new MyObjectEx();// 模拟类继承中this对象的创建和使用var thisObj = new Object;MyObjct.call(thisObj);MyObjctEx.call(thisObj);</code></pre><p>因此类中的this实例：</p><ul><li>实际上是使用Objct()构造器创建的，并且(使用它作为this引用)</li><li>调用构造器，该调用是顺序的，从基类开始一直到MyObjctEx()</li></ul><p>这样一来这个顺序与上例中的原型继承正好相反，由此带来了一项著名的限制：</p><ul><li>在类的构造方法中，不能在调用super之前使用this</li></ul><p>显然，必须让所有的构造方法都得先调用super以回溯整个原型链。才能确保基类最先创建实例。这也是没有在类中声明<code>constructor</code>方法时，JS会默认添加一个构造函数，并在其中调用super的原因，更确切地说，如果子类是派生的，那么他就必须得在构造函数中调用super。而非派生类，就不能调用super</p><p>在非派生类的构造方法中，this对象是在进入该构造方法之前由引擎创建好了的(因此不用在构造函数中调用super)，并且在构造函数中可以返回一个对象来代替这个默认的this对象，这沿袭了JS一项历史悠远的传统设计，new运算会为构造器创建一个对象作为this引用，并调用该函数，且允许在函数中返回对象来替换默认的this对象</p><p>最后，在任何时候我们都能混用两种继承风格：</p><pre><code class="js">function MyObjectEx() {}MyObjectEx.prototype = new MyObject;MyObjectEx.prototype.constructor = MyObjctExclass MyObjectEx2 extends MyObjcetEx {}</code></pre><h3 id="3-3-4-父类的默认值与null值"><a href="#3-3-4-父类的默认值与null值" class="headerlink" title="3.3.4 父类的默认值与null值"></a>3.3.4 父类的默认值与null值</h3><p>如果没有写父类，那么默认就是<code>Object</code>作为父类，以下两种写法等价</p><pre><code class="js">class MyObject1{}// 不能使用 superclass MyObject2 extends Objcet {}// 必须调用super()</code></pre><p>如果父类是null，那么该类不能实例化，由于不能调用super()，所以也不能使用this，super.xxx()需要绑定this也不能使用，super.xxx事实上不能访问到有效成员，也不能使用</p><p>这种类就变成了纯静态类，只有类方法有意义</p><h2 id="3-4-JavaScript的对象系统"><a href="#3-4-JavaScript的对象系统" class="headerlink" title="3.4 JavaScript的对象系统"></a>3.4 JavaScript的对象系统</h2><p>所谓“对象系统”就是“一组对象构成的系统”。这些对象之间存在或者不存在某种联系，但是总之是通过一些规则组织起来的。若以这样一个对象系统为基础来衍生演化，且其新系统仍能满足这些组织规则的话，整个系统即是所谓的“面向对象的系统”</p><h3 id="3-4-1-封装和多态"><a href="#3-4-1-封装和多态" class="headerlink" title="3.4.1 封装和多态"></a>3.4.1 封装和多态</h3><p>对象系统还包括其他两个方面的要素（即组织规则）：封装和多态。它们通常和继承一起，称为对象系统的三要素</p><h4 id="3-4-1-1-封装"><a href="#3-4-1-1-封装" class="headerlink" title="3.4.1.1 封装"></a>3.4.1.1 封装</h4><p>封装表达为<code>private、protected</code>等关键字限定的成员存取范围或作用域，以及对象在不用继承层次上对成员的叠加</p><p>JS依赖变量作用域来实现封装特性，所以相当于只实现了<code>pubic</code>和<code>protected</code></p><h4 id="4-3-1-2-多态"><a href="#4-3-1-2-多态" class="headerlink" title="4.3.1.2 多态"></a>4.3.1.2 多态</h4><p>多态性表现在两个方面：类型的模糊与类型的确认（或者识别）。在一些高级语言中，它们分别被表达为<code>as</code>和<code>is</code>这两个关键词或运算</p><p>对象的多态性被转换为运行期的动态特性——例如可以动态的添加对象的方法或者成员，使它看起来像是某个对象</p><p>由于所有对象的typeof的值都是object，所以在系统需要确知对象具体类型时，应当使用<code>instanceof</code> 运算来进一步检测对象类型的检查，它等效于其他高级语言的<code>is</code>运算，但是当两个函数当作一般对象参与运算时，instanceof就失效了，需要使用<code>isPrototypeOf</code></p><pre><code class="js">// 直接置f2的原型链var f1 = new Function, f2 = new FunctionObject.setPrototypeOf(f2, f1)// 检测不到f1与f2之间的原型关系console.log(f2 instanceof f1) // false// 使用isPrototypeOf检测console.log(f1.isPrototypeOf(f2)) // true</code></pre><p>同理，类之间也得使用<code>isPrototypeOf</code></p><h4 id="3-4-1-3-多态与方法继承"><a href="#3-4-1-3-多态与方法继承" class="headerlink" title="3.4.1.3 多态与方法继承"></a>3.4.1.3 多态与方法继承</h4><p>多态性中的另一个关键问题是，在类型继承中识别父类的同名方法，使用super关键字即可</p><h3 id="3-4-2-属性"><a href="#3-4-2-属性" class="headerlink" title="3.4.2 属性"></a>3.4.2 属性</h3><p>一些讨论对象系统的书籍会将属性、方法、事件（properties、Methods、Events，PME）作为对象系统完整的外在表现来讨论，在本节中“方法”是特指函数类型的属性，在这种情况下：方法是属性的一个子集，有对象成员的全部特性</p><h4 id="3-4-2-1-方法"><a href="#3-4-2-1-方法" class="headerlink" title="3.4.2.1 方法"></a>3.4.2.1 方法</h4><p>方法就是函数类型的属性，除了null值，所有JS的对象都能操作自己的属性表，在对象的自有属性表维护的方法称为对象方法，而在Constructor.prototype这个对象上维护的方法，是那些用<code>new Constructor()</code>所创建的实例的原型方法，原型方法是所有实例通过原型继承来共享使用的——相同父类的实例调用的原型方法是用一个函数</p><p>对象通过重写对象方法可以来覆盖继承的原型方法，这与重写一般属性没有什么区别，因此也可以使用<code>Objcet.defineproperty()</code>等来创建这些方法。当方法被重写之后，也可以使用<code>Object.getOwnPropertyDescriptor()</code>来获取它的描述符</p><p>当一个函数在调用过程中获取到的this值为undefined或者null，则在严格模式下，仍以此作为this，其他模式就把全局对象作为this值</p><h4 id="3-4-2-2-事件"><a href="#3-4-2-2-事件" class="headerlink" title="3.4.2.2 事件"></a>3.4.2.2 事件</h4><p>大多数高级语言并没有事件系统，在这种情况下，事件是对象系统实现时由应用框架提供的额外机制，而非对象系统的必然要求</p><p>JS的事件也是外来户，JS本身并没有事件，我们经常在浏览器使用的Onload、Onclick等事件，其实是DOM——一个由宿主供应与维护的可编程对象模型提供的</p><p>尽管大多数时候我们在写事件的响应函数，或者面向事件响应来架构系统，但是事件却不是ECMAScript或者JS语言的一个组成部分</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记5</title>
    <link href="undefined2020/07/green5/"/>
    <url>2020/07/green5/</url>
    
    <content type="html"><![CDATA[<h3 id="3-1-3-对象成员"><a href="#3-1-3-对象成员" class="headerlink" title="3.1.3 对象成员"></a>3.1.3 对象成员</h3><p>JS中的对象是属性包，属性即所谓的对象成员，当我们分别讨论对象实例和类时，属性和类成员是两个概念，由于类本身也是函数类型的对象，所以当我们统一用”对象“这个概念来讲述的时候，其成员仍被称为属性</p><p>对象成员有三种性质，称为”可读写“、”可枚举“和”可重置”</p><p>对象成员可以是自有的也可以是继承的，所谓继承的就是指对象的父类或者祖先类原型上具有该成员，子类对象可以用相同的名字重新声明该成员，称为“覆盖”或者“重写”</p><h4 id="3-1-3-1-成员的列举以及可列举性"><a href="#3-1-3-1-成员的列举以及可列举性" class="headerlink" title="3.1.3.1 成员的列举以及可列举性"></a>3.1.3.1 成员的列举以及可列举性</h4><p>对象成员是否可列举被称为成员的可列举性，当某个成员不存在或者不可列举时，对该对象成员调用<code>propertyIsEnumerable()</code>方法将返回<code>false</code>，比较常见的情况是，JS对象的某些特定成员是被设置为隐藏的，因此不能枚举，例如：</p><pre><code class="js">var obj = new Object()// 不存在a所以返回falseconsole.log(obj.propertyIsEnumerable(a)) // false// 数组的length也是隐藏的console.log([].propertyIsEnumerable(length)) // false</code></pre><p>这种情况下，可以用<code>in</code>运算来检测到该成员，但是不能用<code>for ... in</code>来列举该成员</p><p>一直以来，对<code>propertyIsEnumerable()</code>的设计存在歧义，因为它默认不检查对象的原型链的，但是更合理的方法是让它页检测原型链，因为继承来的成员实际上是可以被<code>for ... in</code>枚举出来的</p><p>ES5开始，提供了一些其他的操作对象成员的方法</p><table><thead><tr><th align="center">成员</th><th align="center">语法</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">仅显式成员</td><td align="center">for … in</td><td align="center">可枚举的成员名（含原型链）</td></tr><tr><td align="center">仅显式成员</td><td align="center">Object.keys()<br>Object.values()<br>Object.entries()</td><td align="center">可枚举的、非符号的自有属性名</td></tr><tr><td align="center">包含隐式成员</td><td align="center">Object.getOwnPropertyNames()</td><td align="center">全部的、非符号的自有属性名</td></tr><tr><td align="center">包含隐式成员</td><td align="center">Object.getOwnPropertySymbols()</td><td align="center">全部的、符号键名的自有属性名</td></tr></tbody></table><p><code>Object.values()、Object.entries()</code>可以通过<code>Object.keys().map(key =&gt; obj[key])、Object.keys().map(key =&gt; [key, obj[key]] )</code>实现</p><p>对象可以使用<code>for ... in</code>，通常如果对象的成员插入不是有序的，它的列举也就不是有序的，多数情况下着并不要紧</p><p>不要对数组使用<code>for... in</code>遍历使用最基础的循环或者<code>forEach</code>，<code>for...in</code>并不能够保证返回的是按一定顺序的索引，但是它会返回所有可枚举属性，包括继承属性。</p><p>或许可以使用<code>for...of</code>遍历，但是不能得到下标，而且该语句将数组视为“集合对象”(Collection objects)并列举其中的“集合成员”，而不是列举“对象成员”。从根本上来说，这些集合公布了它们提供的默认内置的迭代器，而<code>for...of</code>指示调用这些迭代器而已</p><h4 id="3-1-3-2-对象及其成员的检查"><a href="#3-1-3-2-对象及其成员的检查" class="headerlink" title="3.1.3.2 对象及其成员的检查"></a>3.1.3.2 对象及其成员的检查</h4><p>JS中使用<code>in</code>来检查对象是否具有某个成员(包括显式或者隐式的，也包括符号作为键名的属性)</p><p>这种也用来做环境兼容性</p><pre><code class="js">if(&#39;XMLHttpRequest&#39; in window) {  // ...}</code></pre><p>但是这并不可靠，因为更早版本的浏览器可能没有<code>in</code>运算</p><p>所以建议</p><pre><code class="js">if(window.XMLHttpRequest) {  // ...}</code></pre><p>在JS中，取一个“不存在的属性”并不会导致异常，而是返回<code>undefined</code>，而<code>undefined</code>刚好能被<code>if</code>语句理解为<code>false</code>，效果相当于用<code>in</code>运算</p><p>旧版本的浏览器也推荐如下的方法做检测</p><pre><code class="js">if(typeof window.XMLHttpRequest !== &#39;undefined&#39;) {  // ...}</code></pre><p>但是一个属性如果被赋值<code>undefined</code>那也是不好用的，，，在WEB浏览器中，DOM约定，如果一个属性没有初值那么应该将它置null</p><p>此外，可以使用<code>instanceof</code>运算符来检测“对象是不是类的一个实例”</p><pre><code class="js">console.log(obj instanceof Object)</code></pre><p>类可以是一般构造器函数或者类声明，它还会检测类的继承关系，因此一个子类的实例，在进行<code>instanceof</code>运算时，仍会得到<code>true</code></p><h4 id="3-1-3-3-值的存取"><a href="#3-1-3-3-值的存取" class="headerlink" title="3.1.3.3 值的存取"></a>3.1.3.3 值的存取</h4><p>多数情况下我们会用对象成员的名字来存取值，使用成员存取运算符<code>.</code>或者<code>[]</code>，所不同的是前者右边的操作数必须是一个标识符，后者方括号中的操作数可以是变量、标识符、符号、字面量或者表达式</p><p>赋值模板也可以用于将对象的属性值督导变量中，并且它通常用作属性的成批读取，或者按照模式(模板)的规则读取</p><pre><code class="js">var obj = {  &#39;abcd.ef&#39;: 1234,  &#39;1&#39;: 4567,  &#39;.&#39;: 7890,  more: {    a: 100,    b: 200,  }} var {&#39;abcd.ef&#39;: x, &#39;.&#39;: y, more: {a: z}}</code></pre><p>这种声明赋值模板的方法也可以用在函数参数上，这样可以避免在函数内频繁的读取对象成员</p><p>无论声明成员还是读取它的值，都可以在<code>[]</code>运算符中使用可计算的成员名，即使用表达式来作为成员名</p><h4 id="3-1-3-4-成员的删除"><a href="#3-1-3-4-成员的删除" class="headerlink" title="3.1.3.4 成员的删除"></a>3.1.3.4 成员的删除</h4><p>可以使用<code>delete</code>运算符来删除一个对象的指定属性，甚至可以删除全局对象<code>Global</code>的某些成员例如<code>delete isNaN;</code></p><p>不过该运算符不能用于删除</p><ul><li>用var/let/const 声明的变量和常量</li><li>直接继承自原型的成员</li></ul><p>关于delete不能删除“直接继承自原型的成员”有一点例外：如果修改了这个成员的值，仍然可以删除它(并使它恢复到原型的值)例如：</p><pre><code class="js">function Myobj() {  this.name = &quot;instance&#39;s name&quot;}Myobj.prototype.name = &quot;prototype&#39;s name&quot;var obj = new Myobj()obj.name // &quot;instance&#39;s name&quot;delete obj.nameobj.name // &quot;prototype&#39;s name&quot;// 如果真的想彻底删除namedelete obj.constructor.prototype.name;obj.name // undefined// 但是于此同时，所有实例都将失去这一属性</code></pre><p>delete仅在删除一个不能删除的成员的时候才返回<code>false</code>，其余的时候，例如删除不存在的成员，或者删除继承自父类/原型的成员，即使删除不成功也会返回<code>true</code></p><p>delete操作删除宿主对象的成员时，也可能存在问题，删除后仍能用<code>in</code>运算返回<code>true</code>，但是取值会报错</p><h4 id="3-1-3-5-方法的调用"><a href="#3-1-3-5-方法的调用" class="headerlink" title="3.1.3.5 方法的调用"></a>3.1.3.5 方法的调用</h4><p>JS中可以用两种方式来对类的方法进行调用</p><pre><code class="js">// 基于运算符.obj.method();// 基于运算符[]obj.[&#39;method&#39;]()</code></pre><h3 id="3-1-4-使用对象自身"><a href="#3-1-4-使用对象自身" class="headerlink" title="3.1.4 使用对象自身"></a>3.1.4 使用对象自身</h3><p>有一些操作对象是仅针对对象自身而非对象成员的，典型的例子就是<code>instanceof</code>和<code>typeof</code>，还有一些运算或者语句是直接作用于对象自身的</p><h4 id="3-1-4-1-与基础类型数据之间的运算"><a href="#3-1-4-1-与基础类型数据之间的运算" class="headerlink" title="3.1.4.1 与基础类型数据之间的运算"></a>3.1.4.1 与基础类型数据之间的运算</h4><p>对象可以直接与其他基础类型的数据进行运算</p><pre><code class="js">// 尝试进行数值运算console.log(new Object * 1)</code></pre><p>虽然返回的是<code>NaN</code>但是这个操作本身是有意义的，表明Object的实例，包括任何对象实例，都可以被先转换成基础类型，再与值”1“进行数值运算，转换过程与<code>Object.prototype.valueOf()</code>有关</p><h4 id="3-1-4-2-默认对象的绑定"><a href="#3-1-4-2-默认对象的绑定" class="headerlink" title="3.1.4.2 默认对象的绑定"></a>3.1.4.2 默认对象的绑定</h4><p>在JS中，脚本引擎可以很容易的区分用户代码是在访问值、对象还是对象的成员</p><p><code>with</code>是使用对象自身的另一种方法，他的作用在于存取对象的成员</p><h3 id="3-1-5-符号"><a href="#3-1-5-符号" class="headerlink" title="3.1.5 符号"></a>3.1.5 符号</h3><p>符号作为数据类型，使用<code>Symbol()</code>函数来创建新值<br><code>var aSymbol = Symbol()</code><br>这种情况下，<code>symbol()</code>被称为”符号类型“而不是”符号类“，而值<code>aSymbol</code>直接被称为符号，在语义上是指”aSymbol是Symbol()类型的一个值”</p><p>符号可以作为对象的成员名使用，且这种对象成员仍然被称为属性，也具有一般属性具有的全部性质，也可以继承或者基于原型访问等。唯一不同的是，它通常需要特殊的方式猜能列举、存取和使用</p><h4 id="3-1-5-1-列举符号属性"><a href="#3-1-5-1-列举符号属性" class="headerlink" title="3.1.5.1 列举符号属性"></a>3.1.5.1 列举符号属性</h4><p>当符号用作对象的属性名时，我们称该属性为“符号属性”，唯一能有效列举符号属性的方法是<code>Object.getOwnPropertySymbols()</code></p><p>因为正常情况下没办法枚举，所以也没必要去隐藏它们，例如设置<code>enumerable</code>为<code>false</code>，无论如何<code>Object.getOwnPropertySymbols()</code>都可以获取一个对象全部的、自有的符号属性列表</p><p>默认情况下对象没有自有的符号属性，所以<code>Object.getOwnPropertySymbols(new Object)</code>会返回一个空数组</p><h4 id="3-1-5-2-改变对象内部行为"><a href="#3-1-5-2-改变对象内部行为" class="headerlink" title="3.1.5.2 改变对象内部行为"></a>3.1.5.2 改变对象内部行为</h4><p>由于JS对内部行为的约定，所有对象的行为都受到一些“与内部行为相关”的符号属性的影响。这些符号定义在<code>Symbol</code>类型中，更详细的去参考”3.6.1.2可能被符号影响的行为“</p><h4 id="3-1-5-3-全局符号表"><a href="#3-1-5-3-全局符号表" class="headerlink" title="3.1.5.3 全局符号表"></a>3.1.5.3 全局符号表</h4><p>使用字符串作为属性名可以随处访问，例如：</p><pre><code class="js">// 模块Avar propName = &#39;myProp&#39;export var obj = {[propName]: 100};// 模块Bimport {obj} from &#39;module_a&#39;;console.log(obj[&#39;propName&#39;]);</code></pre><p>然而使用符号作为属性名时，例如</p><pre><code class="js">var symbolPropName = Symbol()export var obj = {[symbolPropName]: 100}</code></pre><p>就必须导出<code>symbolPropName</code>来访问对应的属性</p><p>但是JS提供了一个新的手段</p><pre><code class="js">Symbol.for(keyName)</code></pre><p>JS能确保即使用户代码在多个地方调用了<code>Symbol.for(keyName)</code>也只有第一次会返回（并创建）符号，而此后的调用都将直接返回该符号，这种内建的机制保证了这些符号全局唯一，也意味着Symbol在全局建立了一个”符号名-符号“的对照表。因此，这个符号表也可以反过来查找它的<code>KeyName</code>，例如：<code>console.log(Symbol.keyFor(s));</code>显式符号s注册的名字是：’symbolPropName’</p><h2 id="3-2-JavaScript的原型继承"><a href="#3-2-JavaScript的原型继承" class="headerlink" title="3.2 JavaScript的原型继承"></a>3.2 JavaScript的原型继承</h2><p>一个对象系统的继承特性有三种实现方案，包括基于类（class-based）、基于原型（prototype-based）和基于元类（metaclass-based）。这三种对象模型各具特色，也各有应用。在这其中，JS使用了原型继承来实现对象系统，并基于原型继承实现了具备类继承特征的对象系统。</p><h3 id="3-2-1-空（null）与空白对象（empty）"><a href="#3-2-1-空（null）与空白对象（empty）" class="headerlink" title="3.2.1 空（null）与空白对象（empty）"></a>3.2.1 空（null）与空白对象（empty）</h3><p>JS中，空白对象是整个原型继承体系的根基，但是我们从空(null)对象说起</p><p>JS中，空(null)，是作为一个保留字存在的，代表一个”属于对象类型的空值“。因为它属于对象类型，所以也可以用<code>for ... in</code>去列举它，又因为它是空值，所以没有任何方法和属性，因而枚举不到内容，另一方面，多数对象相关的方法都将null作为特殊值处理，例如不能使用<code>Object.keys()</code>来列举值</p><p>null也可以参与运算，例如<code>+</code>和<code>-</code>运算，但是由于它不是创建自<code>Object()</code>构造器及其子类，因此<code>instanceof</code>运算会返回<code>false</code></p><p>null不是空白对象，空白对象（也称为裸对象），是一个标准的，通过<code>Object()</code>构造的对象实例，例如：</p><pre><code class="js">obj = new Object()obj1 = {}</code></pre><p>由于对象的字面量声明也会隐式的调用<code>Object()</code>来构造实例，所以两者都是空白对象</p><p>空白对象具有对象的一切特性，因此可以使用对象的内置属性和方法，而且<code>instanceof</code>运算符也会返回<code>true</code></p><p>默认情况下空白对象只具有原生对象的一些内置成员，<code>for...in</code>语句并不列举它们</p><h4 id="3-2-1-1-空白对象是所有对象的基础"><a href="#3-2-1-1-空白对象是所有对象的基础" class="headerlink" title="3.2.1.1 空白对象是所有对象的基础"></a>3.2.1.1 空白对象是所有对象的基础</h4><p>我们用下边的代码来考察以下最基本的<code>Object()</code>构造器：</p><pre><code class="js">// 列举原型对象成员并计数var num = 0for (var n in Object.prototype) {  num++;}// 显示计数0console.log(num)</code></pre><p>说明<code>Object()</code>构造器的原型就是一个空白对象，这就意味着，下边的两行代码，无非就是从<code>Object.prototype</code>上复制出一个“对象”的映像来——它们也是空白对象</p><pre><code class="js">obj1  = new Object();obj2 = {};</code></pre><p>因此，对象的构建过程可以被简单的理解为“对原型的复制”</p><p>原型的含义是指，如果构造器有一个原型对象，则由该构造器创建的实例都必然复制自该原型对象。换言之，所谓“原型”就是由构造器用于生成实例的模板。而这样的“复制”就存在多种可能性，由此引出动态绑定和静态绑等问题。</p><p>假如不考虑“复制”如何被实现，至少我们可以关注到，由于实例复制自原型，所以它必然有（或者说继承了）后者——原型对象——的所有属性、方法和其他性质</p><p>这也就是所谓继承性的实现</p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记4</title>
    <link href="undefined2020/07/green4/"/>
    <url>2020/07/green4/</url>
    
    <content type="html"><![CDATA[<h2 id="2-7-运算符的二义性"><a href="#2-7-运算符的二义性" class="headerlink" title="2.7 运算符的二义性"></a>2.7 运算符的二义性</h2><p>存在二义性的语法元素</p><table><thead><tr><th align="center">运算符</th><th align="center">含义</th><th align="center">其他含义</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">增值运算符<br>正值运算符<br>链接运算符</td><td align="center">数值字面量声明<br>(正值、负值或指数形式)</td></tr><tr><td align="center">( )</td><td align="center">函数调用运算符<br>分组运算符</td><td align="center">new运算符的形式参数表<br>(某些语句中的语法符号)<br>(分组运算符常用作强制优先级)</td></tr><tr><td align="center">?:</td><td align="center">条件运算符</td><td align="center">:号有声明标签的含义<br>:号有声明switch分支的含义<br>:号有声明对象成员的含义</td></tr><tr><td align="center">,</td><td align="center">连续运算符</td><td align="center">参数分隔符<br>对象、数组声明分隔符</td></tr><tr><td align="center">[]</td><td align="center">解构赋值<br>数组下标<br>对象成员存取</td><td align="center">数组字面量声明</td></tr><tr><td align="center">*</td><td align="center">幂运算符<br>乘法运算符<br>yield委托</td><td align="center">生成器函数声明</td></tr><tr><td align="center">{ }</td><td align="center">解构赋值</td><td align="center">复合语句<br>函数的代码体<br>字面量风格的对象声明</td></tr><tr><td align="center">;</td><td align="center"></td><td align="center">空语句<br>语句分隔符<br>类声明分隔符<br>(分号可以被回车和文末符代替)</td></tr><tr><td align="center">in</td><td align="center">属性检查</td><td align="center">循环语句的语法元素</td></tr><tr><td align="center">async</td><td align="center"></td><td align="center">箭头函数声明有语法歧义</td></tr></tbody></table><h3 id="2-7-1-加号”-”的二义性"><a href="#2-7-1-加号”-”的二义性" class="headerlink" title="2.7.1 加号”+”的二义性"></a>2.7.1 加号”+”的二义性</h3><p>加号可以表示字符串链接、数字取正值的一元运算、数值表达式的求和运算，字符串和数字求和容易出现二义性</p><p>如果表达式中存在字符串则优先按字符串链接进行运算</p><p>当加号执行的是值运算的时候，当对象<code>x</code>参与运算时，将调用<code>x.valueOf()</code>来确定操作数的类型<code>T</code>如果仍不能满足要求，则尝试<code>x.toString()</code>，这样的复杂的类型转换逻辑导致实际的操作结果变得难以预测</p><h3 id="2-7-2-括号”-”的二义性"><a href="#2-7-2-括号”-”的二义性" class="headerlink" title="2.7.2 括号”()”的二义性"></a>2.7.2 括号”()”的二义性</h3><p>阔号最常见的形式之一就是作为函数声明中的”虚拟参数表“</p><p>但是某些情况下只作为”传值参数表“而不表达函数调用的含义。到目前为止只出现在<code>new</code>关键字的使用中：<code>new</code>关键字用于创建一个对象实例并负责调用该构造器函数，如果有一对阔号指示的参数表，则在调用构造器的时候传入该参数表</p><p>也用于循环语句中，会有将表达式转换为布尔值的作用，在<code>with(x)</code>中会将<code>x</code>转化为对象、</p><p>还可以用于强制表达式运算</p><pre><code class="js">var str = (&#39;please input a string&#39;, 1000)</code></pre><p>这里由于连续运算符<code>,</code>的返回值是最后一个表达式的值，所以结果是1000</p><p>最后一种作为函数\方法的调用运算符</p><blockquote><p>无论<code>break (label)</code>看起来如何合理，也会被引擎识别为语法错误，因为标签是不可以交给括号运算符处理的操作，数标签与操作数属于两个各自独立的、可重复（而不发生覆盖）的标识符系统</p></blockquote><h3 id="2-7-3-冒号”-”与标签的二义性"><a href="#2-7-3-冒号”-”与标签的二义性" class="headerlink" title="2.7.3 冒号”:”与标签的二义性"></a>2.7.3 冒号”:”与标签的二义性</h3><p>冒号有三种语法作用：声明对象字面量的成名和声明标签，以及在<code>switch</code>语句中声明一个分支，冒号还具有一个运算符的含义:在三元表达式中，表示条件为<code>false</code>时的表达式分支，冒号的二义性问题集中在标签声明和对象成员声明的识别上，下一节讲</p><h3 id="2-7-4-大括号”-”的二义性"><a href="#2-7-4-大括号”-”的二义性" class="headerlink" title="2.7.4 大括号”{}”的二义性"></a>2.7.4 大括号”{}”的二义性</h3><p>大括号有六种作用。在所有场景中，它都是作为词法/语法符号来使用的</p><h4 id="2-7-4-1-复合语句-语句块"><a href="#2-7-4-1-复合语句-语句块" class="headerlink" title="2.7.4.1 复合语句/语句块"></a>2.7.4.1 复合语句/语句块</h4><p>第一种比较常见，表示”复合语句“</p><pre><code class="js">// 示例一：表示标签后的复合语句myLabel: {  // ...}// 实例二：在其他语句中表示复合语句if(condition) {  // ...}else {  // ...}</code></pre><p>由于语句末尾大括号前后都可以省略<code>;</code>号，因此下边的代码就值得回味了</p><pre><code class="js">// 示例三：复合语句中的表达式语句{1,2,3}</code></pre><p>复合语句中的<code>,</code>被理解为连续运算符，所以省略了一个分号，但是当它与一个解构赋值模板来比较时，就会发现语法解析上的困难了</p><pre><code class="cmd"># 左侧是赋值模板&gt; let {a, b} = {a: 100, b:1000}# 如下是对象声明&gt; {a, b}{a: 100, b: 1000}#如下是语句&gt; {a, b}1000</code></pre><h4 id="2-7-4-2-声明对象字面量"><a href="#2-7-4-2-声明对象字面量" class="headerlink" title="2.7.4.2 声明对象字面量"></a>2.7.4.2 声明对象字面量</h4><p>当大括号用作对象声明时，它的字面量声明部分其实是一个字面量风格的单值表达式，我们可以考虑使用以下方法让单值表达式编程语句，但它并不总是可行的，因为<code>{</code>在语法解析的时候被优先作为语句块的开始符号，所以要实现类似效果需要让引擎将这一部分代码按表达式解析</p><pre><code class="js">// 使用分号的表示法{a: 1,b: 2}// 使用复合语句的表示法{{a: 1,b: 2}}// 先强制作为连续运算语句，然后将对象字面量理解为单值表达式0, {a: 1,b: 2}</code></pre><p>接下来会变得复杂一点</p><pre><code class="js">if(true) {  entry: 1}</code></pre><p>if语句后边的语句可能是以下三者之一：</p><ul><li>一个单行语句</li><li>一个表达式(语句)</li><li>一个由大括号包起来的复合语句</li></ul><p>正确的理解仍然是”语句优先“，所以大括号变成了复合语句，所以<code>entry:1</code>变成了标签，最后的输出时<code>1</code></p><p>但是用户仍然可以使用强制表达式运算的方式得到对象字面量</p><pre><code class="js">if(true)({  entry: 1})</code></pre><h4 id="2-7-4-3-函数声明"><a href="#2-7-4-3-函数声明" class="headerlink" title="2.7.4.3 函数声明"></a>2.7.4.3 函数声明</h4><p>大括号的第三种用法，是声明函数字面量时的语法符号</p><p>作为参考，下面这段代码的语法歧义是阔号运算符导致的，而不是大括号除了问题</p><pre><code class="js">function foo() {  // ...}(1,2);</code></pre><h4 id="2-7-4-4-结构化异常"><a href="#2-7-4-4-结构化异常" class="headerlink" title="2.7.4.4 结构化异常"></a>2.7.4.4 结构化异常</h4><p>大括号也是结构化异常处理的语法符号，大括号在结构化异常中是语法符号，因此不能用单行语句来代替</p><h4 id="2-7-4-5-模板中的变量引用"><a href="#2-7-4-5-模板中的变量引用" class="headerlink" title="2.7.4.5 模板中的变量引用"></a>2.7.4.5 模板中的变量引用</h4><p>由于模板内不存在语句，所以大括号就不会被理解成语句，而是一个对象，这也是<code>eval</code>和模板最大的不同</p><h4 id="2-7-4-6-解构赋值"><a href="#2-7-4-6-解构赋值" class="headerlink" title="2.7.4.6 解构赋值"></a>2.7.4.6 解构赋值</h4><p>解构赋值利用赋值表达式左右运算数的不同来消除二义性。从语法设计的角度来讲，赋值表达式左侧的运算数是一个引用，而右侧是一个值</p><ul><li>将右侧的结果赋值给左侧的引用来存储</li><li>如果左侧的被引用对象没有存储能力，就抛出异常<pre><code class="js">8 = 8;// 向一个&quot;值&quot;赋值的行为是引用异常，不是语法分析期的错误</code></pre>在赋值模板中不可以使用字符串模板</li></ul><p>赋值模板还可能出现函数的参数界面或者try语句所隐含的异常对象声明中</p><h4 id="2-7-5-逗号”-”的二义性"><a href="#2-7-5-逗号”-”的二义性" class="headerlink" title="2.7.5 逗号”,”的二义性"></a>2.7.5 逗号”,”的二义性</h4><p>逗号既可以是语法分隔符，又可以是运算符，在它作为“联系运算符”的效果是运算表达式并返回结果值</p><pre><code class="js">a = (1,2,3)// 如果没有阔号，会优先进行赋值运算a = 1,2,3// 返回3，同时a被赋值为1var a = 1,2,3// 但是如果作为变量声明的话就会出现错误，因为逗号被理解为var声明分隔多个变量的语法分隔符，而不是连续运算符</code></pre><h4 id="2-7-6-方括号”-”的二义性"><a href="#2-7-6-方括号”-”的二义性" class="headerlink" title="2.7.6 方括号”[]”的二义性"></a>2.7.6 方括号”[]”的二义性</h4><p>下边的代码有语法错误么</p><pre><code class="js">a = [ [1] [1]];</code></pre><p>并没有语法错误，但是我们几乎不理解这行代码的意义，但是可以被JS理解，a会被赋值为undefined，也就是说，右边部分作为表达式，可以被运算出一个结果，只有一个元素的数组，该元素为undefined</p><p>同理</p><pre><code class="js">array = [[&#39;pop&#39;],[&#39;push&#39;][&#39;length&#39;]]// =&gt; [[&#39;pop&#39;],1]</code></pre><p>不过这样的二义性还不够复杂，下边的例子呈现了下面三个语法二义性带来的恶果</p><ul><li>方括号可以被理解成数组声明或者下标存取</li><li>方括号还可以理解为对象成员存取</li><li>逗号可以被理解成语法分隔符或者连续运算符</li></ul><pre><code class="js">var table = [  [&#39;A&#39;,1,2,3]  [&#39;B&#39;,4,5,6],  [&#39;c&#39;,6,7,8]]/*[  undefined,  [&#39;c&#39;,6,7,8]]*/</code></pre><p>它的第二行并没有被理解成一个数组，也没有理解成数组元素的存取，相反，被理解成了四个表达式的连续运算，因为<code>[&#39;A&#39;,1,2,3]</code>是一个数组对象，所以后边的<code>[]</code>被理解为“对象属性存取运算符”，那么规则就变成了这样</p><ul><li>如果其中运算的结果是整数，则用于下标存取</li><li>如果其中运算的结果是字符串，则用于对象成员存取</li></ul><p>所以<code>[&#39;B&#39;,4,5,6]</code>就得到了<code>[6]</code>，所以<code>[&#39;A&#39;,1,2,3][&#39;B&#39;,4,5,6]</code>的结果是undefined。</p><h3 id="2-7-7-语法设计中对二义性的处理"><a href="#2-7-7-语法设计中对二义性的处理" class="headerlink" title="2.7.7 语法设计中对二义性的处理"></a>2.7.7 语法设计中对二义性的处理</h3><p>额，，说明了以下语法解析经常会遇到一些神奇的东西，就很多二义性的问题需要处理。语法分析器：我太难了</p><p>给出了一个好玩的例子</p><pre><code class="js">{ 100 : a = 100 } = { 100 : a = 100}</code></pre><p>书上说会得到有趣的结果，但是我只得到了报错，，，嘤嘤嘤</p><h1 id="第三章-JavaScript的面向语言特性"><a href="#第三章-JavaScript的面向语言特性" class="headerlink" title="第三章 JavaScript的面向语言特性"></a>第三章 JavaScript的面向语言特性</h1><h2 id="3-1-面向对象编程的语法概要"><a href="#3-1-面向对象编程的语法概要" class="headerlink" title="3.1 面向对象编程的语法概要"></a>3.1 面向对象编程的语法概要</h2><h3 id="3-1-1-对象声明和实例创建"><a href="#3-1-1-对象声明和实例创建" class="headerlink" title="3.1.1 对象声明和实例创建"></a>3.1.1 对象声明和实例创建</h3><p>通常可以使用字面量创建对象，或者用new关键字创建新的对象实例，也可以通过宿主程序来添加自己的构造器，并用new关键字来创建它们的对象实例，并允许用户在脚本代码中持有和使用它</p><h4 id="3-1-1-1-使用构造器创建对象实例"><a href="#3-1-1-1-使用构造器创建对象实例" class="headerlink" title="3.1.1.1 使用构造器创建对象实例"></a>3.1.1.1 使用构造器创建对象实例</h4><p>构造器是创建和初始化对象一般性的方法，需要通过new运算符让构造器产生对象实例，构造器可以是普通函数也可以是JS内置的或者宿主程序拓展的构造器——按照管理，首字母大写</p><p>在语法中，参数表为空和没有参数表是一样的，所以下边两种写法等价，但是如果参数不为空，则视为构造参数，这种情况下构造函数不是一个普通意义上的函数，因此这里不能直接将其理解为函数参数列表</p><pre><code class="js">obj = new MyObject();obj = new MyObject;</code></pre><p>JS将在构造器函数执行过程中传入new运算所产生的实例，并将该实例作为this对象引用传入，就可以通过修改this对象引用的成员来完成对象构造阶段的初始化对象实例</p><p>也可以只将构造器作为普通的函数来使用，当返回值不是值类型的时候，将替代实例返回，值类型会被忽略，返回实例</p><p>JS中还会设计一些其他“初始化对象实例”的方法。但更多的牵涉到原型继承的问题，所以如下内容安排到3.2中去讨论</p><ul><li>通过构造原型实例来初始化</li><li>通过<code>Object.create()</code>并使用属性描述符得方式来创建对象并初始化</li></ul><h4 id="3-1-1-2-声明对象字面量"><a href="#3-1-1-2-声明对象字面量" class="headerlink" title="3.1.1.2 声明对象字面量"></a>3.1.1.2 声明对象字面量</h4><p>使用字面量声明比使用构造函数要方便， 声明的时候“属性名”可以用字符串、数字或者一般标识符，只有在特殊的情况才使用字符串，通常指</p><ul><li>使用的标识符不满足JS对标识符的规则</li><li>特殊的、强调的属性名</li></ul><p>在“属性名”的声明中也允许使用<code>[]</code>，可以包含一个符号，或者可计算表达式的值来作为名字，这个值只能是symbol或者string类型的，否则将尝试转化成为string类型的值，也可以直接引用变量名作为属性值，同时使用该变量的值作为属性值，而且这在<code>with</code>语句中也是可用的</p><p>这些语法带来了简洁而灵活的对象字面量声明方式，并有效的利用了其他已存在的变量名，此外，还可以用对象展开语法来引用对象的成员（而非对象自身）</p><p>方法声明是新的特定语法（而不是省略掉function关键字的函数声明），还是匿名的函数</p><pre><code class="js">profile = {  method() {    // ...  }}</code></pre><p>也可以加上<code>set/get</code>，用来表示这是属性存取方法</p><p>某些类的对象实例也可以使用它特有的字面量声明语法，具体来说就是数组、正则表达式，另外，空对象也是以字面量<code>null</code>的形式存在（当然也可以看场常量、或者语法关键字）</p><h4 id="3-1-1-3-数组及其字面量"><a href="#3-1-1-3-数组及其字面量" class="headerlink" title="3.1.1.3 数组及其字面量"></a>3.1.1.3 数组及其字面量</h4><p>可以使用new运算来创建一个数组</p><pre><code class="js">// 创建一个指定长度的数组arr = new Array(10)</code></pre><p>当参数只有一个并且是数值类型的时候，创建出来的会是一个长度为数值，每个元素都是undefined的空数组，其余情况每个值将作为数值的内容按顺序放入，但是这样就不如直接用字面量声明了</p><p>用字面量来声明数组时，数组可以是异质的（数组元素的类型可以不同），交错的（数组元素可以是不同维度的数组）。数组的这种交错性使它看起来像是“多维的”，事实上不过是“数组的数组”这种嵌套属性</p><p>想要获取交错数组的某个下标分量的方法</p><pre><code class="js">var arr = [,[,,[,,,&quot;abc&quot;]]]// 正常的访问arr[1][2][3]// 或者模板赋值语法var {1:{2:{3:x}}} = arrx // =&gt; &quot;abc&quot;</code></pre><p>也可以使用数值字符串作为下标来访问数组成员，但这时语义上却有所不同，这种情况下是将数组作为对象来进行“名-值”存取的</p><p>不但数组可以作为对象使用，反过来，某些对象也可以用作数组，这称为“类数组”。例如：<code>arguments</code></p><p>所有数组都是可迭代对象，但是类数组不一定可迭代</p><h4 id="3-1-1-4-正则表达式及其字面量"><a href="#3-1-1-4-正则表达式及其字面量" class="headerlink" title="3.1.1.4 正则表达式及其字面量"></a>3.1.1.4 正则表达式及其字面量</h4><p>正则表达式的语法为<code>/expression pattern/flags</code></p><p>正则表达式的flag和元字符建议去百度学习，这里就不抄写了</p><p>另外注意匹配转义符号<code>\</code>需要转义<code>\\</code></p><h4 id="3-1-1-5-在对象声明中使用属性存取器"><a href="#3-1-1-5-在对象声明中使用属性存取器" class="headerlink" title="3.1.1.5 在对象声明中使用属性存取器"></a>3.1.1.5 在对象声明中使用属性存取器</h4><p>除了上述的基础语法之外，还可以在字面量声明中使用属性的“存取器”，也称为读写器<code>(get/setter)</code>，具有对象方法的一切性质，只不过通常被称为存取器函数。</p><pre><code class="js">get propName() {  // ...}set propName(newValue) {  // ...}</code></pre><p>仅在ES5的严格模式下，属性声明和该属性的存取器声明不能同时出现，解析器会认为声明了两个相同名字的属性，抛出一个无效属性的异常</p><h3 id="3-1-2-使用类继承体系"><a href="#3-1-2-使用类继承体系" class="headerlink" title="3.1.2 使用类继承体系"></a>3.1.2 使用类继承体系</h3><p>使用new运算从“构造器”创建对象时，构造器既可以是一般函数，也可以是从ES6开始支持的“类”，这种类本质上是一种声明构造器的方式，因而所谓类继承，其实也是传统原型继承模式的一种表现方式</p><h4 id="3-1-2-1-声明类和继承关系"><a href="#3-1-2-1-声明类和继承关系" class="headerlink" title="3.1.2.1 声明类和继承关系"></a>3.1.2.1 声明类和继承关系</h4><p>声明一个类本质上就是声明一个构造器函数，其基本语法为：</p><pre><code class="js">class className [extends parentClass] {  constructor() {    // ...  }}</code></pre><p>当父类<code>(super)</code>是内置的<code>Object()</code>时，<code>extends Object</code>可以省略，当不需要指定构造过程时，<code>constructor(){...}</code>声明也可以省略，这样一来，下边三个声明在语义上就是等效的</p><pre><code class="js">// 最简单的类声明class MyObject()// 等价于(采用构造函数声明风格)function MyObject() {}// 或等价于(采用变量声明风格)var MyObject = new Function;</code></pre><p>对于使用<code>class</code>关键字的类声明过程来说，最明显的收益就是可以使用<code>extends</code>来声明父类</p><pre><code class="js">class MyObjectEx extends MyObject {  // ...}</code></pre><p>这基本代替了原先在构造函数声明风格中的如下代码：</p><pre><code class="js">// 与如下效果类似MyObjectEx.prototype = new MyObject();MyObjectEx.prototype.contructor = MyObjectEx;</code></pre><p>由<code>class</code>引导的整个类声明（包括类表达式）代码块总是工作在严格模式中，意味着<code>extends</code>声明也同样处于严格模式之下，用<code>extends</code>声明的父类是一个表达式(的结果值)，因此事实上是说，该表达式将运行在严格模式中。</p><pre><code class="js">// 在extends中的表达式，例如字面量风格的函数表达式，是处于严格模式中的class MyObject extends function x() {xyz = 123;} {  // ...}new MyObject()// ReferenceError: xyz is not definded</code></pre><p>最后，在将一般函数用作构造器时，函数体就是构造过程本身，而在使用<code>class</code>关键字时，该构造过程就被独立出来使用特定的方法进行声明，即<code>constructor</code></p><h4 id="3-1-2-2-声明属性"><a href="#3-1-2-2-声明属性" class="headerlink" title="3.1.2.2 声明属性"></a>3.1.2.2 声明属性</h4><p>使用函数作为构造器时需要通过原型来声明对象实例的属性，例如</p><pre><code class="js">// 构造函数声明风格function MyObject(){}// 在原型上声明属性MyObject.prototype.aName = &#39;value&#39;;</code></pre><p>而对于使用<code>class</code>关键字的类声明过程来说，这些声明都可以采用特定的关键字或者语法来声明：</p><pre><code class="js">// 类声明风格class MyObject {  // 声明属性的读方法  get aName() {    // ...  }  // 声明属性的写方法  set aName(value) {    // ...  }  // 声明方法  aMethod() {    // ...  }}</code></pre><p>如果在上例中只有<code>get</code>或者<code>set</code>之一，那么这个属性就是只读或者只写的，并且你只能使用这种方法来声明类的存取属性，如果打算声明一般属性，那么仍然需要直接操作这个类的原型</p><pre><code class="js">class MyObject{}// 在原型中声明属性MyObject.prototype.aName = &#39;value&#39;// 示例var obj = new MyObject();console.log(obj.aName) // value</code></pre><h3 id="3-1-2-3-调用父类构造方法"><a href="#3-1-2-3-调用父类构造方法" class="headerlink" title="3.1.2.3 调用父类构造方法"></a>3.1.2.3 调用父类构造方法</h3><p>在上例中，如果我们为<code>MyObject</code>派生一个子类<code>MyobjectEx</code>那么可以知道的是，子类是以父类的一个实例为原型的</p><p>关键字<code>extends</code>为你实现了类似的逻辑</p><pre><code class="js">// 作用类似于如下MyObjectEx.prototype = new MyObject()MyObjectEx.prototype.constructor = MyObjectEx</code></pre><p>我们也知道，如果构造器<code>MyObject</code>是支持参数的，那么由于<code>extends</code>只声明了继承关系，因而无法传递给构造函数所需要的参数，要实现这个，就需要在子类的构造函数中调用父类的构造函数，JS规定这个构造方法可以是父类，也可以是父类的构造器——在整个类声明过程中可以使用<code>super</code>关键字来进行访问，例如：</p><pre><code class="js">// 访问父类的构造方法class MyObjectEx extends Myobject {  constructor() {    super(x, y)  }}</code></pre><p>在这种情况下使用<code>super</code>会默认传入当前所构造的实例作为父类可以访问的<code>this</code>引用，也就是说，<code>new</code>运算所创建的对象实例将在当前类和父类(整个继承链)中传递，在这个效果上，它于如下使用构造函数的传统方式是类似的(注意下例中的<code>MyObject()</code>也必须声明为传统的构造器，即普通函数)：</p><pre><code class="js">function MyObjectEx() {  // super(x,y) 将实现为类似的代码  MyObjct.apply(this, (x,y))}MyObjectEx.prototype = new MyObject()MyObjectEx.prototype.constructor = MyObjectEx</code></pre><p>于是就可以在构造方法中操作<code>this</code>实例了，注意在使用<code>this</code>之前们总是需要显示的调用<code>super</code>以便在当前构造方法中获取this实例，如果没有<code>extends</code>，难么不调用<code>super</code>也是可以的</p><h4 id="3-1-2-4-调用父类方法"><a href="#3-1-2-4-调用父类方法" class="headerlink" title="3.1.2.4 调用父类方法"></a>3.1.2.4 调用父类方法</h4><p>在类声明语法中可以直接调用父类方法，这需要用到<code>super.XXX</code>引用</p><pre><code class="js">// 声明基类上的foo方法class MyObjct {  foo(x) {    // ...  }}// 使用继承class MyObjectEx extends MyObject {  foo(x, y) {    super.foo(x); // 调用父类同名方法  }  bar(x) {    super.foo(x); // 调用父类方法  }}</code></pre><blockquote><p><code>super.XXX</code>是属性引用，而<code>super.XXX()</code>是将属性作为方法调用的语法，关于这一点的细节，看3.3.2.3 super对一般属性的意义</p></blockquote><p>在使用<code>super.XXX</code>调用父类方法的时候也会隐式的传入当前this的引用，这个和在构造函数中使用<code>super</code>是一样的</p><h4 id="3-1-2-5-类成员-类静态成员"><a href="#3-1-2-5-类成员-类静态成员" class="headerlink" title="3.1.2.5 类成员(类静态成员)"></a>3.1.2.5 类成员(类静态成员)</h4><p>在类声明语法中也可以使用<code>static</code>关键字来声明类静态成员，包括静态方法和属性，并且它们在子类中也是作为类成员继承的</p><pre><code class="js">// 声明类的静态方法和属性class MyObject {  static get aName() {    return 10;  }  static foo() {    console.log(super.toString());  }}class MyObjectEx extends MyObject {}// 访问类静态成员console.log(MyObject.aName)// 调用类静态方法MyObject.foo();// 子类可以继承MyObjectEx.foo();/*10class MyObject {  static get aName() {    return 10;  }  static foo() {    console.log(super.toString());  }}class MyObjectEx extends MyObject {}*/</code></pre><p>访问类静态成员的时候不需要创建对象实例，因为它是类自有的成员，如果是方法(包括静态方法和属性存取方法)，那么也是可以使用<code>super</code>的。指示在其中调用<code>super</code>或者<code>super.XXX</code>的时候，this会绑定到类(构造函数本身)——因为这个时候并没有创建对象实例</p><p>事实上，类静态成员也可以直接声明为“类、构造器函数”的成员，除了不能使用<code>super</code>以外，<code>this</code>也没有绑定到类，并没有特别的不同</p><pre><code class="js">// 于上例等效的声明class MyObjct {}MyObject.aName = 10;MyObject.foo = function() {  console.log(Object.toString.call(MyObject));}// 访问类静态成员console.log(MyObject.aName);// 调用类静态方法MyObject.foo();</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记3</title>
    <link href="undefined2020/07/green3/"/>
    <url>2020/07/green3/</url>
    
    <content type="html"><![CDATA[<h2 id="2-4-JavaScript的语法-语句"><a href="#2-4-JavaScript的语法-语句" class="headerlink" title="2.4 JavaScript的语法: 语句"></a>2.4 JavaScript的语法: 语句</h2><p>JS是一门在执行过程中以表达式求值为核心设计的语言</p><p>语句：是代码语法分析中的核心元素，通常是单行语句，或者由一对大括号括起来的复合语句，在语法描述中，复合语句可以整体作为一个单行语句处理</p><p>这里有两个原则</p><ul><li>语句由语法符号<code>;</code>来分隔</li><li>一些语句存在返回值</li></ul><h3 id="2-4-1-表达式语句"><a href="#2-4-1-表达式语句" class="headerlink" title="2.4.1 表达式语句"></a>2.4.1 表达式语句</h3><p>下边的代码显然是表达式</p><pre><code class="js">1+2+3</code></pre><p>在后边加一个分号<code>1+2+3;</code>就成为了表达式语句</p><p>JS中，许多语法和语义最终都是由”表达式语句“来实现的，例如赋值、函数调用、以及我们在语言中常见的”调用对象方法“。由于表达式运算总是有值的——这包括<code>NaN</code>和<code>undefined</code>因此表达式语句也总是有值</p><h4 id="2-4-1-1-一般表达式语句"><a href="#2-4-1-1-一般表达式语句" class="headerlink" title="2.4.1.1 一般表达式语句"></a>2.4.1.1 一般表达式语句</h4><p>单值后边加分号就是单值表达式</p><p><code>evel()</code>会返回”最后执行到的、有返回值“的那条语句的值</p><p>JS允许空语句，但是使用的时候一定要加好注释，否则代码审查将无法清晰地理解使用该技术的意图</p><h4 id="2-4-1-2-赋值语句和隐式的变量声明"><a href="#2-4-1-2-赋值语句和隐式的变量声明" class="headerlink" title="2.4.1.2 赋值语句和隐式的变量声明"></a>2.4.1.2 赋值语句和隐式的变量声明</h4><p>赋值语句在JS中也是典型的表达式语句，是”赋值表达式运算“的一种效果，并且可以继续参与运算</p><pre><code class="js">str2 = &#39;this is a &#39; + (str = &#39;test string&#39;)</code></pre><p>可以加一个分号表明这是一个表达式语句</p><p>赋值表达式具有隐式声明变量的功能，但是会声明到全局上，视为局部变量的”泄露“，严格模式不允许向未声明的变量直接赋值</p><h4 id="2-4-1-3-函数调用语句"><a href="#2-4-1-3-函数调用语句" class="headerlink" title="2.4.1.3 函数调用语句"></a>2.4.1.3 函数调用语句</h4><p>JS中的函数本身是一个变量/值，所以函数调用也是一个表达式</p><p>函数调用方法</p><pre><code class="js">// 具名函数直接调用function a() {  // ...}a();// 匿名函数通过引用来调用b = function () {  // ...}b();// 非引用匿名函数的调用方法1(function () {  // ...}());// 非引用匿名函数的调用方法2(function () {  // ...})()// 非引用匿名函数的调用方法3void function() {  // ...} ();</code></pre><blockquote><p>匿名函数调用方法1和2的运算过程是不同的<br>方法一中，用分组运算符使函数调用得以执行<br>方法二中，用分组运算符使”函数字面量“这个表达式求职，并返回一个函数自身的引用，然后通过函数调用运算符<code>()</code>来操作这个函数的引用，换言之，”函数调用运算符<code>()</code>“在方法一中作用于匿名函数本身，方法二中却作用于一个运算的结果值</p></blockquote><p>不能不加小括号直接调用，例如</p><pre><code class="js">function() {  // ...}(1,2)// 这个是能通过语法检测的，但是并不能正确运算，因为被解释成了function () {  // ...};(1,2);</code></pre><p>类似的技巧也可以在箭头函数中使用，箭头函数通常可以在表达式中声明，并在声明后立即调用，但是需要一个阔号来将箭头函数声明作为一个操作数</p><pre><code class="js">&gt; x = 1 + (y =&gt; y + 2)(5) + 1018</code></pre><h3 id="2-4-2-变量声明语句"><a href="#2-4-2-变量声明语句" class="headerlink" title="2.4.2 变量声明语句"></a>2.4.2 变量声明语句</h3><p>纯粹的”变量声明语句“的语义，只是声明该变量名字（而无视它的初始赋值）</p><p><code>var a = 1</code>在JS中，将该语句分为”变量声明 + 赋值语句“在两个不同阶段中处理，<code>var a</code>作为变量声明在语法解析阶段就被处理，<code>a = 1</code>在执行阶段处理，通过赋值向变量名a绑定具体的值，严格来说，JS中所有显式的数据声明都是按这种处理方法来实现的，包括<code>var  let const</code>声明、函数声明等</p><p>除此之外，具名函数（包括生成器和类）的声明，函数形式参数名的声明，以及在<code>try catch</code>分支中捕获异常的那个变量名都属于显式声明的范畴，不再详述</p><h3 id="2-4-3-分支语句"><a href="#2-4-3-分支语句" class="headerlink" title="2.4.3 分支语句"></a>2.4.3 分支语句</h3><p>和C语言差不多，但是不幸的是，C语言的分支语句和其他语言差别很大,hhh</p><h4 id="2-4-3-1-条件分支语句（if语句）"><a href="#2-4-3-1-条件分支语句（if语句）" class="headerlink" title="2.4.3.1 条件分支语句（if语句）"></a>2.4.3.1 条件分支语句（if语句）</h4><pre><code class="js">if (condition)   statement1else  statement2</code></pre><p>statement1、statement2在语法上标明是”语句“，由于”在语法描述中，复合语句可以整体作为一个单行语句处理“，因此大括号是复合语句中的语法符号，不是if语句的语法元素</p><p><code>if ... else if ...</code>这样的格式并非是”一种语法的变种“，只不过else子句中的statement2是一个新的、单行的if语句而已</p><h4 id="2-4-3-2-多重分支语句-switch语句"><a href="#2-4-3-2-多重分支语句-switch语句" class="headerlink" title="2.4.3.2 多重分支语句(switch语句)"></a>2.4.3.2 多重分支语句(switch语句)</h4><pre><code class="js">switch(x) {  case 100:    j++;    i += j;    break;  case 200:    // ...}</code></pre><p>关键字<code>case</code>只需要标识分支的入口点，而无需标识这些分支的开始和结束，所以在<code>case</code>分支中通常是直接书写多行代码而无需大括号。</p><p>一定要注意不要忘了加<code>break;</code>，它之前的上一个语句最好加分号，如果需要特殊操作需要省略<code>break;</code>要在旁边注释好</p><h3 id="2-4-4-循环语句"><a href="#2-4-4-循环语句" class="headerlink" title="2.4.4 循环语句"></a>2.4.4 循环语句</h3><p>for循环、while循环、do…while循环</p><p>循环条件都应当是有意义的，少数情况放<code>true</code>表示无限循环</p><p>循环体可以使用空语句，但是除了展示技巧以外并无益处</p><p>除了这三种还有几种用于对象成员列举的循环语句，后边会说</p><h3 id="2-4-5-流程控制：一般子句"><a href="#2-4-5-流程控制：一般子句" class="headerlink" title="2.4.5 流程控制：一般子句"></a>2.4.5 流程控制：一般子句</h3><p><code>break、continue、return</code>都是受上下文限制的，不能随意使用</p><h4 id="2-4-5-1-标签声明"><a href="#2-4-5-1-标签声明" class="headerlink" title="2.4.5.1 标签声明"></a>2.4.5.1 标签声明</h4><p>JS中的标签就是一个标识符，标签可以和变量名重名而互不影响，因为是一种独立的语法元素，(不是变量也不是类型)</p><p>标签不能作用于注释语句、模块导入导出语句、以及函数或者类的声明语句。因为这些语句没有执行含义。</p><p>绿宝书上对它的功能描述不多，看不太懂，这篇博客回答了功能性上的问题<a href="https://segmentfault.com/a/1190000014127816" target="_blank" rel="noopener">链接</a></p><h4 id="2-4-5-2-break语句"><a href="#2-4-5-2-break语句" class="headerlink" title="2.4.5.2 break语句"></a>2.4.5.2 break语句</h4><p>如果在<code>for、while</code>语句中使用<code>break</code>，那么表明停止一个最内层的循环，如果在<code>switch</code>语句中则直接跳出整个语句</p><p>尽管不太常见，但是<code>default</code>分支中的break在某些情况下是有价值的，例如</p><pre><code class="js">  default:    if(...) break;    // ...}</code></pre><p>break配合标签可以跳出整个标签（指示了break的作用范围）</p><h4 id="2-4-5-3-continue子句"><a href="#2-4-5-3-continue子句" class="headerlink" title="2.4.5.3 continue子句"></a>2.4.5.3 continue子句</h4><p>仅对循环语句有意义，表明跳出当前循环并转到下一次循环迭代开始运行</p><h4 id="2-4-5-4-return子句"><a href="#2-4-5-4-return子句" class="headerlink" title="2.4.5.4 return子句"></a>2.4.5.4 return子句</h4><p>只能在一个函数内，同一个函数允许多个return子句，当函数被调用时，代码执行到第一个return子句则退出该函数并返回return子句所指定的值：当return子句没有指定返回值时，该函数返回undefined</p><p>当执行函数的逻辑过程中没有return 会执行到最后一个语句并返回undefined</p><h3 id="2-4-6-流程控制：异常"><a href="#2-4-6-流程控制：异常" class="headerlink" title="2.4.6 流程控制：异常"></a>2.4.6 流程控制：异常</h3><p>结构化异常处理的语法结构如下：</p><pre><code class="js">try {  // tryStatements}catch (e) {  // catchStatements}finally {  // finallyStatements};</code></pre><p>该处理机制被分为三部分</p><ul><li>触发异常，使用<code>throw</code>语句可以在任何位置触发异常，或者由引擎内部在执行过程中触发异常</li><li>捕获异常，使用<code>try...catch</code>语句可以（在形式上表明）捕获一个代码块中可能发生的异常，并使用<code>expection</code>来指向该异常的一个引用</li><li>结束处理，使用<code>try...finally</code>可以无视指定代码块中发生的异常，确保<code>finally</code>中的语句总是被执行</li></ul><blockquote><p>在<code>try</code>块中使用<code>return</code>，<code>finally</code>中的语句仍会被执行，在<code>catch</code>块中使用<code>break</code>，<code>finally</code>中的语句仍会被执行</p></blockquote><blockquote><p>如果<code>throw</code>出现在<code>finally</code>语句块中，那么它之后的语句也不能被执行，同理，如果出现了错误后边的语句也不能被执行，尽可能保证<code>finally</code>中的代码都能安全，无异常的执行</p></blockquote><h2 id="2-5-JavaScript的语法：模块"><a href="#2-5-JavaScript的语法：模块" class="headerlink" title="2.5 JavaScript的语法：模块"></a>2.5 JavaScript的语法：模块</h2><h3 id="2-5-1-模块的声明与加载"><a href="#2-5-1-模块的声明与加载" class="headerlink" title="2.5.1 模块的声明与加载"></a>2.5.1 模块的声明与加载</h3><p>即使一个js文件没有<code>export</code>语句，它也可以被其他文件作为模块导入，在这种情况下，JS引擎仍然会为它创建一个空的导出名字表。也就是说，这两种行为——使用<code>export</code>语句来表明自己是模块，与普通文件作为模块加载——在ECMAScript中式没有差别的<br>ECMAScript约定只能在模块文件的顶层使用<code>import/export</code>语句，不能用在<code>if/for</code>等语句块中，或者将它们用<code>try...catch</code>语句包括起来</p><h4 id="2-5-1-1-加载模块"><a href="#2-5-1-1-加载模块" class="headerlink" title="2.5.1.1 加载模块"></a>2.5.1.1 加载模块</h4><pre><code class="js">// 简单装载import &#39;module-name&#39;;// 命名导入import defaultExport from &#39;module-name&#39;;import { importList } from &#39;module-name&#39;;// 名字空间导入import * as aNameSpace from &#39;module-name&#39;;// 默认导入的扩展形式import defaultExport, ... from &#39;module-name&#39;;</code></pre><p>如果只打算引入一个模块而无视它对外导出的内容，使用简单装载，由于模块可被多次加载并且首次加载之后就被缓存，所以也可以使用简单装载进行预装载模块</p><p>装载模块意味着模块中的顶层代码会被执行一次，由于引擎的模块装载系统会静态扫描全部模块并确定装载的次序，所以事实上模块名在import语句中出现和被依赖的次序就成为了顶层代码执行的顺序，后续的模块是基于缓存的，所以顶层的代码不会反复执行</p><p>模块可以导出一个没有名字的实体——值或者对象</p><pre><code class="js">// 例如：被导入模块(module-name)export default ...;// 当前模块import x from &quot;module-name&quot;;</code></pre><p>这样就在当前模块中命名了x这个标识符。如果源模块已经声明了x这个名字的导出，可以使用以下语法</p><pre><code class="js">// 例如：被导入模块(module-name)export var x = ...;// 当前模块import {x} from &quot;module-name&quot;;</code></pre><p>或者将这个名字导入成新名字y</p><pre><code class="js">// 当前模块import {x as y} from &quot;module-name&quot;;// 也可以导入一个使用”,“分隔的名字列表import {x, x as y, z} from &quot;module-name&quot;;</code></pre><p>或者将所有名字导入一个名字空间</p><pre><code class="js">// 得到&quot;moudule-name&quot;的名字空间(唯一实例)import * as myNames from &quot;module-name&quot;;</code></pre><p>默认导入和名字导入是两种不同的语法风格，起因于原模块中页存在着两种不同的声明方法，为了简便ECMAScript也约定了可以将两种风格混用的语法，即“默认导入的扩展形式”，例如：</p><pre><code class="js">// 混用默认导入和名字导入import defaultExport, {names...} from &#39;module-name&#39;;// 混用默认导入和名字空间导入import defaultExport, * as aNameSpace from &quot;module-name&quot;;</code></pre><h4 id="2-5-1-2-声明模块"><a href="#2-5-1-2-声明模块" class="headerlink" title="2.5.1.2 声明模块"></a>2.5.1.2 声明模块</h4><pre><code class="js">// 导出声明export let name1, name2=..., ..., nameN; // 包括 var、count 等声明export function FunctionName() { ... } // 包括具名的函数声明和类声明// 导出已声明的名字，其中default将作为默认名特殊处理export {name1, variableName as name2, name as default, ...};// 将一个数据用默认名导出export default ...; // 可以是任何数据、变量和声明，包括匿名函数和类声明// 导出指定模块中的名字(聚合多个模块中的导出名)export ... from &quot;module-name&quot;; // 支持导出名字、默认名或者整个名字空间</code></pre><p>所有在JS中通过声明语法得到的名字都可以被导出，并且<code>export</code>可以直接加载声明语句之前</p><pre><code class="js">// 用默认名导出表达式执行额结果export deafult 1 + 2</code></pre><p>处理这个语句的时候，语法分析阶段只是会在导出表中建立名字<code>default</code>，而这个名字和值的绑定再执行阶段才会处理，这与JS处理<code>var</code>是相似的</p><p>可以通过当前模块导出其他模块中定义的名字，这称为<strong>聚合</strong></p><pre><code class="js">// 聚合（并导出）源模块module-name中的名字x或者vexport { x } from &quot;module-name&quot;;export { v as x} from &quot;module-name&quot;;</code></pre><p>但在使用：</p><pre><code class="js">// 聚合（并导出）源模块module-name中的全部名字export * from &quot;module-name&quot;;</code></pre><p>这样的语法是，那些被聚合的名字不会重复出现在当前模块额导出表中，只是需要引用某个名字时，先查找自己的导出名字中是否存在，没有再通过一个内部登记项(称为REquestedModules)来索引那些源模块，以实现深度遍历</p><h3 id="2-5-2-名字空间的特殊性"><a href="#2-5-2-名字空间的特殊性" class="headerlink" title="2.5.2 名字空间的特殊性"></a>2.5.2 名字空间的特殊性</h3><p>在ECMAScript中，名字空间看起来像一个普通对象，并且也可以通过对象成员来存取那些被导出的名字，不过由于名字空间对象的原型是null。所以除了导出名字之外它没有任何多余的成员名</p><h4 id="2-5-2-1-名字空间的创建者"><a href="#2-5-2-1-名字空间的创建者" class="headerlink" title="2.5.2.1 名字空间的创建者"></a>2.5.2.1 名字空间的创建者</h4><p>具体的JavaScript引擎在装载主模块并开始执行第一行用户代码之前，通过语法分析就可以得出所有模块之间的导出、导入关系。所有通过</p><pre><code class="js">export ... from &#39;module-name&#39;;</code></pre><p>语法声明聚合的模块都被优先装载，随后是使用类似</p><pre><code class="js">import ... from &#39;module-name&#39;;</code></pre><p>语法显式指定了导入项的模块，在所有模块依赖关系的深度遍历结束后，JS就会开始向当前模块（主模块）的执行环境中添加<code>import</code>项所声明的名字，并让导出名（源模块的）与本地模块(当前模块)绑定在一起</p><p>在所有其他方式声明的（例如，使用<code>var</code>声明或者函数声明）的名字创建之前，那些import导入的名字就已经被创建并且绑定了值，然而自此以后，模块依赖的维护工作就结束了，也就是说，主模块根本就没有自己的名字空间</p><p>除了这个特例，其他的模块都在他们被<code>import</code>导入的时候，由JS引擎为之创建了一个对应的名字空间对象，显然，主模块没有被import导入过</p><h4 id="2-5-2-2-名字空间中的名字是属性名"><a href="#2-5-2-2-名字空间中的名字是属性名" class="headerlink" title="2.5.2.2 名字空间中的名字是属性名"></a>2.5.2.2 名字空间中的名字是属性名</h4><p>不同于导入名，名字空间的名字其实是属性名，可以像对象属性一样操作，因为名字空间本身是一个特殊对象，所以它的属性，也有一些特殊性</p><p>属性描述符显示名字是可写的，且名字空间(作为对象)未被冻结</p><p>但是删除或者更新属性描述符的操作都将直接返回<code>false</code>，由于模块总是在严格模式中，所以会引发异常</p><p>如果尝试使用<code>Object.defineProperty()</code>来更新属性描述符，而新的描述符相对于默认值是没有变化的，那么就不会触发异常，如果有变化就会触发异常</p><p>当然，我们仍可以列举完整的名字列表</p><h4 id="2-5-2-3-使用上的一些特殊属性"><a href="#2-5-2-3-使用上的一些特殊属性" class="headerlink" title="2.5.2.3 使用上的一些特殊属性"></a>2.5.2.3 使用上的一些特殊属性</h4><p>导入名先于代码执行被创建，因此可以提前使用</p><pre><code class="js">console.log(x) // x是有值的import x from &#39;module-name&#39;</code></pre><p>使用命名导入，与使用“名字空间+本地变量声明”的效果在表面上是相似的</p><p>但是存取方式是有着本质上的差别的</p><pre><code class="js">// 例如：被导入模块export var x = &#39;good&#39;;// 1. 导入名字空间，使用myNames.ximport * as myNames from &#39;module-name&#39;// 2. 导入名字，使用导入名ximport { x } from &#39;module-name&#39;// 3. 名字空间+本地变量声明，使用本地名字x2var {x : x2} = myNames// 测试console.log(x, x2, myNames.x) // good good good</code></pre><p>对于方法一，参见上一小节，<code>myNames.x</code>是一个对象属性，但与一般对象属性的操作不同，方法2中x是当前模块中的一个本地名字，它被创建为所谓的“非可变简介绑定”，并关联到目标模块的导出项，这决定该本地名字和常量是相类似的，是不可写的，当读取x的时候发生了操作是：</p><ul><li>当前模块查找到一个引用名x</li><li>发现它绑定到了源模块的导出名x</li><li>会调用源模块的内部操作返回x</li></ul><p>所以这是一个源模块的引用，所以对x写操作会报错</p><p>但是使用方法三的时候，x2是一个本地变量，是本地环境中的值，而不是引用，所以可以被修改，因为从引用中取值的操作在之前模板赋值的时候就已经发生过了</p><p>使用名字空间的一个好处是，如果使用import导入一个名字，但是模块中没有这个名字的导出，就会报错，但是使用名字空间就可以得到<code>undefinded</code>而不报错</p><h2 id="2-6-严格模式下的语法限制"><a href="#2-6-严格模式下的语法限制" class="headerlink" title="2.6 严格模式下的语法限制"></a>2.6 严格模式下的语法限制</h2><p>ES5开始支持严格模式，需要使用字符串序列</p><pre><code class="js">&quot;use strict&quot;</code></pre><p>来开启，可以是一对双引号，也可以是一对单引号，代码中是一个字符串字面量，被用在一段代码的最前面，作为“指示前缀”，可以加入的地方包括</p><ul><li>全局代码的开始处加入</li><li>在<code>eval</code>代码开始处加入</li><li>在函数声明代码开始处加入</li><li>在<code>new function()</code>所传入的<code>body</code>参数快开始处加入</li></ul><p>例如：</p><pre><code class="js">// 下边的函数声明表明它是一个运行在严格模式下的函数function foo() {  &quot;use strict&quot;;  return true;}</code></pre><p>除了这种显式进入严格模式的方法之外，如下情况下的代码也处于严格模式中</p><ul><li>模块中</li><li>类声明和类表达式的整个声明块中</li><li>引擎或者宿主的运行参数中指定”node –use_strict”</li></ul><p>语法限制：不能通过语法检查</p><p>执行限制：会导致运行期错误的限制</p><h3 id="2-6-1-语法限制"><a href="#2-6-1-语法限制" class="headerlink" title="2.6.1 语法限制"></a>2.6.1 语法限制</h3><p>总的来说，有七种语法在严格模式中被禁用</p><p>一、在对象字面量声明中存在相同的属性名，非严格模式下，声明将使用最后一个有效的声明项</p><p>二、在函数声明中，参数表中含有相同的参数名，非严格模式下，访问同名的参数时，只有最后一个是有效的</p><p>三、不能声明或者重写<code>eval</code>和<code>arguments</code>两个标识符，也就是说不能出现在运算符的左边，也不能用<code>var</code>来声明，由于<code>catch</code>以及具名函数都会隐式的声明变量名，所以也不能使用这两个作为标识符，最后这两个不能使用<code>delete</code>进行删除，在非严格模式中，上述语法都是有效的，但是一些引擎中重写<code>eval</code>会导致运行期异常</p><p>四、用0前缀声明的八进制字面量，非严格模式下<code>012</code>将显示<code>12</code></p><p>五、用delete删除显式声明的标识符、名称或者具名函数，例如</p><pre><code class="js">var adelete a</code></pre><p>非严格模式下，这个操作仅仅是无效的，但是不会报错</p><p>六、在代码中使用一些保留字，包括<code>implements、interface、let、package、private、protected、public、static和yield</code>，非严格模式下是可用的</p><p>七、在代码中包含<code>with</code>语句</p><h3 id="2-6-2-执行限制"><a href="#2-6-2-执行限制" class="headerlink" title="2.6.2 执行限制"></a>2.6.2 执行限制</h3><p>一、在严格模式下向不存在的标识符复制，将导致“引用异常”，非严格模式下会隐式声明</p><p>二、运算符处理一些不可处理的操作数，将导致“类型异常或者语法错误”</p><p>三、访问arguments.callee或者函数的caller属性将导致“类型异常”</p><p>四、以下代码的执行效果和非严格模式不一致</p><pre><code class="js">// 严格模式下返回传入的值// 非严格模式下返回100function f(x) {arguments[0] = 100; return x;}f(&#39;abc&#39;)</code></pre><h3 id="2-6-3-严格模式的范围"><a href="#2-6-3-严格模式的范围" class="headerlink" title="2.6.3 严格模式的范围"></a>2.6.3 严格模式的范围</h3><p>除非在创建和启动引擎的时候将它设置为严格模式，或者通过模块来进行加载，否则用户代码只能指定一个有限范围的严格模式</p><h4 id="2-6-3-1-有限范围的严格模式"><a href="#2-6-3-1-有限范围的严格模式" class="headerlink" title="2.6.3.1 有限范围的严格模式"></a>2.6.3.1 有限范围的严格模式</h4><p>写在文件第一行就表明该代码块是严格模式</p><p>写在函数第一行表明函数是严格模式，函数名出问题也会报错，函数之外没影响</p><h4 id="2-6-3-2-非严格模式下的全局环境"><a href="#2-6-3-2-非严格模式下的全局环境" class="headerlink" title="2.6.3.2 非严格模式下的全局环境"></a>2.6.3.2 非严格模式下的全局环境</h4><p>在任何处于严格模式下的代码中，JS都允许用户代码通过两种方式将代码执行在一个非严格全局环境中</p><ul><li>使用间接调用的<code>eval()</code>函数，后边会说</li><li>使用<code>new Function</code>方式创建的函数，后边会说</li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记2</title>
    <link href="undefined2020/07/green2/"/>
    <url>2020/07/green2/</url>
    
    <content type="html"><![CDATA[<h2 id="2-3-JavaScript的语法：表达式运算"><a href="#2-3-JavaScript的语法：表达式运算" class="headerlink" title="2.3 JavaScript的语法：表达式运算"></a>2.3 JavaScript的语法：表达式运算</h2><p>在JS中，运算符大多是符号，但是也有少量单词，你应当避免把他们误解成语句</p><table><thead><tr><th align="center">运算符\符号</th><th align="center">运算符含义</th></tr></thead><tbody><tr><td align="center">typeof</td><td align="center">取变量或者值得类型</td></tr><tr><td align="center">void</td><td align="center">运算表达式并忽略值</td></tr><tr><td align="center">new</td><td align="center">创建指定类的对象实例</td></tr><tr><td align="center">in</td><td align="center">检查对象属性</td></tr><tr><td align="center">instanceof</td><td align="center">检查变量是否指定类的实例</td></tr><tr><td align="center">delete</td><td align="center">删除实例属性</td></tr><tr><td align="center">yield</td><td align="center">从生成器内部返回一个值</td></tr><tr><td align="center">await</td><td align="center">在异步函数内等待一个值</td></tr></tbody></table><blockquote><p>yield 和 await 不是严格意义上的运算符</p></blockquote><p>JS中可以存在没有运算符的表达式，被称为<code>单值表达式</code>，它有值的含义，表达式的结果即是该值，主要包括</p><ul><li>this、super、new.target和arguments引用</li><li>变量引用，即一个已经声明的标识符</li><li>字面量，包括null、undefined、字符串、布尔值、数值、模板、正则表达式</li></ul><h3 id="2-3-1-一般表达式运算"><a href="#2-3-1-一般表达式运算" class="headerlink" title="2.3.1 一般表达式运算"></a>2.3.1 一般表达式运算</h3><h4 id="2-3-1-1-逻辑运算"><a href="#2-3-1-1-逻辑运算" class="headerlink" title="2.3.1.1 逻辑运算"></a>2.3.1.1 逻辑运算</h4><p>运算符会将操作数隐式转换成布尔值，以进行布尔运算</p><p>运算过程(与普通布尔运算一样)是支持布尔短路的</p><p>连续的逻辑运算可以用来替代语句</p><p><code>||</code> 如果第一个值为真，后边的表达式将不会执行</p><p><code>&amp;&amp;</code> 如果第一个值为假，后边的表达式将不会执行</p><h4 id="2-3-1-2-字符串运算"><a href="#2-3-1-2-字符串运算" class="headerlink" title="2.3.1.2 字符串运算"></a>2.3.1.2 字符串运算</h4><p>历史中JS有且只有一种字符串运算就是<code>+</code>，它总是产生一个新的字符串，它在运算效果上完全等同于调用字符串对象的<code>concat()</code>方法</p><p>ES5中引入了新的概念，将字符串作为类似数组的对象(to treat the string as an array-like object)，引入了第二个字符串运算符<code>[]</code>可以通过下标存取，但你仍不能通过该运算去修改字符串中的字符值。</p><p>ES6中，字符串添加了<code>Symbol.iterator属性，可以作为迭代对象处理，例如接受数组展开以及</code>yield*`运算（以及for…of语句）</p><h4 id="2-3-1-3-数值运算"><a href="#2-3-1-3-数值运算" class="headerlink" title="2.3.1.3 数值运算"></a>2.3.1.3 数值运算</h4><p>包括“加减乘除”等一般性的数值运算，又包括数值的位运算，在位操作中JS强制运算目标为一个有符号的32位整型数；如果目标是非数值，那么会强制转化为数值，如果目标是浮点数，则会被取整；否则，将目标识别为有符号整型数</p><p>非数值会被转化为<code>NaN</code>，运算结果仍为<code>NaN</code></p><blockquote><p>一般表达式运算符总能成功的应用于所有的数据类型，符号例外，因为符号不能转换为数值，符号在一般表达式运算中，可以作为(或转换为)布尔值<code>true</code>参与运算</p></blockquote><h3 id="2-3-2-比较运算"><a href="#2-3-2-比较运算" class="headerlink" title="2.3.2 比较运算"></a>2.3.2 比较运算</h3><p>需要关注一下JS的类型转换机制，后边会写</p><p>严格相等<code>===</code>会先比较数据的类型，因此这里不会发生类型转换，并且按照约定<code>-0 === 0</code> 以及 <code>NaN !== NaN</code>，于是ES6之后的版本设计了<code>Object.is()</code>处理类似<code>Object.is(-0, +0) === false</code>和<code>Object.is(NaN,NaN) === true</code>这样的运算逻辑</p><h4 id="2-3-2-1-等值检测"><a href="#2-3-2-1-等值检测" class="headerlink" title="2.3.2.1 等值检测"></a>2.3.2.1 等值检测</h4><p>“相等”运算规则：</p><table><thead><tr><th align="center">类型</th><th align="center">运算规则</th></tr></thead><tbody><tr><td align="center">值类型与引用类型进行比较</td><td align="center">将引用类型的数据转换为与值类型相同的数据，再进行”数据等值“比较</td></tr><tr><td align="center">两个值类型进行比较</td><td align="center">转换成相同数据类型的值进行”数据等值“比较</td></tr><tr><td align="center">两个引用类型进行比较</td><td align="center">比较引用(的地址)</td></tr></tbody></table><p>”数据等值”仅指针对“值类型”的比较而言，表明比较的是变量所指向的存储单元中的数据（通常指“内存数据”）。如果两个比较的值不同，那么：</p><ul><li>有任何一个是数字时，会将另一个转化为数字进行比较</li><li>有任何一个是布尔值时，它将被转换为数字进行比较（由于上一个规则的存在，另一个操作数也被转换为数字）</li><li>有任何一个是对象（或者函数）时，将调用该对象的<code>valueOf()</code>方法来将其转换为值数据进行比较，多数情况下，该值作为数字值进行处理</li><li>按照特定规则返回比较结果，例如<code>undefined</code>和<code>null</code>值总是相等的</li></ul><blockquote><p>JS总是尽量使用数字值比较实现等值检测</p></blockquote><p>“严格相等”运算规则：</p><table><thead><tr><th align="center">类型</th><th align="center">运算规则</th></tr></thead><tbody><tr><td align="center">值类型与引用类型进行比较</td><td align="center">必然不“严格相等”</td></tr><tr><td align="center">两个值类型进行比较</td><td align="center">如果数据类型不同，则必然“不严格相等”；否则，按等值检测中“相等”的运算规则进行比较</td></tr><tr><td align="center">两个引用类型进行比较</td><td align="center">比较引用(的地址)</td></tr></tbody></table><blockquote><p>符号可以转换为true但是不等值于true<br>即使字面量相同的引用类型也是不严格相等的<code>{} === {} // false</code></p></blockquote><h4 id="2-3-2-2-序列检测"><a href="#2-3-2-2-序列检测" class="headerlink" title="2.3.2.2 序列检测"></a>2.3.2.2 序列检测</h4><p>Number类型是实数数轴的抽象</p><p>当等值检测中有任何一个数据是符号时。无需进行类型转换，因为它总是不等值于任何其他数据</p><p>运算符<code>&gt; &gt;= &lt; &lt;=</code></p><p>任何值与NaN进行序列检测都得到false</p><p>布尔值会转换为<code>0</code>或者<code>1</code></p><p>序列检测的运算规则：</p><table><thead><tr><th align="center">类型</th><th align="center">运算规则</th></tr></thead><tbody><tr><td align="center">值类型与引用类型进行比较</td><td align="center">将引用类型的数据转换为与值类型数据相同的数据，再进行”序列大小“的比较</td></tr><tr><td align="center">两个值类型进行比较</td><td align="center">直接比较数据在序列中的大小</td></tr><tr><td align="center">两个引用类型进行比较</td><td align="center">无意义，返回false</td></tr></tbody></table><blockquote><p>对引用类型进行序列检测运算其实是可能的，这与<code>valueOf()</code>运算的效果有关，但这意味着最终比较的数据并非引用类型本身，而是它们转换后的值类型</p></blockquote><p>最后，所谓的字符串的序列检测，在具体实现上是有限制的：</p><ul><li>当两个操作数都是字符串的时候，4个运算符才表示字符串检测序列</li><li>当任意一个操作数时非字符串时，会将字符串转换为数值来参与运算</li></ul><h3 id="2-3-3-赋值运算"><a href="#2-3-3-赋值运算" class="headerlink" title="2.3.3 赋值运算"></a>2.3.3 赋值运算</h3><p>一般赋值运算符<code>=</code></p><p>带操作的赋值运算符(复合赋值运算符)<code>v += e</code></p><p>自增自减运算符(隐含赋值运算)<code>v++</code></p><p>JS中赋值是一个运算而不是一个语句，所以在赋值表达式中，运算符左右都是操作数，当然，按表达式的概念，表达式的操作数可以是值也可以是引用，所以从语法上来看<code>100 = 1000</code>是成立的，并且可以通过JS的语法检测，但是会在运行中报错</p><h4 id="2-3-3-1-赋值的语义"><a href="#2-3-3-1-赋值的语义" class="headerlink" title="2.3.3.1 赋值的语义"></a>2.3.3.1 赋值的语义</h4><p>赋值运算的本质：赋值的效果时修改存储单元中的值</p><p>只是在更加术语化的表述中，这个行为也被称为”（值与标识符的）绑定“</p><p>对于引用类型来说只是复制了一个地址</p><p>这里有两个特例，值类型的字符串是一个大的，不确定长度的连续数据块，这导致复制数据的开销很大，所以在JS中，字符串的赋值也变成了复制地址——该字符串的地址引用，由此引入了三条字符串处理的限制：</p><ul><li>不能直接修改字符串中的字符</li><li>字符串链接运算必然导致写复制，这将产生新的字符串</li><li>不能改变字符串的长短，修改length属性是无意义的</li></ul><p>在ES6后的结构赋值中，赋值运算符的语义不只有”复制地址、复制引用“还包括”解析数组或者对象的成员“这一行为</p><h4 id="2-3-3-2-复合赋值运算符"><a href="#2-3-3-2-复合赋值运算符" class="headerlink" title="2.3.3.2 复合赋值运算符"></a>2.3.3.2 复合赋值运算符</h4><p>除了<code>+=</code>能用于字符串，剩下得都只能用于数值类型，如果是非数值类型，将发生隐式类型转换</p><h4 id="2-3-3-3-解构赋值"><a href="#2-3-3-3-解构赋值" class="headerlink" title="2.3.3.3 解构赋值"></a>2.3.3.3 解构赋值</h4><p>是对<code>=</code>的一个拓展，能用于所有该操作符的地方</p><h3 id="2-3-4-函数相关的表达式"><a href="#2-3-4-函数相关的表达式" class="headerlink" title="2.3.4 函数相关的表达式"></a>2.3.4 函数相关的表达式</h3><p>匿名函数和箭头函数不存在函数声明的语法</p><h4 id="2-3-4-1-匿名函数和箭头函数"><a href="#2-3-4-1-匿名函数和箭头函数" class="headerlink" title="2.3.4.1 匿名函数和箭头函数"></a>2.3.4.1 匿名函数和箭头函数</h4><p>声明函数时</p><pre><code class="js">function functionName() {  // ...}</code></pre><p>如果省略<code>functionName</code>就可以得到一个匿名函数(Anonymous Function)。这个匿名函数也可以作为字面量直接参加表达式运算——而不需要引用它的名字，例如：</p><pre><code class="js">void( 1 + function() {  // ...})</code></pre><p>箭头函数声明出来也是匿名的，毕竟它的语法中就不不能指定函数名，完整形式为</p><pre><code class="js">( parameters ) =&gt; { functionBody }</code></pre><p>当<code>parameters</code>只是一个参数时，这对圆括号可以省略</p><h4 id="2-3-4-2-函数调用"><a href="#2-3-4-2-函数调用" class="headerlink" title="2.3.4.2 函数调用"></a>2.3.4.2 函数调用</h4><p>在函数紧跟函数运算符<code>()</code>时，该运算符被解释成两个含义</p><ul><li>使函数得以执行，并且，当函数执行时</li><li>从左至右运算并传入<code>()</code>内的参数序列</li></ul><p>函数调用运算作用于以下几个变量的效果是一致的</p><pre><code class="js">function func1() {};var func2 = function() {};var func3 = new Function(&#39;&#39;);var func4 = () =&gt; {};</code></pre><p>如果运算符之前既非上述几种之一也并非他们的引用，就会触发一个运行期异常</p><p>ES6之后的模板处理函数是一种隐式的函数调用。它通过在函数后跟一个模板字符串来调用该函数，并按特定格式传入参数。</p><pre><code class="js">function foo(tp1, ...values) {  console.log(tp1) ;// {&quot;try call&quot;, &quot;.&quot;}  console.log(values[0]) // &quot;foo&quot;}// 将foo函数作为模板处理函数使用foo`try call ${foo.name}.`;</code></pre><p>其他的隐式调用函数的情况包括：</p><ul><li>将函数作为属性读取器时，属性存取操作将隐式调用该函数</li><li>使用.bind方法将原函数绑定为目标函数时，调用目标函数则隐式调用源函数</li><li>当使用Proxy()创建源函数的代理对象时，调用代理对象则隐式调用源函数</li><li>可以使用new运算符变相地调用函数</li><li>可以将函数赋值给对象的符号属性，并在对象相应行为触发时调用该函数</li><li>…</li></ul><h4 id="2-3-4-3-new运算"><a href="#2-3-4-3-new运算" class="headerlink" title="2.3.4.3 new运算"></a>2.3.4.3 new运算</h4><p>用class声明的类也将是一个函数（构造器），但它只能被<code>new</code>运算调用</p><p>严格来说，在</p><pre><code class="js">new functionReference()</code></pre><p>语法中<code>functionReference</code>后边的阔号并不是函数调用运算符，而只是<code>new</code>运算符语法的参数传入表——这是因为，在这一语法中决定（或启动）函数调用的是new运算符而不是后边的阔号，不过在少数情况下，new运算符会被用作隐式的函数调用</p><h3 id="2-3-5-特殊作用的运算符"><a href="#2-3-5-特殊作用的运算符" class="headerlink" title="2.3.5 特殊作用的运算符"></a>2.3.5 特殊作用的运算符</h3><p>有些运算符不产生运算效果，而是用于影响运算效果，这一类运算符的操作对通常是”表达式“，而并非”表达式的值“</p><h4 id="2-3-5-1-类型运算符"><a href="#2-3-5-1-类型运算符" class="headerlink" title="2.3.5.1 类型运算符"></a>2.3.5.1 类型运算符</h4><p>这里的<code>typeof</code>是运算符而不是关键字，之所以是特殊的运算符，是因为在其他运算符中，变量是以值参与运算的，而<code>typeof</code>运算符是尝试获取值的类型信息，甚至也可以直接对标识符进行运算，而无视该标识符是否存在，是否声明过，是否绑定值，类似的情况下，它将返回<code>undefined</code></p><p>ES6之后标识符不只是简单的有或者没有，所以使用typeof就不再总是安全的，当对”使用let或者const声明但是没绑定值得标识符“运算时，将会抛出一个异常</p><h4 id="2-3-5-2-展开语法"><a href="#2-3-5-2-展开语法" class="headerlink" title="2.3.5.2 展开语法"></a>2.3.5.2 展开语法</h4><p><code>...</code>称为展开”spread syntax/operator“。将它置于一个可迭代对象之前时，表明将操作数展开为一组值；将它置于一个普通对象之前时，则表明对象展开为一组属性，如果展开发生在函数调用界面上，则展开结果作为参数，如果展开在一个数组或者对象中，则结果作为他们的成员</p><h4 id="2-3-5-3-面向表达式的运算符"><a href="#2-3-5-3-面向表达式的运算符" class="headerlink" title="2.3.5.3 面向表达式的运算符"></a>2.3.5.3 面向表达式的运算符</h4><p>尽管它们以表达式为目标，但是语义上仍然是运算符，因此他们与运算对象(表达式)结合的结果仍然是表达式(而非语句)</p><p>对于ES5之后出现的 await 和 yield 来说，强制它们的操作数发生运算并得到该运算的值是他们作为运算符的基本功能，而进行流程控制时它们的副作用</p><p>在这两个运算中，await会有两种流程控制效果</p><ul><li>运算符await总会挂起函数，直到它等待的数据就绪</li><li>如果它等待的数据被rejected，那么它会触发一个throw效果，以便将<code>rejected</code>的原因，任何可能的值或者对象作为异常抛出</li><li>运算符yield总会挂起函数（并将生成的值作为外部的迭代对象的.next()方法的结果值返回）</li><li>运算符总是在外部迭代对象调用下一个.next(x)方法时恢复函数，并将传入的值作为yield运算的结果值</li></ul><h3 id="2-3-6-运算优先级"><a href="#2-3-6-运算优先级" class="headerlink" title="2.3.6 运算优先级"></a>2.3.6 运算优先级</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">()</td><td align="center">成组运算</td></tr><tr><td align="center">. [] new</td><td align="center">对象成员存取、数组下标、带参数的new</td></tr><tr><td align="center">() new</td><td align="center">函数调用、不带参数的new</td></tr><tr><td align="center">++ –</td><td align="center">后置递增、递减</td></tr><tr><td align="center">+ - ++ – ~ ! delete typeof void</td><td align="center">前置加减号、递增、递减、逻辑与、按位非、其他</td></tr><tr><td align="center">* / %</td><td align="center">乘法、除法、取模</td></tr><tr><td align="center">+ - +</td><td align="center">加法、减法、字符串链接</td></tr><tr><td align="center">&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td align="center">移位</td></tr><tr><td align="center">&lt; &gt; &lt;= &gt;= in instanceof</td><td align="center">序列检测、in、instanceof</td></tr><tr><td align="center">== != === !==</td><td align="center">等值检测</td></tr><tr><td align="center">&amp;</td><td align="center">按位与</td></tr><tr><td align="center">^</td><td align="center">按位异或</td></tr><tr><td align="center">|</td><td align="center">按位或</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与</td></tr><tr><td align="center">||</td><td align="center">逻辑或</td></tr><tr><td align="center">?:</td><td align="center">条件</td></tr><tr><td align="center">= op=</td><td align="center">赋值、运算赋值</td></tr><tr><td align="center">yield yield*</td><td align="center">yield表达式</td></tr><tr><td align="center">…</td><td align="center">展开</td></tr><tr><td align="center">,</td><td align="center">多重求值</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>绿宝书学习笔记1</title>
    <link href="undefined2020/07/green1/"/>
    <url>2020/07/green1/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-二十年来的JavaScript"><a href="#第一章-二十年来的JavaScript" class="headerlink" title="第一章 二十年来的JavaScript"></a>第一章 二十年来的JavaScript</h1><p>这一章主要介绍了作者本身的经历以及二十年来JavaScript的发展，从微软和网景的语言大战到最后的ES6，我通读了一遍，感觉没有什么需要记录下来东西，在此不做赘述</p><h1 id="第二章-JavaScript的语法"><a href="#第二章-JavaScript的语法" class="headerlink" title="第二章 JavaScript的语法"></a>第二章 JavaScript的语法</h1><p>对于JavaScript的语法叙述来讲《JavaScript权威指南》是最好的一本书，但是本书面向具有一定开发经验的程序员，所以本章只讨论语法中的关键部分，并不打算讨论更多细节</p><p>请关注每小节之前的对内容的概括和汇总性的表格，可能会和其他书籍以及你既有的知识不一致，但是这是我们后续进一步讨论语言的基础</p><h2 id="2-1-语法综述"><a href="#2-1-语法综述" class="headerlink" title="2.1 语法综述"></a>2.1 语法综述</h2><p>语言中的标识符一般分为两类，一类用于命名语法、符号等抽象概念，另一类用于命名数据。前者被称为语法关键字，后者被称为变量和常量，由此引入了一个概念：绑定。从标识符的角度来说，绑定分为语法关键字和语义逻辑的绑定，以及变量与它所存储数据和位置性质的绑定。</p><p>其中语法关键字和语义逻辑的绑定结果，是对<code>作用域</code>的限定，变量与它所存储数据和位置性质的绑定的结果，则是对变量<code>生存周期</code>的绑定</p><h3 id="2-1-1-标识符所绑定的语义"><a href="#2-1-1-标识符所绑定的语义" class="headerlink" title="2.1.1 标识符所绑定的语义"></a>2.1.1 标识符所绑定的语义</h3><p>声明的意义：所谓声明，即约定数据的生存周期和逻辑的作用域。</p><blockquote><p>这里的声明已经涵盖了逻辑与数据（这相当于<code>程序</code>的全部），因此，整个编程的过程，其实被解释成了<code>&quot;说明逻辑与数据&quot;</code>的过程：</p><ol><li>纯粹陈叔“数据”的过程，被称为变量与类型声明。</li><li>纯粹陈述“逻辑”的过程，被称为语句（包含逻辑控制语句）</li><li>陈述“数据与（算法的）逻辑”的关系的过程，被称为表达式</li></ol></blockquote><p>除了“声明”在语义上对绑定内容的限制之外，当一个被声明的标识符（变量、常量或者符号）去绑定一个数据时，事实上还有其他两个方面的语义：数据（受作用域限制）的声明周期以及可写性</p><p><strong>在JavaScript中</strong></p><ul><li>用于显式数据声明的<code>var let const</code>，函数声明以及类声明</li><li>数种for语句、try…catch语句、赋值语句</li><li>在函数调用和new运算符等语法中通过形参传入值</li></ul><p>这些语义都存在着隐式或显式变量声明的原因：它们有着各自在“作用域、值和可写性”三方面的不同性质</p><h3 id="2-1-2-识别语法错误与运行错误"><a href="#2-1-2-识别语法错误与运行错误" class="headerlink" title="2.1.2 识别语法错误与运行错误"></a>2.1.2 识别语法错误与运行错误</h3><p>如果在语法分析不通过，脚本代码块都不执行；当语法分析通过时，脚本代码才会执行。若运行过程中出错，则在同一代码上下文中，出错点之后的代码将不再执行</p><p>事实上，Node.js在命令行中传入的主文件也是作为模块加载的</p><p>可以在命令行上使用Node.js进行语法检测</p><pre><code class="cmd"># 使用node -c 或者 --check 来进行语法查错&gt; echo . | node -c -SyntaxError：Unexpected token .# 这段代码没有问题所以Node.js直接返回&gt; echo null.toString | node -c -</code></pre><h2 id="2-2-JavaScript的语法：声明"><a href="#2-2-JavaScript的语法：声明" class="headerlink" title="2.2 JavaScript的语法：声明"></a>2.2 JavaScript的语法：声明</h2><p>JS是弱类型语言，只表明该语言在表达式运算中不强制操作数的数据类型，而并不表明该语言是否具有类型系统。所以说JS是“无类型(untype language)语言”是错误的。</p><p>以数据的可写性来看可分为变量和常量；以数据类型来看，有对象、函数、符号、和值类型数据等。另一种常见的分类方法是以声明语法来进行的，JS中有六种声明标识符的方法，包括变量（var），常量（coust），块作用域变量（let），函数（function），类（class）和模块（import），它们都可以声明出在语法分析阶段就被识别的标识符。还可以分为全局变量和局部变量。</p><h3 id="2-2-1-变量的数据类型"><a href="#2-2-1-变量的数据类型" class="headerlink" title="2.2.1 变量的数据类型"></a>2.2.1 变量的数据类型</h3><table><thead><tr><th>类型</th><th>含义</th><th>说明</th><th>值/引用类型</th></tr></thead><tbody><tr><td>undefined</td><td>未定义</td><td>未声明的或者声明过但是未赋值的变量，其值会是undefined。也可以显式或者隐式的给一个变量赋值为undefined</td><td>值类型</td></tr><tr><td>number</td><td>数值</td><td>除赋值操作外，只有数值与数值的运算结果是数值；函数、方法返回值或者对象的属性值可以是数值</td><td>值类型</td></tr><tr><td>string</td><td>字符串</td><td>可以直接读取指定位置的单个字符，但不能修改</td><td>值类型</td></tr><tr><td>boolean</td><td>布尔值</td><td>true / false</td><td>值类型</td></tr><tr><td>symbol</td><td>符号</td><td>从ES6开始支持</td><td>值类型</td></tr><tr><td>function</td><td>函数</td><td>JS中的函数存在多重含义，函数、方法、构造器、生成器、类、以及函数对象等</td><td>引用类型</td></tr><tr><td>object</td><td>对象</td><td>基于原型继承和类继承的面向对象类型</td><td>引用类型</td></tr></tbody></table><h4 id="2-2-1-1-基本数据类型"><a href="#2-2-1-1-基本数据类型" class="headerlink" title="2.2.1.1 基本数据类型"></a>2.2.1.1 基本数据类型</h4><p>任何一个变量和值的类型都可以（而且应当首先）使用<code>typeof</code>运算得到，它是一个保留字，是一个运算符而不是一个函数，尽管看上过去可以在后边加上一对括号</p><p>值/引用类型已加入上表</p><p>在JS中，严格相等(===)运算符用来对值类型/引用类型的实际数据进行比较和检查，按照约定，在基于上述类型的运算中</p><ul><li>一般表达式运算的结果总是值</li><li>函数/方法吊桶的结果可以返回值类型或者引用</li><li>值与引用、值与值之间即使相等(==)，也不一定严格相等(===)</li><li>两个引用之间如果相等(===)，则一定严格相等(===)</li></ul><pre><code class="js">var str = &#39;abcde&#39;var obj = new String(str)function newToString() {  return &#39;hello, world&#39;}function func(val) {  val.toString = newToString}func(str)console.log(str) // &#39;abcde&#39;func(obj)console.log(obj) // &#39;hello, world&#39;</code></pre><p>第一个只是传入了str的值，因此对它的toString属性的修改是无意义的，但是第二个传入的是引用，所以可以影响到后来的<code>toString()</code>的结果</p><h3 id="2-2-2-变量声明"><a href="#2-2-2-变量声明" class="headerlink" title="2.2.2 变量声明"></a>2.2.2 变量声明</h3><p>JS中变量声明有两种方法：</p><ul><li>显式声明</li><li>隐式声明（即用即声明）</li></ul><p>显式声明，一般指使用<code>var</code>等关键字进行的声明。包括在一些语句中使用<code>var</code>进行声明，包括<code>for</code>语句等，还有两种情况是指具名函数声明以及异常捕获子句中的异常对象<code>e</code></p><p>而隐式声明一般发生在一般的赋值语句中</p><p>解释器总是将显式声明理解为“变量声明”，而对于隐式声明则不一定：</p><ul><li>如果变量未被声明，则先声明该变量并立即给它赋值</li><li>如果该变量已被声明，则该语句就是赋值语句</li></ul><h4 id="2-2-2-1-块级作用域的变量声明与一般var声明"><a href="#2-2-2-1-块级作用域的变量声明与一般var声明" class="headerlink" title="2.2.2.1 块级作用域的变量声明与一般var声明"></a>2.2.2.1 块级作用域的变量声明与一般var声明</h4><p>除了以下三点不同，<code>let</code>的语法以及使用场景都和<code>var</code>一致</p><ul><li><code>var</code>声明的变量，其作用域为当前函数、模块或者全局；<code>let</code>声明的变量，其作用域总是在当前的代码块，例如语句块</li><li>在同一个代码块中，可以用var来多次声明变量名，在语法分析中与声明一次没有区别；而用<code>let</code>却只能声明一次，覆盖一个已经声明的<code>let</code>变量（或者用<code>let</code>去覆盖一个已经声明过的标识符）会导致语法错误</li><li>用户代码可以在声明语句之前使用所声明的<code>var</code>变量，这时该变量的值为<code>undefined</code>；而<code>let</code>声明的变量必须先声明后使用，声明语句之前的代码引用了<code>let</code>变量会触发异常，这也会导致<code>typeof</code>成为一个不安全的运算</li></ul><p>当<code>let</code>声明在全局代码块的时候会和<code>var</code>产生一些细微的区别，<code>var</code>声明之后相当于在全局对象<code>global</code>上声明了一个属性，进而使所有代码都能将这些声明作为全局变量来访问，而<code>let</code>与一些其他的语法元素都遵循“块级作用域”的规则，即使出现在全局代码块中，也不会成为<code>global</code>上的属性</p><blockquote><p>常量声明<code>const</code>,类声明<code>class</code>在块级作用域上的特性和<code>let</code>声明是相类似的</p></blockquote><h4 id="用赋值模板声明一批变量"><a href="#用赋值模板声明一批变量" class="headerlink" title="用赋值模板声明一批变量"></a>用赋值模板声明一批变量</h4><p>JS声明一批变量的传统方法使使用<code>var</code>关键字，即在一个<code>var</code>中声明多个变量，而ES6开始支持更为灵活的结构赋值语法，这个表达式的左操作数称为“赋值模板(Assignment Pattern)”</p><p>当这个模板使用在<code>var</code>等变量声明中时，也可以成批地声明变量，例如</p><pre><code class="js">// 使用数据结构赋值，声明变量x,yvar [x, y] = [1, 2]// 使用对象结构赋值，声明变量height,widthlet {clientHeight: height, clientWidht: width} = window.document.body;</code></pre><p>还可以使用剩余参数语法来声明数组或对象。例如：</p><pre><code class="js">// 在变量声明的赋值模板中使用剩余参数，可以声明数组变量morevar [x, y, ...more] = [1, 2, 3, 4, 5]// 在对象解构赋值中使用剩余参数，可以声明对象变量morePropslet {x, y, ...moreProps} = {x: 100, y:200, z: 300}</code></pre><h3 id="2-2-3-使用字面量风格的值"><a href="#2-2-3-使用字面量风格的值" class="headerlink" title="2.2.3 使用字面量风格的值"></a>2.2.3 使用字面量风格的值</h3><p>JS中没有类型声明的概念，因此这时变量声明就只用来说明一个变量的初值，在声明中，等号右边既可以时表达式————这意味着将表达式运算的结果作为该变量的初值，也可以是更为强大和灵活的字面量声明。</p><blockquote><p>三种值类型、null值和正则表达式是被称为字面量的，而Function、Object、Array其实只是”字面量风格的声明“，他们严格来说仍然是存在着语义上的差异的</p></blockquote><h4 id="2-2-3-1-字符串字面量、转义符"><a href="#2-2-3-1-字符串字面量、转义符" class="headerlink" title="2.2.3.1 字符串字面量、转义符"></a>2.2.3.1 字符串字面量、转义符</h4><p>现在ES标准统一要求字符串必须是Unicode字符序列</p><p>转义序列列表：</p><table><thead><tr><th>转义符</th><th>含义</th></tr></thead><tbody><tr><td>\b</td><td>退格符</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\</td><td>反斜线字符</td></tr><tr><td>&#39;</td><td>单引号</td></tr><tr><td>&quot;</td><td>双引号</td></tr><tr><td>\0</td><td>字符NUL</td></tr><tr><td>\xnn</td><td>ASCII 字符编码为nn的字符</td></tr><tr><td>\unnnn</td><td>Unicode字符编码为nnnn的字符</td></tr><tr><td>\u{nnnnn}</td><td>Unicode字符编码大于0xFFFF的字符</td></tr></tbody></table><blockquote><p><code>\</code>也用于表示连续的字符串声明，只要在行末加上\就可以换行继续写字符串了</p></blockquote><h4 id="2-2-3-2-模板字面量"><a href="#2-2-3-2-模板字面量" class="headerlink" title="2.2.3.2 模板字面量"></a>2.2.3.2 模板字面量</h4><p>ES6开始出现的模板字面量(template literal)用一对反引号来标识，将其理解为一种增强的字符串声明，在使用反引号声明的字符串中，可以使用<code>${...}</code>这样的语法来捕获当前上下文中的变量、常量、字面量或者对象成员属性，以及计算一个表达式并将结果转换为字符串值——这也意味着这样的字符串其实是动态的，模板字面量本质上来说是一个字面量的引用——该字面量在JS内部表达为一个对象(array-like object)或者数组</p><p>它有一个<code>.row</code>属性指向该”表达该模板字面量的内部数组“的一个原始的、未经转义的格式。</p><pre><code class="js">console.log(String.raw({raw: [&#39;&#39;, &#39;/nworld&#39;]}, &#39;Hi&#39;))/*Hi,World*/// 等同于foo = tpl =&gt; String.raw(tpl, &#39;Hi&#39;);console.log(foo`${1},world`);</code></pre><h4 id="2-2-3-3-数值字面量"><a href="#2-2-3-3-数值字面量" class="headerlink" title="2.2.3.3 数值字面量"></a>2.2.3.3 数值字面量</h4><p>数值字面量总是以一个数字字符，或者一个点字符，以及不多于一个正值符号或者负值符号开始，当数字一字符开始的时候有四条规则</p><ul><li>0X或者0x，标明是十六进制</li><li>0o或者0O，表明是一个八进制</li><li>0b或者0B，表明是一个二进制</li><li>剩下的情况默认为十进制整数或者是浮点数</li></ul><p>当以点字符开始时，总表明是一个十进制浮点数</p><h3 id="2-2-4-其他声明"><a href="#2-2-4-其他声明" class="headerlink" title="2.2.4 其他声明"></a>2.2.4 其他声明</h3><h4 id="2-2-4-1-常量声明"><a href="#2-2-4-1-常量声明" class="headerlink" title="2.2.4.1 常量声明"></a>2.2.4.1 常量声明</h4><p><code>const</code>关键字用于常量声明，除了不可更改之外的属性都类似于<code>let</code></p><h4 id="2-2-4-2-符号声明"><a href="#2-2-4-2-符号声明" class="headerlink" title="2.2.4.2 符号声明"></a>2.2.4.2 符号声明</h4><p>符号是从ES6开始支持的一种数据类型，它可以使用一般形式的变量声明或者常量声明(const/var/let)，与其他数据类型在声明上没有什么特别的不同</p><p>符号没有字面量声明形式，由于符号是值而非对象，所以也不能用<code>new</code>运算符来创建它</p><h4 id="2-2-4-3-函数声明"><a href="#2-2-4-3-函数声明" class="headerlink" title="2.2.4.3 函数声明"></a>2.2.4.3 函数声明</h4><p>在JS中函数是一种数据类型，所以函数声明是变量声明的一种特殊形式</p><pre><code class="js">function a() {}</code></pre><p>在ES5以后的规范中，明确规定了在表达式中出现的具名函数名只影响函数内的代码，而不会影响该表达式所在的作用域</p><p>可以设定默认值，如果默认值并没有放在参数列表的尾部，那么可以使用Undefined，在传参时表明该参数使用默认值</p><p>可以使用剩余参数<code>...arg</code>来收集剩余的参数</p><blockquote><p>使用class关键字来声明的类，也是一个函数。因此可以将类声明理解为函数声明的一种特殊语法，但是类声明得到的函数只能使用<code>new</code>运算来创建对象实例，而不能直接作为函数调用。而如果语法关键字<code>function</code>之后加<code>*</code>字符。则会声明一个特殊的函数：生成器。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>绿宝书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack打包原理</title>
    <link href="undefined2020/07/webpack/"/>
    <url>2020/07/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack"></a>什么是 webpack</h2><p>本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。</p><p>webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。</p><p>webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。 – 深入浅出 webpack 吴浩麟<br><img src="/img/wp.png" alt=""></p><h2 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念"></a>webpack 核心概念</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。</p><p>进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。</p><p>基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</p><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。</p><p>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。</p><p>本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。</p><p>插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p><h2 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h2><p>Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。</li><li>确定入口：根据配置中的 entry 找出所有的入口文件。</li><li>编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。</li><li>输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。</li></ol><p>在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="实践加深理解-撸一个简易-webpack"><a href="#实践加深理解-撸一个简易-webpack" class="headerlink" title="实践加深理解,撸一个简易 webpack"></a>实践加深理解,撸一个简易 webpack</h2><h3 id="1-定义-Compiler-类"><a href="#1-定义-Compiler-类" class="headerlink" title="1. 定义 Compiler 类"></a>1. 定义 Compiler 类</h3><pre><code class="js">class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {}  // 重写 require函数,输出bundle  generate() {}}</code></pre><h3 id="2-解析入口文件-获取-AST"><a href="#2-解析入口文件-获取-AST" class="headerlink" title="2. 解析入口文件,获取 AST"></a>2. 解析入口文件,获取 AST</h3><p>我们这里使用@babel/parser,这是 babel7 的工具,来帮助我们分析内部的语法,包括 es6,返回一个 AST 抽象语法树。</p><pre><code class="js">// webpack.config.jsconst path = require(&#39;path&#39;)module.exports = {  entry: &#39;./src/index.js&#39;,  output: {    path: path.resolve(__dirname, &#39;./dist&#39;),    filename: &#39;main.js&#39;  }}//</code></pre><pre><code class="js">const fs = require(&#39;fs&#39;)const parser = require(&#39;@babel/parser&#39;)const options = require(&#39;./webpack.config&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    const ast = Parser.getAst(this.entry)  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="3-找出所有依赖模块"><a href="#3-找出所有依赖模块" class="headerlink" title="3. 找出所有依赖模块"></a>3. 找出所有依赖模块</h3><p>Babel 提供了@babel/traverse(遍历)方法维护这 AST 树的整体状态,我们这里使用它来帮我们找出依赖模块。</p><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    const { getAst, getDependecies } = Parser    const ast = getAst(this.entry)    const dependecies = getDependecies(ast, this.entry)  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="4-AST-转换为-code"><a href="#4-AST-转换为-code" class="headerlink" title="4. AST 转换为 code"></a>4. AST 转换为 code</h3><p>将 AST 语法树转换为浏览器可执行代码,我们这里使用@babel/core 和 @babel/preset-env。</p><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst { transformFromAst } = require(&#39;@babel/core&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  },  getCode: ast =&gt; {    // AST转换为code    const { code } = transformFromAst(ast, null, {      presets: [&#39;@babel/preset-env&#39;]    })    return code  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    const { getAst, getDependecies, getCode } = Parser    const ast = getAst(this.entry)    const dependecies = getDependecies(ast, this.entry)    const code = getCode(ast)  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="5-递归解析所有依赖项-生成依赖关系图"><a href="#5-递归解析所有依赖项-生成依赖关系图" class="headerlink" title="5. 递归解析所有依赖项,生成依赖关系图"></a>5. 递归解析所有依赖项,生成依赖关系图</h3><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst { transformFromAst } = require(&#39;@babel/core&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  },  getCode: ast =&gt; {    // AST转换为code    const { code } = transformFromAst(ast, null, {      presets: [&#39;@babel/preset-env&#39;]    })    return code  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    // 解析入口文件    const info = this.build(this.entry)    this.modules.push(info)    this.modules.forEach(({ dependecies }) =&gt; {      // 判断有依赖对象,递归解析所有依赖项      if (dependecies) {        for (const dependency in dependecies) {          this.modules.push(this.build(dependecies[dependency]))        }      }    })    // 生成依赖关系图    const dependencyGraph = this.modules.reduce(      (graph, item) =&gt; ({        ...graph,        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容        [item.filename]: {          dependecies: item.dependecies,          code: item.code        }      }),      {}    )  }  build(filename) {    const { getAst, getDependecies, getCode } = Parser    const ast = getAst(filename)    const dependecies = getDependecies(ast, filename)    const code = getCode(ast)    return {      // 文件路径,可以作为每个模块的唯一标识符      filename,      // 依赖对象,保存着依赖模块路径      dependecies,      // 文件内容      code    }  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="6-重写-require-函数-输出-bundle"><a href="#6-重写-require-函数-输出-bundle" class="headerlink" title="6. 重写 require 函数,输出 bundle"></a>6. 重写 require 函数,输出 bundle</h3><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst { transformFromAst } = require(&#39;@babel/core&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  },  getCode: ast =&gt; {    // AST转换为code    const { code } = transformFromAst(ast, null, {      presets: [&#39;@babel/preset-env&#39;]    })    return code  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    // 解析入口文件    const info = this.build(this.entry)    this.modules.push(info)    this.modules.forEach(({ dependecies }) =&gt; {      // 判断有依赖对象,递归解析所有依赖项      if (dependecies) {        for (const dependency in dependecies) {          this.modules.push(this.build(dependecies[dependency]))        }      }    })    // 生成依赖关系图    const dependencyGraph = this.modules.reduce(      (graph, item) =&gt; ({        ...graph,        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容        [item.filename]: {          dependecies: item.dependecies,          code: item.code        }      }),      {}    )    this.generate(dependencyGraph)  }  build(filename) {    const { getAst, getDependecies, getCode } = Parser    const ast = getAst(filename)    const dependecies = getDependecies(ast, filename)    const code = getCode(ast)    return {      // 文件路径,可以作为每个模块的唯一标识符      filename,      // 依赖对象,保存着依赖模块路径      dependecies,      // 文件内容      code    }  }  // 重写 require函数 (浏览器不能识别commonjs语法),输出bundle  generate(code) {    // 输出文件路径    const filePath = path.join(this.output.path, this.output.filename)    // 懵逼了吗? 没事,下一节我们捋一捋    const bundle = `(function(graph){      function require(module){        function localRequire(relativePath){          return require(graph[module].dependecies[relativePath])        }        var exports = {};        (function(require,exports,code){          eval(code)        })(localRequire,exports,graph[module].code);        return exports;      }      require(&#39;${this.entry}&#39;)    })(${JSON.stringify(code)})`    // 把文件内容写入到文件系统    fs.writeFileSync(filePath, bundle, &#39;utf-8&#39;)  }}new Compiler(options).run()</code></pre><h3 id="7-看完这节-彻底搞懂-bundle-实现"><a href="#7-看完这节-彻底搞懂-bundle-实现" class="headerlink" title="7. 看完这节,彻底搞懂 bundle 实现"></a>7. 看完这节,彻底搞懂 bundle 实现</h3><p>我们通过下面的例子来进行讲解,先死亡凝视 30 秒</p><pre><code class="js">;(function(graph) {  function require(moduleId) {    function localRequire(relativePath) {      return require(graph[moduleId].dependecies[relativePath])    }    var exports = {}    ;(function(require, exports, code) {      eval(code)    })(localRequire, exports, graph[moduleId].code)    return exports  }  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><h4 id="step-1-从入口文件开始执行"><a href="#step-1-从入口文件开始执行" class="headerlink" title="step 1 : 从入口文件开始执行"></a>step 1 : 从入口文件开始执行</h4><pre><code class="js">// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) {  // 重写require函数  function require(moduleId) {    console.log(moduleId) // ./src/index.js  }  // 从入口文件开始执行  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><h4 id="step-2-使用-eval-执行代码"><a href="#step-2-使用-eval-执行代码" class="headerlink" title="step 2 : 使用 eval 执行代码"></a>step 2 : 使用 eval 执行代码</h4><pre><code class="js">// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) {  // 重写require函数  function require(moduleId) {    ;(function(code) {      console.log(code) // &quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));      eval(code) // Uncaught TypeError: Cannot read property &#39;code&#39; of undefined    })(graph[moduleId].code)  }  // 从入口文件开始执行  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><p>可以看到,我们在执行”./src/index.js”文件代码的时候报错了,这是因为 index.js 里引用依赖 hello.js,而我们没有对依赖进行处理,接下来我们对依赖引用进行处理。</p><h4 id="step-3-依赖对象寻址映射-获取-exports-对象"><a href="#step-3-依赖对象寻址映射-获取-exports-对象" class="headerlink" title="step 3 : 依赖对象寻址映射,获取 exports 对象"></a>step 3 : 依赖对象寻址映射,获取 exports 对象</h4><pre><code class="js">// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) {  // 重写require函数  function require(moduleId) {    // 找到对应moduleId的依赖对象,调用require函数,eval执行,拿到exports对象    function localRequire(relativePath) {      return require(graph[moduleId].dependecies[relativePath]) // {__esModule: true, say: ƒ say(name)}    }    // 定义exports对象    var exports = {}    ;(function(require, exports, code) {      // commonjs语法使用module.exports暴露实现,我们传入的exports对象会捕获依赖对象(hello.js)暴露的实现(exports.say = say)并写入      eval(code)    })(localRequire, exports, graph[moduleId].code)    // 暴露exports对象,即暴露依赖对象对应的实现    return exports  }  // 从入口文件开始执行  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><p>这下应该明白了吧 ~ 可以直接复制上面代码到控制台输出哦~</p><p>完整代码地址<a href="https://github.com/webfansplz/article/tree/master/easy-webpack" target="_blank" rel="noopener">戳我</a> 👈</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Webpack 是一个庞大的 Node.js 应用,如果你阅读过它的源码,你会发现实现一个完整的 Webpack 需要编写非常多的代码。 但你无需了解所有的细节,只需了解其整体架构和部分细节即可。</p><p>对 Webpack 的使用者来说,它是一个简单强大的工具； 对 Webpack 的开发者来说,它是一个扩展性的高系统。</p><p>Webpack 之所以能成功,在于它把复杂的实现隐藏了起来,给用户暴露出的只是一个简单的工具,让用户能快速达成目的。 同时整体架构设计合理,扩展性高,开发扩展难度不高,通过社区补足了大量缺失的功能,让 Webpack 几乎能胜任任何场景。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.webpackjs.com" target="_blank" rel="noopener">webpack 中文文档</a></p><p><a href="https://webpack.wuhaolin.cn/" target="_blank" rel="noopener">深入浅出 webpack</a></p><blockquote><p>作者：null仔<br>链接：<a href="https://segmentfault.com/a/1190000021494964?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021494964?utm_source=tag-newest</a><br>来源：SegmentFault 思否</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>高级</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AST 抽象语法树</title>
    <link href="undefined2020/07/ast/"/>
    <url>2020/07/ast/</url>
    
    <content type="html"><![CDATA[<h1 id="AST-抽象语法树"><a href="#AST-抽象语法树" class="headerlink" title="AST 抽象语法树"></a>AST 抽象语法树</h1><blockquote><p>抽象语法树（AST），是一个非常基础而重要的知识点，但国内的文档却几乎一片空白。<br>本文将带大家从底层了解AST,并且通过发布一个小型前端工具，来带大家了解AST的强大功能</p></blockquote><h2 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h2><p>拆解一个简单的add函数</p><pre><code class="js">function add(a, b) {  return a + b}</code></pre><p>首先我们拿到了这个语法快，这是一个<code>FunctionDeclaration</code>(函数定义)对象</p><p>分解成三块</p><ul><li>一个id，就是他的名字，即<code>add</code></li><li>两个params，也就是它的参数，即[a,b]</li><li>一块body，也就是大括号里边的东西</li></ul><p>add没办法继续拆下去了，它是一个最基础的Identifier(标志)对象，用来作为函数的唯一标志，就像人的姓名一样</p><pre><code class="js">{  name: &#39;add&#39;,  type: &#39;identifier&#39;,  ...}</code></pre><p>params继续拆下去，其实是两个Identifier组成的数组。之后也没办法拆下去了。</p><pre><code class="js">[    {        name: &#39;a&#39;        type: &#39;identifier&#39;        ...    },    {        name: &#39;b&#39;        type: &#39;identifier&#39;        ...    }]</code></pre><p>接下来，我们继续拆开<code>body</code></p><p>我们发现,<code>body</code>其实是一个<code>BlockStatement</code>（块状域）对象，用来表示是<code>{return a + b}</code></p><p>打开<code>BlockStatement</code>，里边藏着一个<code>ReturnStatement</code>(Return域)对象，用来表示<code>return a + b</code></p><p>继续打开<code>ReturnStatement</code>,里边是一个<code>BinaryExpression</code>(二项式)对象，用来表示<code>a + b</code></p><p>继续打开<code>BinaryExpression</code>，它成了三部分, <code>left</code>, <code>operator</code>, <code>right</code></p><ul><li><code>operator</code> 即<code>+</code></li><li><code>left</code> 里面装的，是Identifier对象 <code>a</code></li><li><code>right</code> 里面装的，是Identifer对象 <code>b</code></li></ul><p>我们拆解完了,就是一个这样的树形结构<br><img src="https://image-static.segmentfault.com/214/084/2140843498-5b89e44deaa5c_articlex" alt=""></p><p>那么，上面我们提到的Identifier、Blockstatement、ReturnStatement、BinaryExpression， 这一个个小部件的说明书去哪查？</p><p><strong>请查看</strong> <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" target="_blank" rel="noopener">AST对象文档</a></p><h2 id="送给你的AST螺丝刀：recast"><a href="#送给你的AST螺丝刀：recast" class="headerlink" title="送给你的AST螺丝刀：recast"></a>送给你的AST螺丝刀：recast</h2><p>输入命令</p><p><code>npm i recast -s</code></p><p>你即可获得一把操纵语法树的螺丝刀</p><p>接下来，你可以在任意js文件下操纵这把螺丝刀，我们新建一个parse.js示意：</p><p>parse.js</p><pre><code class="js">// 给你一把&quot;螺丝刀&quot;——recastconst recast = require(&quot;recast&quot;);// 你的&quot;机器&quot;——一段代码// 我们使用了很奇怪格式的代码，想测试是否能维持代码结构const code =  `  function add(a, b) {    return a +      // 有什么奇怪的东西混进来了      b  }  `// 用螺丝刀解析机器const ast = recast.parse(code);// ast可以处理很巨大的代码文件// 但我们现在只需要代码块的第一个body，即add函数const add  = ast.program.body[0]console.log(add)</code></pre><p>输入node parse.js你可以查看到add函数的结构，与之前所述一致，通过AST对象文档可查到它的具体属性：</p><pre><code class="js">FunctionDeclaration{    type: &#39;FunctionDeclaration&#39;,    id: ...    params: ...    body: ...}</code></pre><p>你也可以继续使用console.log透视它的更内层，如：</p><pre><code class="js">console.log(add.params[0])console.log(add.body.body[0].argument.left)</code></pre><h2 id="recast-types-builders-制作模具"><a href="#recast-types-builders-制作模具" class="headerlink" title="recast.types.builders 制作模具"></a>recast.types.builders 制作模具</h2><p>一个机器，你只会拆开重装，不算本事。</p><p>拆开了，还能改装，才算上得了台面。</p><p><code>recast.types.builders</code>里面提供了不少“模具”，让你可以轻松地拼接成新的机器。</p><p>最简单的例子，我们想把之前的function add(a, b){…}声明，改成匿名函数式声明const add = function(a ,b){…}</p><p>如何改装？</p><p>第一步，我们创建一个<code>VariableDeclaration</code>变量声明对象，声明头为<code>const</code>， 内容为一个即将创建的<code>VariableDeclarator</code>对象。</p><p>第二步，创建一个<code>VariableDeclarator</code>，放置<code>add.id</code>在左边， 右边是将创建的<code>FunctionDeclaration</code>对象</p><p>第三步，我们创建一个<code>FunctionDeclaration</code>，如前所述的三个组件，<code>id params body</code>中，因为是匿名函数id设为空，<code>params</code>使用<code>add.params</code>，<code>body</code>使用<code>add.body</code>。</p><p>这样，就创建好了<code>const add = function(){}</code>的AST对象。</p><p>在之前的parse.js代码之后，加入以下代码</p><pre><code class="js">// 引入变量声明，变量符号，函数声明三种“模具”const {variableDeclaration, variableDeclarator, functionExpression} = recast.types.builders// 将准备好的组件置入模具，并组装回原来的ast对象。ast.program.body[0] = variableDeclaration(&quot;const&quot;, [  variableDeclarator(add.id, functionExpression(    null, // Anonymize the function expression.    add.params,    add.body  ))]);//将AST对象重新转回可以阅读的代码const output = recast.print(ast).code;console.log(output)</code></pre><p>可以看到，我们打印出了</p><pre><code class="js">const add = function(a, b) {  return a +    // 有什么奇怪的东西混进来了    b};</code></pre><p>最后一行</p><pre><code class="js">const output = recast.print(ast).code;</code></pre><p>其实是recast.parse的逆向过程，具体公式为</p><pre><code class="js">recast.print(recast.parse(source)).code === source</code></pre><p>打印出来还保留着“原装”的函数内容，连注释都没有变。</p><p>我们其实也可以打印出美化格式的代码段：</p><pre><code class="js">const output = recast.prettyPrint(ast, { tabWidth: 2 }).code</code></pre><p>输出为</p><pre><code class="js">const add = function(a, b) {  return a + b;};</code></pre><blockquote><p>现在，你是不是已经产生了“我可以通过AST树生成任何js代码”的幻觉？<br>我郑重告诉你，这不是幻觉。</p></blockquote><h2 id="实战进阶：命令行修改js文件"><a href="#实战进阶：命令行修改js文件" class="headerlink" title="实战进阶：命令行修改js文件"></a>实战进阶：命令行修改js文件</h2><p>除了<code>parse/print/builder</code>以外，Recast的三项主要功能：</p><ul><li>run: 通过命令行读取js文件，并转化成ast以供处理。</li><li>tnt： 通过assert()和check()，可以验证ast对象的类型。</li><li>visit: 遍历ast树，获取有效的AST对象并进行更改。</li></ul><p>我们通过一个系列小务来学习全部的recast工具库：</p><p>创建一个示例文件，假设是demo.js</p><p>demo.js</p><pre><code class="js">function add(a, b) {  return a + b}function sub(a, b) {  return a - b}function commonDivision(a, b) {  while (b !== 0) {    if (a &gt; b) {      a = sub(a, b)    } else {      b = sub(b, a)    }  }  return a}</code></pre><h3 id="recast-run-——-命令行文件读取"><a href="#recast-run-——-命令行文件读取" class="headerlink" title="recast.run —— 命令行文件读取"></a>recast.run —— 命令行文件读取</h3><p>新建一个名为read.js的文件，写入<br>read.js</p><pre><code class="js">const recast = require(&quot;recast&quot;);recast.run( function(ast, printSource){    printSource(ast)})</code></pre><p>命令行输入</p><pre><code class="cmd">node read demo.js</code></pre><p>我们查以看到js文件内容打印在了控制台上。</p><p>我们可以知道，<code>node read</code>可以读取<code>demo.js</code>文件，并将<code>demo.js</code>内容转化为<code>ast</code>对象。</p><p>同时它还提供了一个<code>printSource</code>函数，随时可以将ast的内容转换回源码，以方便调试。</p><h3 id="recast-visit-——-AST节点遍历"><a href="#recast-visit-——-AST节点遍历" class="headerlink" title="recast.visit —— AST节点遍历"></a>recast.visit —— AST节点遍历</h3><p>read.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast  = require(&#39;recast&#39;)recast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function({node}) {        console.log(node)        return false      }    });});</code></pre><p><code>recast.visit</code>将AST对象内的节点进行逐个遍历。</p><p>注意</p><ul><li><p>你想操作函数声明，就使用visitFunctionDelaration遍历，想操作赋值表达式，就使用visitExpressionStatement。 只要在 AST对象文档中定义的对象，在前面加visit，即可遍历。</p></li><li><p>通过node可以取到AST对象</p></li><li><p>每个遍历函数后必须加上return false，或者选择以下写法，否则报错</p></li></ul><pre><code class="js">#!/usr/bin/env nodeconst recast  = require(&#39;recast&#39;)recast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function(path) {        const node = path.node        printSource(node)        this.traverse(path)      }    })});</code></pre><p>调试时，如果你想输出AST对象，可以<code>console.log(node)</code></p><p>如果你想输出AST对象对应的源码，可以<code>printSource(node)</code></p><p>命令行输入<code>node read demo.js</code>进行测试。</p><blockquote><p>#!/usr/bin/env node 在所有使用recast.run()的文件顶部都需要加入这一行，它的意义我们最后再讨论。</p></blockquote><h3 id="TNT-——-判断AST对象类型"><a href="#TNT-——-判断AST对象类型" class="headerlink" title="TNT —— 判断AST对象类型"></a>TNT —— 判断AST对象类型</h3><p>TNT，即<code>recast.types.namedTypes</code>，就像它的名字一样火爆，它用来判断AST对象是否为指定的类型。</p><p><code>TNT.Node.assert()</code>，就像在机器里埋好的炸药，当机器不能完好运转时（类型不匹配），就炸毁机器(报错退出)</p><p><code>TNT.Node.check()</code>，则可以判断类型是否一致，并输出False和True</p><p>上述Node可以替换成任意AST对象，例如<code>TNT.ExpressionStatement.check(),TNT.FunctionDeclaration.assert()</code></p><p>read.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const TNT = recast.types.namedTypesrecast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function(path) {        const node = path.value        // 判断是否为ExpressionStatement，正确则输出一行字。        if(TNT.ExpressionStatement.check(node)){          console.log(&#39;这是一个ExpressionStatement&#39;)        }        this.traverse(path);      }    });});</code></pre><p>read.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const TNT = recast.types.namedTypesrecast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function(path) {        const node = path.node        // 判断是否为ExpressionStatement，正确不输出，错误则全局报错        TNT.ExpressionStatement.assert(node)        this.traverse(path);      }    });});</code></pre><p>命令行输入<code>node read demo.js</code>进行测试。</p><h2 id="实战：用AST修改源码，导出全部方法"><a href="#实战：用AST修改源码，导出全部方法" class="headerlink" title="实战：用AST修改源码，导出全部方法"></a>实战：用AST修改源码，导出全部方法</h2><p>exportific.js</p><p>现在，我们想让这个文件中的函数改写成能够全部导出的形式，例如</p><pre><code class="js">function add (a, b) {    return a + b}</code></pre><p>想改变为</p><pre><code class="js">exports.add = (a, b) =&gt; {  return a + b}</code></pre><p>除了使用fs.read读取文件、正则匹配替换文本、fs.write写入文件这种笨拙的方式外，我们可以用AST优雅地解决问题。</p><p>查询<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" target="_blank" rel="noopener">AST对象文档</a></p><h3 id="首先，我们先用builders凭空实现一个键头函数"><a href="#首先，我们先用builders凭空实现一个键头函数" class="headerlink" title="首先，我们先用builders凭空实现一个键头函数"></a>首先，我们先用builders凭空实现一个键头函数</h3><p>exportific.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const {  identifier:id,  expressionStatement,  memberExpression,  assignmentExpression,  arrowFunctionExpression,  blockStatement} = recast.types.buildersrecast.run(function(ast, printSource) {  // 一个块级域 {}  console.log(&#39;\n\nstep1:&#39;)  printSource(blockStatement([]))  // 一个键头函数 ()=&gt;{}  console.log(&#39;\n\nstep2:&#39;)  printSource(arrowFunctionExpression([],blockStatement([])))  // add赋值为键头函数  add = ()=&gt;{}  console.log(&#39;\n\nstep3:&#39;)  printSource(assignmentExpression(&#39;=&#39;,id(&#39;add&#39;),arrowFunctionExpression([],blockStatement([]))))  // exports.add赋值为键头函数  exports.add = ()=&gt;{}  console.log(&#39;\n\nstep4:&#39;)  printSource(expressionStatement(assignmentExpression(&#39;=&#39;,memberExpression(id(&#39;exports&#39;),id(&#39;add&#39;)),    arrowFunctionExpression([],blockStatement([])))))});</code></pre><p>上面写了我们一步一步推断出<code>exports.add = ()=&gt;{}</code>的过程，从而得到具体的AST结构体。</p><p>使用<code>node exportific demo.js</code>运行可查看结果。</p><p>接下来，只需要在获得的最终的表达式中，把id(‘add’)替换成遍历得到的函数名，把参数替换成遍历得到的函数参数，把blockStatement([])替换为遍历得到的函数块级作用域，就成功地改写了所有函数！</p><p>另外，我们需要注意，在commonDivision函数内，引用了sub函数，应改写成exports.sub</p><p>exportific.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const {  identifier: id,  expressionStatement,  memberExpression,  assignmentExpression,  arrowFunctionExpression} = recast.types.buildersrecast.run(function (ast, printSource) {  // 用来保存遍历到的全部函数名  let funcIds = []  recast.types.visit(ast, {    // 遍历所有的函数定义    visitFunctionDeclaration(path) {      //获取遍历到的函数名、参数、块级域      const node = path.node      const funcName = node.id      const params = node.params      const body = node.body      // 保存函数名      funcIds.push(funcName.name)      // 这是上一步推导出来的ast结构体      const rep = expressionStatement(assignmentExpression(&#39;=&#39;, memberExpression(id(&#39;exports&#39;), funcName),        arrowFunctionExpression(params, body)))      // 将原来函数的ast结构体，替换成推导ast结构体      path.replace(rep)      // 停止遍历      return false    }  })  recast.types.visit(ast, {    // 遍历所有的函数调用    visitCallExpression(path){      const node = path.node;      // 如果函数调用出现在函数定义中，则修改ast结构      if (funcIds.includes(node.callee.name)) {        node.callee = memberExpression(id(&#39;exports&#39;), node.callee)      }      // 停止遍历      return false    }  })  // 打印修改后的ast源码  printSource(ast)})</code></pre><h3 id="一步到位，发一个最简单的exportific前端工具"><a href="#一步到位，发一个最简单的exportific前端工具" class="headerlink" title="一步到位，发一个最简单的exportific前端工具"></a>一步到位，发一个最简单的exportific前端工具</h3><p>上面讲了那么多，仍然只体现在理论阶段。</p><p>但通过简单的改写，就能通过recast制作成一个名为exportific的源码编辑工具。</p><p>以下代码添加作了两个小改动</p><ul><li>添加说明书–help，以及添加了–rewrite模式，可以直接覆盖文件或默认为导出*.export.js文件。</li><li>将之前代码最后的 printSource(ast)替换成 writeASTFile(ast,filename,rewriteMode)</li></ul><p>exportific.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const {  identifier: id,  expressionStatement,  memberExpression,  assignmentExpression,  arrowFunctionExpression} = recast.types.buildersconst fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)// 截取参数const options = process.argv.slice(2)//如果没有参数，或提供了-h 或--help选项，则打印帮助if(options.length===0 || options.includes(&#39;-h&#39;) || options.includes(&#39;--help&#39;)){  console.log(`    采用commonjs规则，将.js文件内所有函数修改为导出形式。    选项： -r  或 --rewrite 可直接覆盖原有文件    `)  process.exit(0)}// 只要有-r 或--rewrite参数，则rewriteMode为truelet rewriteMode = options.includes(&#39;-r&#39;) || options.includes(&#39;--rewrite&#39;)// 获取文件名const clearFileArg = options.filter((item)=&gt;{  return ![&#39;-r&#39;,&#39;--rewrite&#39;,&#39;-h&#39;,&#39;--help&#39;].includes(item)})// 只处理一个文件let filename = clearFileArg[0]const writeASTFile = function(ast, filename, rewriteMode){  const newCode = recast.print(ast).code  if(!rewriteMode){    // 非覆盖模式下，将新文件写入*.export.js下    filename = filename.split(&#39;.&#39;).slice(0,-1).concat([&#39;export&#39;,&#39;js&#39;]).join(&#39;.&#39;)  }  // 将新代码写入文件  fs.writeFileSync(path.join(process.cwd(),filename),newCode)}recast.run(function (ast, printSource) {  let funcIds = []  recast.types.visit(ast, {    visitFunctionDeclaration(path) {      //获取遍历到的函数名、参数、块级域      const node = path.node      const funcName = node.id      const params = node.params      const body = node.body      funcIds.push(funcName.name)      const rep = expressionStatement(assignmentExpression(&#39;=&#39;, memberExpression(id(&#39;exports&#39;), funcName),        arrowFunctionExpression(params, body)))      path.replace(rep)      return false    }  })  recast.types.visit(ast, {    visitCallExpression(path){      const node = path.node;      if (funcIds.includes(node.callee.name)) {        node.callee = memberExpression(id(&#39;exports&#39;), node.callee)      }      return false    }  })  writeASTFile(ast,filename,rewriteMode)})</code></pre><p>现在尝试一下</p><pre><code>node exportific demo.js</code></pre><p>已经可以在当前目录下找到源码变更后的demo.export.js文件了。</p><h3 id="npm发包"><a href="#npm发包" class="headerlink" title="npm发包"></a>npm发包</h3><p>编辑一下package.json文件</p><pre><code class="json">{  &quot;name&quot;: &quot;exportific&quot;,  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;description&quot;: &quot;改写源码中的函数为可exports.XXX形式&quot;,  &quot;main&quot;: &quot;exportific.js&quot;,  &quot;bin&quot;: {    &quot;exportific&quot;: &quot;./exportific.js&quot;  },  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;wanthering&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: {    &quot;recast&quot;: &quot;^0.15.3&quot;  }}</code></pre><p>注意bin选项，它的意思是将全局命令<code>exportific</code>指向当前目录下的<code>exportific.js</code></p><p>这时，输入<code>npm link</code> 就在本地生成了一个<code>exportific</code>命令。</p><p>之后，只要哪个js文件想导出来使用，就<code>exportific XXX.js</code>一下。</p><p>这是在本地的玩法，想和大家一起分享这个前端小工具，只需要发布npm包就行了。</p><p>同时，一定要注意exportific.js文件头有</p><blockquote><p>#!/usr/bin/env node</p></blockquote><p>否则在使用时将报错。</p><h3 id="接下来，正式发布npm包！"><a href="#接下来，正式发布npm包！" class="headerlink" title="接下来，正式发布npm包！"></a>接下来，正式发布npm包！</h3><p>如果你已经有了npm 帐号，请使用<code>npm login</code>登录</p><p>如果你还没有npm帐号 <a href="https://www.npmjs.com/signup" target="_blank" rel="noopener">https://www.npmjs.com/signup</a> 非常简单就可以注册npm</p><p>然后，输入<br><code>npm publish</code></p><p>没有任何繁琐步骤，丝毫审核都没有，你就发布了一个实用的前端小工具exportific 。任何人都可以通过</p><p><code>npm i exportific -g</code></p><p>全局安装这一个插件。</p><blockquote><p>提示：==在试验教程时，请不要和我的包重名，修改一下发包名称。==</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们对javascript再熟悉不过，但透过AST的视角，最普通的js语句，却焕发出精心动魄的美感。你可以通过它批量构建任何javascript代码！</p><p>童年时，这个世界充满了新奇的玩具，再普通的东西在你眼中都如同至宝。如今，计算机语言就是你手中的大玩具，一段段AST对象的拆分组装，构建出我们所生活的网络世界。</p><p>所以不得不说软件工程师是一个幸福的工作，你心中住的仍然是那个午后的少年，永远有无数新奇等你发现，永远有无数梦想等你构建。</p><blockquote><p>作者：刘羽冲<br>链接：<a href="https://segmentfault.com/a/1190000016231512" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016231512</a><br>来源：SegmentFault 思否</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于AST的解析可以看看这个<a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">GitHub</a></p><p>一个可以直观导出AST的在线工具<a href="https://astexplorer.net/" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>高级</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试题总结——牛客网</title>
    <link href="undefined2020/07/interview2/"/>
    <url>2020/07/interview2/</url>
    
    <content type="html"><![CDATA[<h1 id="百度提前批面试一面"><a href="#百度提前批面试一面" class="headerlink" title="百度提前批面试一面"></a>百度提前批面试一面</h1><h2 id="如何清除浮动"><a href="#如何清除浮动" class="headerlink" title="如何清除浮动"></a>如何清除浮动</h2><p><a href="https://blog.csdn.net/xiaxiaoxian/article/details/85712035" target="_blank" rel="noopener">链接</a></p><p>给浮动元素的父元素添加高度</p><p>clear:both;</p><p>伪元素清除浮动</p><p>给父元素使用overflow:hidden;</p><p>br标签清浮动</p><h2 id="px、em、rem说一下？"><a href="#px、em、rem说一下？" class="headerlink" title="px、em、rem说一下？"></a>px、em、rem说一下？</h2><p>em：相对于父级的字体大小</p><p>rem: 相对于根节点的字体大小</p><p>浏览器默认字体大小16px</p><h2 id="如何实现一个元素水平、垂直居中"><a href="#如何实现一个元素水平、垂直居中" class="headerlink" title="如何实现一个元素水平、垂直居中"></a>如何实现一个元素水平、垂直居中</h2><p>position 然后改margin</p><p>position 然后<code>transform:translate(-50%,-50%);</code></p><p>position 上下左右定位0，然后<code>margin:auto;</code></p><p>flex</p><p>单行文字：height撑满text-align:center;</p><h2 id="CSS选择第一个元素、最后一个元素、3的整数倍子元素"><a href="#CSS选择第一个元素、最后一个元素、3的整数倍子元素" class="headerlink" title="CSS选择第一个元素、最后一个元素、3的整数倍子元素"></a>CSS选择第一个元素、最后一个元素、3的整数倍子元素</h2><p>伪类选择器<a href="https://www.cnblogs.com/yanggeng/p/11188285.html" target="_blank" rel="noopener">链接</a></p><table><thead><tr><th align="center">n</th><th align="center">2n+1</th><th align="center">4n+1</th><th align="center">4n+4</th><th align="center">4n</th><th align="center">5n-2</th><th align="center">-n+3</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">4</td><td align="center">-</td><td align="center">-</td><td align="center">3</td></tr><tr><td align="center">1</td><td align="center">3</td><td align="center">5</td><td align="center">8</td><td align="center">4</td><td align="center">3</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">5</td><td align="center">9</td><td align="center">12</td><td align="center">8</td><td align="center">8</td><td align="center">1</td></tr><tr><td align="center">3</td><td align="center">7</td><td align="center">13</td><td align="center">16</td><td align="center">12</td><td align="center">13</td><td align="center">-</td></tr><tr><td align="center">4</td><td align="center">9</td><td align="center">17</td><td align="center">20</td><td align="center">16</td><td align="center">18</td><td align="center">-</td></tr><tr><td align="center">5</td><td align="center">11</td><td align="center">21</td><td align="center">24</td><td align="center">20</td><td align="center">23</td><td align="center">-</td></tr></tbody></table><h2 id="说一下伪类和伪元素的区别"><a href="#说一下伪类和伪元素的区别" class="headerlink" title="说一下伪类和伪元素的区别"></a>说一下伪类和伪元素的区别</h2><p><a href="https://blog.csdn.net/guangtouhan/article/details/88074008?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">链接</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements" target="_blank" rel="noopener">官方文档</a></p><p>“伪元素”和“伪类”都带一个“伪”字，那是他们的共同点，所以，他们的区别就是一个本质上是元素，另一个本质上是类。</p><p>有没有创建一个文档树之外的元素</p><p>① 伪类是以1个冒号(:)作为前缀被添加到选择器末尾的关键字；伪元素是以2个冒号(::)作为前缀被添加到选择器末尾的关键字</p><p>② 如果伪类你用了2个冒号，不会报错，但也不会生效，比如 ::hover；但伪元素你用1个或2个冒号不会报错且有效，比如，:before，::before</p><h2 id="说一下原型和原型链"><a href="#说一下原型和原型链" class="headerlink" title="说一下原型和原型链"></a>说一下原型和原型链</h2><p><a href="https://www.cnblogs.com/Joe-and-Joan/p/10692844.html" target="_blank" rel="noopener">链接</a></p><p><img src="/img/interview2-proto.png" alt=""></p><h2 id="说一下闭包以及应用场景"><a href="#说一下闭包以及应用场景" class="headerlink" title="说一下闭包以及应用场景"></a>说一下闭包以及应用场景</h2><p><a href="https://www.cnblogs.com/star-studio/archive/2011/06/22/2086493.html" target="_blank" rel="noopener">链接</a></p><h2 id="说一下防抖和节流"><a href="#说一下防抖和节流" class="headerlink" title="说一下防抖和节流"></a>说一下防抖和节流</h2><p>防抖：就是将一段时间内连续的多次触发转化为一次触发</p><p>节流：减少一段时间内触发的频率</p><p><a href="https://blog.csdn.net/muge1161105403/article/details/106649675/" target="_blank" rel="noopener">链接</a></p><h2 id="说一下事件循环"><a href="#说一下事件循环" class="headerlink" title="说一下事件循环"></a>说一下事件循环</h2><p><a href="https://www.cnblogs.com/dong-xu/p/7000163.html" target="_blank" rel="noopener">链接</a></p><p><a href="https://blog.csdn.net/LuckyWinty/article/details/104765786/" target="_blank" rel="noopener">链接</a></p><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别?"></a>TCP和UDP的区别?</h2><p><a href="https://blog.csdn.net/qq_34624951/article/details/82669444" target="_blank" rel="noopener">链接</a></p><h3 id="为什么说UDP是不可靠的？"><a href="#为什么说UDP是不可靠的？" class="headerlink" title="为什么说UDP是不可靠的？"></a>为什么说UDP是不可靠的？</h3><h3 id="说一下TCP报文头部的结构"><a href="#说一下TCP报文头部的结构" class="headerlink" title="说一下TCP报文头部的结构"></a>说一下TCP报文头部的结构</h3><h2 id="说一下Promise的优缺点？"><a href="#说一下Promise的优缺点？" class="headerlink" title="说一下Promise的优缺点？"></a>说一下Promise的优缺点？</h2><p><strong>优点</strong>：解决回调地狱</p><p><strong>缺点：</strong></p><p>Promise无法取消，一旦新建就会立即执行</p><p>不设置回调函数，Promise内部抛出的错误无法反应到外部</p><p>当处于pending状态时，无法得知目前处于哪一阶段（刚刚开始还是即将完成） </p><h2 id="简单实现一下Promise"><a href="#简单实现一下Promise" class="headerlink" title="简单实现一下Promise"></a>简单实现一下Promise</h2><p><a href="https://www.jianshu.com/p/51c65b314704" target="_blank" rel="noopener">链接</a></p><h2 id="JS快速排序"><a href="#JS快速排序" class="headerlink" title="JS快速排序"></a>JS快速排序</h2><p><a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>题库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端基础面试题--灰蓝宇墨</title>
    <link href="undefined2020/07/interview1/"/>
    <url>2020/07/interview1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>写在前面：这是个基础的面试题，而且他的叙述也并不是很详细，建议一边看一边实验一边百度，或许在看这个文章之前你应该看一下<a href="/2020/04/js1">《你不知道的Javascript》</a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型：undefined、null、boolean、number、string、symbol</p><p>引用数据类型：object、array、function（统称为object）</p><h3 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h3><p><code>typeof</code>对于基本数据类型来说，除了<code>null</code>都可以显示正确的类型，<code>typeof</code>对于对象来说，除了函数都会显示<code>object</code></p><blockquote><p>注意：<code>console.log(typeof NaN)   //number</code></p></blockquote><p>instanceof通过原型链来判断数据类型的</p><pre><code class="js">p1 = new Person()p1 instanceof Person // true</code></pre><p><code>Object.prototype.toString.call()</code>可以检测所有的数据类型，算是一个比较完美的方法了</p><pre><code class="js">var obj={}var arr=[]var num = 1console.log(Object.prototype.toString.call(obj))    //[object Object]console.log(Object.prototype.toString.call(arr))    //[object Array]console.log(Object.prototype.toString.call(num))    //[object Number]</code></pre><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code class="js">Object.assign()    //es6的方法</code></pre><p>Object.assign会合并对象生成一个新对象。如果对象的属性是普通类型改变之后新对象不会改变，如果是引用类型改变后新对象也会改变，所以Object.assign实际上还是浅拷贝。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>JSON.parse(JSON.stringify(obj))</code></p><p>利用JSON.stringify(obj)将对象先转为json字符串，再JSON.parse(）转回为json对象可以实现深拷贝，这也是比较常用的一种方法</p><h4 id="用js实现一个深拷贝"><a href="#用js实现一个深拷贝" class="headerlink" title="用js实现一个深拷贝"></a>用js实现一个深拷贝</h4><p>其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝</p><pre><code class="js">function cloneDeep(source) {  if (!isObject(source)) return source; // 非对象返回自身  var target = Array.isArray(source) ? [] : {};  for (var key in source) {    if (source.hasOwnProperty(key)) {      if (isObject(source[key])) {        target[key] = cloneDeep(source[key]); // 注意这里      } else {        target[key] = source[key];      }    }  }  return target;}function isObject(obj) {  return typeof obj === &#39;object&#39; &amp;&amp; obj != null;}</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>在JS中，函数声明<code>function aa(){}</code>和变量声明<code>var</code>经常被隐式提升到当前作用域的顶部</p><blockquote><p>let 不会被提升，关于let的问题<a href="https://blog.csdn.net/jolab/article/details/82466362" target="_blank" rel="noopener">链接</a></p></blockquote><p>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</p><p>声明语句中的赋值部分并不会被提升，只有变量的名称被提升</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>因为函数的嵌套形成作用域的层级关系。当函数执行时，从当前作用域开始搜，没有找到的变量，会向上层作用域查找，直至全局函数，这就是作用域链。</p><p>在 JavaScript 中，作用域为 <code>function(){}</code>内的区域，称为函数作用域</p><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的原理就是作用域链，比函数F内部有一个函数G，函数G可以访问到函数F中的变量，那么函数G就是闭包</p><pre><code class="js">function F() {  let a = 1  window.G = function () {    console.log(a)  }}F()G() // 1</code></pre><h2 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h2><h3 id="js创建对象的几种方式"><a href="#js创建对象的几种方式" class="headerlink" title="js创建对象的几种方式"></a>js创建对象的几种方式</h3><p>对象字面量<code>var obj={};</code></p><p>new一个构造函数</p><pre><code class="js">function Pel(){}  p.name=&quot;hu&quot;;  p.age=&quot;25&quot;;  p.address=function(){}}var p=new Pel();</code></pre><p>new一个内置对象</p><pre><code class="js">var obj=new Object();</code></pre><p><code>Object.create()</code>创建对象</p><pre><code class="js">var test = Object.create({x:1});</code></pre><blockquote><p>关于以上几种方式创建的对象的区别，详见<a href="https://blog.csdn.net/sinat_27514587/article/details/102964631" target="_blank" rel="noopener">链接</a></p></blockquote><h3 id="JS-如何实现一个类"><a href="#JS-如何实现一个类" class="headerlink" title="JS 如何实现一个类"></a>JS 如何实现一个类</h3><p>构造函数法</p><p>缺点：用到了 this 和 prototype，编写复杂，可读性差</p><pre><code class="js">function P(name, age){  this.name = name;  this.age= age;}P.prototype.sal= function(){}var pel= new P(&quot;jj&quot;, 1);pel.sell()</code></pre><p>ES6 语法糖 class</p><pre><code class="js">class Point {  constructor(x, y) {    this.x = x;    this.y = y;  }  toString() {    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  }}var point = new Point(2, 3);</code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>一句话解析什么是原型链</p><blockquote><p>遍历一个实列的属性时，先遍历实列对象上的属性，再遍历它的原型对象，一直遍历到Object</p></blockquote><p>任何一个类（函数）都有原型对象，原型对象至少有两个属性(constructor,proto)。<code>constructor</code>指向函数本身，<code>proto</code>指向父类原型对象</p><p>函数上有一个prototype属性，指向原型对象，通过它可以访问原型对象</p><p>函数的实列可以直接访问原型对象(因为实列上有proto指向构造函数的原型对象)</p><blockquote><p>彻底弄懂JS原型与继承，详见<a href="https://mp.weixin.qq.com/s?__biz=MzI5MjU0Mjk5MA==&mid=2247483768&idx=1&sn=4579b7bd22420d18009505a5a7454a9d&chksm=ec7e8e19db09070f8d529cb6a3f9bb425c20ac3bd4d936f4eb9e918facbe3d7e6eecdd719c4c&token=816776520&lang=zh_CN#rd" target="_blank" rel="noopener">链接</a></p></blockquote><h2 id="new和this"><a href="#new和this" class="headerlink" title="new和this"></a>new和this</h2><h3 id="使用new的时候发生了什么"><a href="#使用new的时候发生了什么" class="headerlink" title="使用new的时候发生了什么"></a>使用new的时候发生了什么</h3><p>首先是创建实例对象{}</p><p>this 变量引用该对象，同时还继承了构造函数的原型</p><p>其次属性和方法被加入到 this 引用的对象中</p><p>并且新创建的对象由 this 所引用，最后隐式的返回 this</p><h4 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h4><pre><code class="js">function objectFactory() {  var obj = new Object(),//从Object.prototype上克隆一个对象  Constructor = [].shift.call(arguments);//取得外部传入的构造器  var F=function(){};  F.prototype= Constructor.prototype;  obj=new F();//指向正确的原型  var ret = Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性  return typeof ret === &#39;object&#39; ? ret : obj;//确保构造器总是返回一个对象};</code></pre><blockquote><p>这里说明对象的构造函数如果有返回值而且是基本类型是会被忽略掉的，引用类型的话则作为实例被返回，详见<a href="https://blog.csdn.net/liwenfei123/article/details/80580883" target="_blank" rel="noopener">链接</a></p></blockquote><h3 id="this对象的理解"><a href="#this对象的理解" class="headerlink" title="this对象的理解"></a>this对象的理解</h3><p><code>this</code>总是指向函数的直接调用者</p><p>如果有 <code>new</code> 关键字，<code>this</code> 指向 <code>new</code> 出来的实例对象</p><p>在事件中，<code>this</code> 指向触发这个事件的对象</p><p>IE 下 <code>attachEvent</code> 中的 <code>this</code> 总是指向全局对象 <code>Window</code></p><p>箭头函数中，函数体内的this对象，就是定义时所在作用域的对象，而不是使用时所在的作用域的对象</p><pre><code class="js">function foo() {  console.log(this.a)}var a = 1foo()           //1       ​const obj = {  a: 2,  foo: foo}obj.foo()      //2​const c = new foo()   //undefined</code></pre><p>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是<code>window</code></p><p>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</p><p>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>new</code>出来的对象上，不会被任何方式改变 <code>this</code></p><p>箭头函数其实是没有<code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code>这类函数是无效的</p><h2 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h2><p><code>call</code>、<code>apply</code>和<code>bind</code>是Function对象自带的三个方法，都是为了改变函数体内部 <code>this</code> 的指向。</p><p><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；</p><p><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都可以利用后续参数传参；</p><p><code>bind</code> 是返回对应 函数，便于稍后调用；<code>apply</code> 、<code>call</code> 则是立即调用 </p><p>call 传入参数列表</p><p>apply 传入数组</p><p>bind() 方法会创建一个 新函数，当调用这个新函数时，新函数会以创建它时传入 bind() 方法的第一个参数 作为 this，传入 bind() 方法的 第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><pre><code class="js">var arr=[&#39;12&#39;,&#39;32&#39;,&#39;89&#39;,&#39;12&#39;,&#39;12&#39;,&#39;78&#39;,&#39;12&#39;,&#39;32&#39;];// 最简单数组去重法function unique1(array){    var n = []; //一个新的临时数组    for(var i = 0; i &lt; array.length; i++){ //遍历当前数组        if (n.indexOf(array[i]) == -1)            n.push(array[i]);    }    return n;}arr=unique1(arr);</code></pre><blockquote><p>这个太简单了，个人建议使用Set进行去重</p></blockquote><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code class="js">/**     * 按 sort 及  id 排序     * @param {Object} a     * @param {Object} b     */function   sortFun(a, b) {  return a.sort - b.sort == 0 ? a.id - b.id : a.sort - b.sort};arr.sort(sortFun)   //从小到大排序</code></pre><h3 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h3><pre><code class="js">function add(num1,num2){  var num = num1+num2;  if(num2+1&gt;100){    return num;  }else{    return add(num,num2+1)  }}var sum =add(1,2)</code></pre><h3 id="计算数组各项的重复次数"><a href="#计算数组各项的重复次数" class="headerlink" title="计算数组各项的重复次数"></a>计算数组各项的重复次数</h3><pre><code class="js">var arr=[&#39;胡将&#39;,&#39;胡将&#39;,&#39;hujiang&#39;,&#39;胡将&#39;,&#39;胡江&#39;,&#39;hujiang&#39;];var obj={};arr.sort();    //先排序for(var i=0;i&lt;arr.length;){    var con=0;    for(var j=i;j&lt;arr.length;j++){        if(arr[i]===arr[j]){            con++        }    }    obj[arr[i]]=con;     i=i+con;    //跳过重复的值}console.log(obj);  //{ hujiang: 2, &#39;胡将&#39;: 3, &#39;胡江&#39;: 1 }</code></pre><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务/微任务"></a>宏任务/微任务</h3><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><p>macro-task(宏任务)：当前调用栈中执行的任务称为宏任务。包括：script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</p><p>micro-task(微任务)： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。包括：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p><p>不同类型的任务会进入对应的Event Queue，宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</p><blockquote><p>这个东西没给例子，可能很难理解，我之前看的这个<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">链接</a></p></blockquote><h3 id="一句话解析下什么是event-loop"><a href="#一句话解析下什么是event-loop" class="headerlink" title="一句话解析下什么是event loop"></a>一句话解析下什么是event loop</h3><p>主线程运行的时候会生成堆（heap）和栈（stack）</p><p>js 从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中</p><p>当程序调用外部的 API 时（比如 ajax、setTimeout 等），会将此类异步任务挂起，继续执行执行栈中的任务。等异步任务返回结果后，再按照顺序排列到事件队列中</p><p>主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中</p><p>主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个循环往复的过程被称为“Event Loop 事件循环”</p><h2 id="浏览器页面渲染过程"><a href="#浏览器页面渲染过程" class="headerlink" title="浏览器页面渲染过程"></a>浏览器页面渲染过程</h2><p>浏览器渲染页面的一般过程：</p><ol><li><p>浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。</p></li><li><p>浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p></li><li><p>DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</p><p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p></li><li><p>一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p></li></ol><p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>原作者给的详情<a href="https://mp.weixin.qq.com/s?__biz=MzI5MjU0Mjk5MA==&mid=2247483826&idx=2&sn=e38f5e5b928a6aa5c15371505b4e8d71&chksm=ec7e8ed3db0907c545393ea90ee8bfd7dc944ff013957228b200d66929767251b1982340d036&token=816776520&lang=zh_CN#rd" target="_blank" rel="noopener">链接</a></p><p>我之前看到的另外一篇比较好的文章<a href="https://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">链接</a></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型的组成，由里向外content,padding,border,margin.</p><p><strong>在IE盒子模型中，width表示content+padding+border这三个部分的宽度</strong></p><p><strong>在标准的盒子模型中，width指content部分的宽度</strong></p><p><code>box-sizing</code>的使用</p><pre><code class="css">box-sizing: content-box; //是W3C盒子模型box-sizing: border-box; //是IE盒子模型</code></pre><p><code>box-sizing</code>的默认属性是<code>content-box</code></p><h2 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>行内元素: <code>text-align: center</code></p><p>块级元素:</p><pre><code class="css">// 方法1 margin: 0 auto;// 方法2position:absolute;left:50%;transform:translateX(-50%);// 方法3display:flex;justify-content: center;</code></pre><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>设置line-height 等于height</p><pre><code class="css">// 方法一position：absolute;top:50%;transform:translateY(-50%);// 方法二display:flex;align-items: center;// 方法三display:table;display:table-cell;vertical-align: middle;</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>一边百度一边看，回想起来不少知识，但是这个还是相对基础的部分，之后再找点难一些的，当然，基础不稳地动山摇，还是要好好复习基础的</p><p>祝各位找到合适自己的公司！奥里给！</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>题库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Curriculum Vitae</title>
    <link href="undefined2020/07/cv/"/>
    <url>2020/07/cv/</url>
    
    <content type="html"><![CDATA[<h1 id="赵英博"><a href="#赵英博" class="headerlink" title="赵英博"></a>赵英博</h1><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>电话：15143211127<br>邮箱：<a href="mailto:zhaoyingbo@live.cn">zhaoyingbo@live.cn</a><br>地址：长春<br>个人网站：<a href="https://lacus.site">https://lacus.site</a><br>微信：15143211127<br>求职意向：web前端开发</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="Toast题库（2020-06-18-至今）"><a href="#Toast题库（2020-06-18-至今）" class="headerlink" title="Toast题库（2020.06.18-至今）"></a>Toast题库（2020.06.18-至今）</h3><ul><li><p>项目描述：使用Vue开发，实现背题，题目检索，背题进度保存，用户反馈等功能</p></li><li><p>项目职责：</p><ol><li><p>负责页面UI布局，不使用第三方UI库，自行封装组件，实现主题切换，使用rem对各种机型进行适配</p></li><li><p>使用DFA算法实现题目检索</p></li><li><p>使用LocalStorage存储用户背题进度</p></li><li><p>使用PWA加速开屏速度以及实现本地化</p></li><li><p>使用Docker，CDN等技术进行部署</p></li></ol></li><li><p>项目业绩：从设计到部署，独立完成整个项目第一版并上线，共用时三天，运行过程中无bug，抢在考试前一周发布，获得大量用户好评</p></li><li><p>项目地址：<a href="https://tiku.lacus.site/" target="_blank" rel="noopener">https://tiku.lacus.site/</a></p></li></ul><h3 id="Cherry课表成绩查询（2020-02-09-至今）"><a href="#Cherry课表成绩查询（2020-02-09-至今）" class="headerlink" title="Cherry课表成绩查询（2020.02.09-至今）"></a>Cherry课表成绩查询（2020.02.09-至今）</h3><ul><li><p>项目描述：使用Python爬取教务系统课表以及成绩信息，并使用前端进行展示</p></li><li><p>项目职责：</p><ol><li><p>整体的项目规划，分工协调</p></li><li><p>负责页面UI布局，少量使用ElementUI</p></li><li><p>处理后端发来的课表以及成绩信息，保存在LocalStorage中，处理数据实现自定义课表功能并防止与源课表冲突</p></li><li><p>使用Python+Flask进行后端开发，对模块编写单元测试</p></li><li><p>使用swagger进行后端文档编写</p></li></ol></li><li><p>项目业绩：带领三人小组一周内完成第一版并上线，后期还添加了小游戏等功能，目前日均PV3.5k、UV1.5k</p></li><li><p>项目地址：<a href="https://cherry.lacus.site/" target="_blank" rel="noopener">https://cherry.lacus.site/</a></p></li></ul><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><h3 id="长春理工大学"><a href="#长春理工大学" class="headerlink" title="长春理工大学"></a>长春理工大学</h3><p>长春 | 软件工程 | 本科 | 计算机科学技术</p><p>2017.09 - 2021.06</p><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><p>熟悉JavaScript，了解TypeScript，掌握ES6以上常用语法</p><p>熟练使用Vue.js框架开发项目</p><p>熟悉Node.js，使用过Serverless开发项目</p><p>熟悉小程序开发，曾独立开发过两个项目，其中一个累计用户11.1k</p><p>熟悉Python，曾使用Flask框架开发过3个项目的后端</p><p>掌握MongoDB以及MySQl的使用与操作</p><p>熟练使用git、svn版本管理器</p><p>了解Sass、Stylus 等 CSS预处理器</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>自学能力强，能快速接受使用新知识</p><p>良好的分析解决问题能力，和自我管理能力</p><p>具有面向对象设计思想，具备独立分析和解决问题的能力</p><p>有较好的团队协作和沟通能力，有强烈的责任心</p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p>中文简历：<a href="http://assets.lacus.site/cv/%E8%B5%B5%E8%8B%B1%E5%8D%9A_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91_15143211127.pdf" target="_blank" rel="noopener">链接</a></p><p>英文简历：<a href="http://assets.lacus.site/cv/%E8%B5%B5%E8%8B%B1%E5%8D%9A_webFrontend_15143211127.pdf" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>文件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--收尾</title>
    <link href="undefined2020/07/js-api-others/"/>
    <url>2020/07/js-api-others/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><p>将字符串转化为JSON</p><pre><code class="js">const json = &#39;{&quot;result&quot;:true, &quot;count&quot;:42}&#39;;const obj = JSON.parse(json);console.log(obj.count);// expected output: 42console.log(obj.result);// expected output: true</code></pre><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p>将JSON转化为字符串</p><pre><code class="js">console.log(JSON.stringify({ x: 5, y: 6 }));// expected output: &quot;{&quot;x&quot;:5,&quot;y&quot;:6}&quot;console.log(JSON.stringify([new Number(3), new String(&#39;false&#39;), new Boolean(false)]));// expected output: &quot;[3,&quot;false&quot;,false]&quot;console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol(&#39;&#39;)] }));// expected output: &quot;{&quot;x&quot;:[10,null,null,null]}&quot;console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));// expected output: &quot;&quot;2006-01-02T15:04:05.000Z&quot;&quot;</code></pre><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>处理时间的函数，平时就用个时间戳<code>new Date().getTime()</code>剩下得几乎用不到，<a href="https://devdocs.io/javascript/global_objects/date" target="_blank" rel="noopener">文档链接</a></p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>数学用函数，只整理常用的，其余看文档，<a href="https://devdocs.io/javascript/global_objects/math" target="_blank" rel="noopener">文档链接</a></p><h3 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs"></a>Math.abs</h3><p>取绝对值</p><pre><code class="js">function difference(a, b) {  return Math.abs(a - b);}console.log(difference(3, 5));// expected output: 2console.log(difference(5, 3));// expected output: 2console.log(difference(1.23456, 7.89012));// expected output: 6.6555599999999995</code></pre><h3 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil"></a>Math.ceil</h3><p>返回大于等于给定量的最小整数</p><pre><code class="js">console.log(Math.ceil(.95));// expected output: 1console.log(Math.ceil(4));// expected output: 4console.log(Math.ceil(7.004));// expected output: 8console.log(Math.ceil(-7.004));// expected output: -7</code></pre><h3 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor"></a>Math.floor</h3><p>返回小于给定量的最大整数</p><pre><code class="js">console.log(Math.floor(5.95));// expected output: 5console.log(Math.floor(5.05));// expected output: 5console.log(Math.floor(5));// expected output: 5console.log(Math.floor(-5.05));// expected output: -6</code></pre><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><p>返回给定值最大的一个</p><pre><code class="js">console.log(Math.max(1, 3, 2));// expected output: 3console.log(Math.max(-1, -3, -2));// expected output: -1const array1 = [1, 3, 2];console.log(Math.max(...array1));// expected output: 3</code></pre><h3 id="Math-min"><a href="#Math-min" class="headerlink" title="Math.min"></a>Math.min</h3><p>返回给定值最小的那个</p><pre><code class="js">console.log(Math.min(2, 3, 1));// expected output: 1console.log(Math.min(-2, -3, -1));// expected output: -3const array1 = [2, 3, 1];console.log(Math.min(...array1));// expected output: 1</code></pre><h3 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow"></a>Math.pow</h3><p>返回给定的量指定次数的幂</p><pre><code class="js">console.log(Math.pow(7, 3));// expected output: 343console.log(Math.pow(4, 0.5));// expected output: 2console.log(Math.pow(7, -2));// expected output: 0.02040816326530612//                  (1/49)console.log(Math.pow(-7, 0.5));// expected output: NaN</code></pre><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random"></a>Math.random</h3><p>返回一个<code>[0,1)</code>之间随机的数</p><pre><code class="js">function getRandomInt(max) {  return Math.floor(Math.random() * Math.floor(max));}console.log(getRandomInt(3));// expected output: 0, 1 or 2console.log(getRandomInt(1));// expected output: 0console.log(Math.random());// expected output: a number between 0 and 1</code></pre><h3 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round"></a>Math.round</h3><p>返回给定数的舍入后的整数</p><pre><code class="js">console.log(Math.round(0.9));// expected output: 1console.log(Math.round(5.95), Math.round(5.5), Math.round(5.05));// expected output: 6 6 5console.log(Math.round(-5.05), Math.round(-5.5), Math.round(-5.95));// expected output: -5 -5 -6</code></pre><h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign"></a>Math.sign</h3><p>返回给定数的符号，正1负-1零0</p><pre><code class="js">console.log(Math.sign(3));// expected output: 1console.log(Math.sign(-3));// expected output: -1console.log(Math.sign(0));// expected output: 0console.log(Math.sign(&#39;-3&#39;));// expected output: -1</code></pre><h3 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt"></a>Math.sqrt</h3><p>返回给定数的平方根</p><pre><code class="js">function calcHypotenuse(a, b) {  return (Math.sqrt((a * a) + (b * b)));}console.log(calcHypotenuse(3, 4));// expected output: 5console.log(calcHypotenuse(5, 12));// expected output: 13console.log(calcHypotenuse(0, 0));// expected output: 0</code></pre><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>数字类型，<a href="https://devdocs.io/javascript/global_objects/number" target="_blank" rel="noopener">文档链接</a></p><h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger"></a>Number.isInteger</h3><p>判定给定值是否是整数</p><pre><code class="js">function fits(x, y) {  if (Number.isInteger(y / x)) {    return &#39;Fits!&#39;;  }  return &#39;Does NOT fit!&#39;;}console.log(fits(5, 10));// expected output: &quot;Fits!&quot;console.log(fits(5, 11));// expected output: &quot;Does NOT fit!&quot;</code></pre><h3 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite"></a>Number.isFinite</h3><p>判定给定值是否是有限数</p><pre><code class="js">console.log(Number.isFinite(1 / 0));// expected output: falseconsole.log(Number.isFinite(10 / 5));// expected output: trueconsole.log(Number.isFinite(0 / 0));// expected output: false</code></pre><h3 id="number-toPrecision"><a href="#number-toPrecision" class="headerlink" title="number.toPrecision"></a>number.toPrecision</h3><p>方法返回表示Number对象到指定的精度的字符串</p><pre><code class="js">function precise(x) {  return Number.parseFloat(x).toPrecision(4);}console.log(precise(123.456));// expected output: &quot;123.5&quot;console.log(precise(0.004));// expected output: &quot;0.004000&quot;console.log(precise(&#39;1.23e+5&#39;));// expected output: &quot;1.230e+5&quot;</code></pre><h3 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h3><p>js中最大正整数</p><h3 id="Number-MAX-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER</h3><p>js最大安全整数</p><h3 id="Number-MIN-SAFE-INTEGER"><a href="#Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MIN_SAFE_INTEGER"></a>Number.MIN_SAFE_INTEGER</h3><p>js最小安全整数</p><h3 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h3><p>js最小正整数值</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>是ES6新增的，相较于对象就是属性名可以为任意值</p><h3 id="map-iterator"><a href="#map-iterator" class="headerlink" title="map.@@iterator"></a>map.@@iterator</h3><p>很明显，map是可以迭代的</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1[Symbol.iterator]();for (let item of iterator1) {  console.log(item);}// expected output: Array [&quot;0&quot;, &quot;foo&quot;]// expected output: Array [1, &quot;bar&quot;]</code></pre><h3 id="map-clear"><a href="#map-clear" class="headerlink" title="map.clear"></a>map.clear</h3><p>清空map</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;baz&#39;);map1.set(1, &#39;foo&#39;);console.log(map1.size);// expected output: 2map1.clear();console.log(map1.size);// expected output: 0</code></pre><h3 id="map-delete"><a href="#map-delete" class="headerlink" title="map.delete"></a>map.delete</h3><p>移出map中的某个元素</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.delete(&#39;bar&#39;));// expected result: true// (true indicates successful removal)console.log(map1.has(&#39;bar&#39;));// expected result: false</code></pre><h3 id="map-entries"><a href="#map-entries" class="headerlink" title="map.entries"></a>map.entries</h3><p>返回一个可迭代的对象，每次返回键值对的数组</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1.entries();console.log(iterator1.next().value);// expected output: [&quot;0&quot;, &quot;foo&quot;]console.log(iterator1.next().value);// expected output: [1, &quot;bar&quot;]</code></pre><h3 id="map-forEach"><a href="#map-forEach" class="headerlink" title="map.forEach"></a>map.forEach</h3><p>对每个键值对都执行一次某个操作</p><pre><code class="js">function logMapElements(value, key, map) {  console.log(`m[${key}] = ${value}`);}new Map([[&#39;foo&#39;, 3], [&#39;bar&#39;, {}], [&#39;baz&#39;, undefined]])  .forEach(logMapElements);// expected output: &quot;m[foo] = 3&quot;// expected output: &quot;m[bar] = [object Object]&quot;// expected output: &quot;m[baz] = undefined&quot;</code></pre><h3 id="map-get"><a href="#map-get" class="headerlink" title="map.get"></a>map.get</h3><p>获取map的某个键对应的值，没有返回undefined</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.get(&#39;bar&#39;));// expected output: &quot;foo&quot;console.log(map1.get(&#39;baz&#39;));// expected output: undefined</code></pre><h3 id="map-has"><a href="#map-has" class="headerlink" title="map.has"></a>map.has</h3><p>查询某个键是否存在</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.has(&#39;bar&#39;));// expected output: trueconsole.log(map1.has(&#39;baz&#39;));// expected output: false</code></pre><h3 id="map-keys"><a href="#map-keys" class="headerlink" title="map.keys"></a>map.keys</h3><p>返回一个可迭代的对象，值是map的键</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1.keys();console.log(iterator1.next().value);// expected output: &quot;0&quot;console.log(iterator1.next().value);// expected output: 1</code></pre><h3 id="map-set"><a href="#map-set" class="headerlink" title="map.set"></a>map.set</h3><p>设置一个键值对到map里边</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.get(&#39;bar&#39;));// expected output: &quot;foo&quot;console.log(map1.get(&#39;baz&#39;));// expected output: undefined</code></pre><h3 id="map-size"><a href="#map-size" class="headerlink" title="map.size"></a>map.size</h3><p>返回map的大小，也就是多少个元素</p><pre><code class="js">const map1 = new Map();map1.set(&#39;a&#39;, &#39;alpha&#39;);map1.set(&#39;b&#39;, &#39;beta&#39;);map1.set(&#39;g&#39;, &#39;gamma&#39;);console.log(map1.size);// expected output: 3</code></pre><h3 id="map-values"><a href="#map-values" class="headerlink" title="map.values"></a>map.values</h3><p>返回一个可迭代对象，值是map的值</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1.values();console.log(iterator1.next().value);// expected output: &quot;foo&quot;console.log(iterator1.next().value);// expected output: &quot;bar&quot;</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>和Map的api是一样的，不过不允许存在重复的值，所以可以用来进行数组去重，<a href="https://devdocs.io/javascript/global_objects/set" target="_blank" rel="noopener">文档链接</a></p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--Object</title>
    <link href="undefined2020/07/js-api-object/"/>
    <url>2020/07/js-api-object/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>将一个或者多个对象的可枚举属性拷贝到源对象上，会改变源对象，如果<code>key</code>相同后边会覆盖前边的</p><pre><code class="js">const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source);console.log(target);// expected output: Object { a: 1, b: 4, c: 5 }console.log(returnedTarget);// expected output: Object { a: 1, b: 4, c: 5 }</code></pre><h3 id="object-constructor"><a href="#object-constructor" class="headerlink" title="object.constructor"></a>object.constructor</h3><p>返回构造函数本身</p><pre><code class="js">var o = {};o.constructor === Object; // truevar o = new Object;o.constructor === Object; // truevar a = [];a.constructor === Array; // truevar a = new Array;a.constructor === Array; // truevar n = new Number(3);n.constructor === Number; // true</code></pre><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p>创建一个新对象，传入的参数就是新对象的原型</p><pre><code class="js">const person = {  isHuman: false,  printIntroduction: function() {    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);  }};const me = Object.create(person);me.name = &#39;Matthew&#39;; // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;me.isHuman = true; // inherited properties can be overwrittenme.printIntroduction();// expected output: &quot;My name is Matthew. Am I human? true&quot;</code></pre><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h3><p>方法直接在对象上定义了新的或修改现有的属性，并返回该对象</p><pre><code class="js">const object1 = {};Object.defineProperties(object1, {  property1: {    value: 42,    writable: true  },  property2: {}});console.log(object1.property1);// expected output: 42</code></pre><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>方法直接在对象上定义了新的或修改现有的属性，并返回该对象</p><pre><code class="js">const object1 = {};Object.defineProperty(object1, &#39;property1&#39;, {  value: 42,  writable: false});object1.property1 = 77;// throws an error in strict modeconsole.log(object1.property1);// expected output: 42</code></pre><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h3><p>可以获取对象的一个可迭代属性，value是一个数组<code>[key,val]</code>，但是是没有顺序的，如果需要顺序可以使用<code>Object.entries(obj).sort((a, b) =&gt; a[0] - b[0]);</code></p><pre><code class="js">const object1 = {  a: &#39;somestring&#39;,  b: 42};for (const [key, value] of Object.entries(object1)) {  console.log(`${key}: ${value}`);}// expected output:// &quot;a: somestring&quot;// &quot;b: 42&quot;// order is not guaranteed</code></pre><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h3><p>冻结一个对象，不能添加删除或者修改，当然对象里边的对象的内容仍可被修改</p><pre><code class="js">const obj = {  prop: 42};Object.freeze(obj);obj.prop = 33;// Throws an error in strict modeconsole.log(obj.prop);// expected output: 42</code></pre><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h3><p>用于将键值对数组转化为对象，本质上是调用的数组的迭代器</p><pre><code class="js">const entries = new Map([  [&#39;foo&#39;, &#39;bar&#39;],  [&#39;baz&#39;, 42]]);const obj = Object.fromEntries(entries);console.log(obj);// expected output: Object { foo: &quot;bar&quot;, baz: 42 }</code></pre><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p>获取对象中某一个属性的信息，是否可写，<code>getter,setter</code>之类的</p><pre><code class="js">const object1 = {  property1: 42};const descriptor1 = Object.getOwnPropertyDescriptor(object1, &#39;property1&#39;);console.log(descriptor1.configurable);// expected output: trueconsole.log(descriptor1.value);// expected output: 42</code></pre><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>获取对象中所有属性的信息，就是上一个的集合</p><pre><code class="js">const object1 = {  property1: 42};const descriptors1 = Object.getOwnPropertyDescriptors(object1);console.log(descriptors1.property1.writable);// expected output: trueconsole.log(descriptors1.property1.value);// expected output: 42</code></pre><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h3><p>获取全部属性名，包含不可枚举属性</p><pre><code class="js">const object1 = {  a: 1,  b: 2,  c: 3};console.log(Object.getOwnPropertyNames(object1));// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]var my_obj = Object.create({}, {  getFoo: {    value: function() { return this.foo; },    enumerable: false  }});my_obj.foo = 1;console.log(Object.getOwnPropertyNames(my_obj).sort()); // logs [&quot;foo&quot;, &quot;getFoo&quot;]</code></pre><h3 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h3><p>获取对象中全部符号属性</p><pre><code class="js">const object1 = {};const a = Symbol(&#39;a&#39;);const b = Symbol.for(&#39;b&#39;);object1[a] = &#39;localSymbol&#39;;object1[b] = &#39;globalSymbol&#39;;const objectSymbols = Object.getOwnPropertySymbols(object1);console.log(objectSymbols);// expected output: Array [Symbol(a), Symbol(b)]</code></pre><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf"></a>Object.getPrototypeOf</h3><p>获取对象的原型对象</p><pre><code class="js">const prototype1 = {};const object1 = Object.create(prototype1);console.log(Object.getPrototypeOf(object1) === prototype1);// expected output: true</code></pre><h3 id="object-hasOwnProperty"><a href="#object-hasOwnProperty" class="headerlink" title="object.hasOwnProperty"></a>object.hasOwnProperty</h3><p>判断一个对象是否有该属性，而不是继承来的</p><pre><code class="js">const object1 = {};object1.property1 = 42;console.log(object1.hasOwnProperty(&#39;property1&#39;));// expected output: trueconsole.log(object1.hasOwnProperty(&#39;toString&#39;));// expected output: falseconsole.log(object1.hasOwnProperty(&#39;hasOwnProperty&#39;));// expected output: false</code></pre><blockquote><p>这个函数能被直接覆写，遇到这种情况使用<code>Object.hasOwnProperty.call()</code></p></blockquote><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h3><p>用于判定两个值是否相同，不限于对象</p><pre><code class="js">Object.is(&#39;foo&#39;, &#39;foo&#39;);     // trueObject.is(window, window);   // trueObject.is(&#39;foo&#39;, &#39;bar&#39;);     // falseObject.is([], []);           // falsevar test = { a: 1 };Object.is(test, test);       // trueObject.is(null, null);       // true// Special CasesObject.is(0, -0);            // falseObject.is(-0, -0);           // trueObject.is(NaN, 0/0);         // true</code></pre><h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible"></a>Object.isExtensible</h3><p>用来判断一个对象是否是可拓展的</p><pre><code class="js">const object1 = {};console.log(Object.isExtensible(object1));// expected output: trueObject.preventExtensions(object1);console.log(Object.isExtensible(object1));// expected output: false</code></pre><h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen"></a>Object.isFrozen</h3><p>用于确认对象是否被冻结</p><pre><code class="js">const object1 = {  property1: 42};console.log(Object.isFrozen(object1));// expected output: falseObject.freeze(object1);console.log(Object.isFrozen(object1));// expected output: true</code></pre><h3 id="object-isPrototypeOf"><a href="#object-isPrototypeOf" class="headerlink" title="object.isPrototypeOf"></a>object.isPrototypeOf</h3><p>用于判定对象是否在另一个对象的原型链中</p><pre><code class="js">function Foo() {}function Bar() {}function Baz() {}Bar.prototype = Object.create(Foo.prototype);Baz.prototype = Object.create(Bar.prototype);var baz = new Baz();console.log(Baz.prototype.isPrototypeOf(baz)); // trueconsole.log(Bar.prototype.isPrototypeOf(baz)); // trueconsole.log(Foo.prototype.isPrototypeOf(baz)); // trueconsole.log(Object.prototype.isPrototypeOf(baz)); // true</code></pre><h3 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed"></a>Object.isSealed</h3><p>用来判断对象是否被<strong>密封</strong>，如果对象设置为不可拓展或者设置<code>configurable: false</code>会返回<code>true</code></p><pre><code class="js">// Objects aren&#39;t sealed by default.var empty = {};Object.isSealed(empty); // === false// If you make an empty object non-extensible,// it is vacuously sealed.Object.preventExtensions(empty);Object.isSealed(empty); // === true// The same is not true of a non-empty object,// unless its properties are all non-configurable.var hasProp = { fee: &#39;fie foe fum&#39; };Object.preventExtensions(hasProp);Object.isSealed(hasProp); // === false// But make them all non-configurable// and the object becomes sealed.Object.defineProperty(hasProp, &#39;fee&#39;, {  configurable: false});Object.isSealed(hasProp); // === true// The easiest way to seal an object, of course,// is Object.seal.var sealed = {};Object.seal(sealed);Object.isSealed(sealed); // === true// A sealed object is, by definition, non-extensible.Object.isExtensible(sealed); // === false// A sealed object might be frozen,// but it doesn&#39;t have to be.Object.isFrozen(sealed); // === true // (all properties also non-writable)var s2 = Object.seal({ p: 3 });Object.isFrozen(s2); // === false // (&#39;p&#39; is still writable)var s3 = Object.seal({ get p() { return 0; } });Object.isFrozen(s3); // === true// (only configurability matters for accessor properties)</code></pre><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h3><p>获取对象的键，只有可枚举属性</p><pre><code class="js">// simple arrayvar arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];console.log(Object.keys(arr)); // console: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]// array like objectvar obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; };console.log(Object.keys(obj)); // console: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]// array like object with random key orderingvar anObj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; };console.log(Object.keys(anObj)); // console: [&#39;2&#39;, &#39;7&#39;, &#39;100&#39;]// getFoo is a property which isn&#39;t enumerablevar myObj = Object.create({}, {  getFoo: {    value: function () { return this.foo; }  } });myObj.foo = 1;console.log(Object.keys(myObj)); // console: [&#39;foo&#39;]</code></pre><h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions"></a>Object.preventExtensions</h3><p>禁止对象进行拓展</p><pre><code class="js">// Object.preventExtensions returns the object// being made non-extensible.var obj = {};var obj2 = Object.preventExtensions(obj);obj === obj2; // true// Objects are extensible by default.var empty = {};Object.isExtensible(empty); // === true// ...but that can be changed.Object.preventExtensions(empty);Object.isExtensible(empty); // === false// Object.defineProperty throws when adding// a new property to a non-extensible object.var nonExtensible = { removable: true };Object.preventExtensions(nonExtensible);Object.defineProperty(nonExtensible, &#39;new&#39;, {  value: 8675309}); // throws a TypeError// In strict mode, attempting to add new properties// to a non-extensible object throws a TypeError.function fail() {  &#39;use strict&#39;;  // throws a TypeError  nonExtensible.newProperty = &#39;FAIL&#39;;}fail();</code></pre><h3 id="object-propertyIsEnumerable"><a href="#object-propertyIsEnumerable" class="headerlink" title="object.propertyIsEnumerable"></a>object.propertyIsEnumerable</h3><p>用于判定指定的属性是否可枚举</p><pre><code class="js">const object1 = {};const array1 = [];object1.property1 = 42;array1[0] = 42;console.log(object1.propertyIsEnumerable(&#39;property1&#39;));// expected output: trueconsole.log(array1.propertyIsEnumerable(0));// expected output: trueconsole.log(array1.propertyIsEnumerable(&#39;length&#39;));// expected output: false</code></pre><h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal"></a>Object.seal</h3><p>密封一个对象，密封之前的对象允许修改值，密封之后不允许删除属性，新增的属性不允许修改值</p><pre><code class="js">var obj = {  prop: function() {},  foo: &#39;bar&#39;};// New properties may be added, existing properties// may be changed or removed.obj.foo = &#39;baz&#39;;obj.lumpy = &#39;woof&#39;;delete obj.prop;var o = Object.seal(obj);o === obj; // trueObject.isSealed(obj); // === true// Changing property values on a sealed object// still works.obj.foo = &#39;quux&#39;;// But you can&#39;t convert data properties to accessors,// or vice versa.Object.defineProperty(obj, &#39;foo&#39;, {  get: function() { return &#39;g&#39;; }}); // throws a TypeError// Now any changes, other than to property values,// will fail.obj.quaxxor = &#39;the friendly duck&#39;;// silently doesn&#39;t add the propertydelete obj.foo;// silently doesn&#39;t delete the property// ...and in strict mode such attempts// will throw TypeErrors.function fail() {  &#39;use strict&#39;;  delete obj.foo; // throws a TypeError  obj.sparky = &#39;arf&#39;; // throws a TypeError}fail();// Attempted additions through// Object.defineProperty will also throw.Object.defineProperty(obj, &#39;ohai&#39;, {  value: 17}); // throws a TypeErrorObject.defineProperty(obj, &#39;foo&#39;, {  value: &#39;eit&#39;}); // changes existing property value</code></pre><h3 id="object-toString"><a href="#object-toString" class="headerlink" title="object.toString"></a>object.toString</h3><p>将对象字符串化，正常返回<code>[Object Object]</code>，可以使用<code>Symbol.toStringTag 与 Symbol.hasInstance</code>改变第二个tag，详见你不知道的js下</p><pre><code class="js">function Dog(name) {  this.name = name;}const dog1 = new Dog(&#39;Gabby&#39;);Dog.prototype.toString = function dogToString() {  return `${this.name}`;};console.log(dog1.toString());// expected output: &quot;Gabby&quot;</code></pre><h3 id="object-valueOf"><a href="#object-valueOf" class="headerlink" title="object.valueOf"></a>object.valueOf</h3><p>方法返回指定对象的原始值</p><pre><code class="js">function MyNumberType(n) {  this.number = n;}MyNumberType.prototype.valueOf = function() {  return this.number;};const object1 = new MyNumberType(4);console.log(object1 + 3);// expected output: 7</code></pre><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values"></a>Object.values</h3><p>返回对象的可枚举的属性值的数组用于<code>for in</code>循环</p><pre><code class="js">const object1 = {  a: &#39;somestring&#39;,  b: 42,  c: false};console.log(Object.values(object1));// expected output: Array [&quot;somestring&quot;, 42, false]</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--String</title>
    <link href="undefined2020/06/js-api-string/"/>
    <url>2020/06/js-api-string/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="string-iterator"><a href="#string-iterator" class="headerlink" title="string.@@iterator"></a>string.@@iterator</h3><p>string类型是可迭代的</p><pre><code class="js">let str = &#39;test string&#39;let ite = str[Symbol.iterator]()console.log(ite.next().value) // t</code></pre><h3 id="string-charAt"><a href="#string-charAt" class="headerlink" title="string.charAt"></a>string.charAt</h3><p>获取字符串某一位的内容，无参数默认第一位，下标从0开始</p><pre><code class="js">let str = &#39;text string&#39;console.log(str.charAt()) // tconsole.log(str.charAt(6)) // s </code></pre><h3 id="string-concat"><a href="#string-concat" class="headerlink" title="string.concat"></a>string.concat</h3><p>用于拼接一个或者多个字符串,返回一个新的字符串不会改变源字符串</p><pre><code class="js">let str = &#39;test string&#39;let con_str = &#39; is cool!&#39;console.log(str.concat(con_str)) // test string is cool!</code></pre><h3 id="string-endsWith"><a href="#string-endsWith" class="headerlink" title="string.endsWith"></a>string.endsWith</h3><p>查看该字符串是否以传入的字符串结尾，可以传入裁剪的字符串长度</p><pre><code class="js">var str = &#39;To be, or not to be, that is the question.&#39;;console.log(str.endsWith(&#39;question.&#39;)); // trueconsole.log(str.endsWith(&#39;to be&#39;));     // falseconsole.log(str.endsWith(&#39;to be&#39;, 19)); // true</code></pre><h3 id="string-includes"><a href="#string-includes" class="headerlink" title="string.includes"></a>string.includes</h3><p>查看传入字符串能不能在该字符串中找到，返回<code>boolean</code></p><pre><code class="js">const sentence = &#39;The quick brown fox jumps over the lazy dog.&#39;;const word = &#39;fox&#39;;console.log(`The word &quot;${word}&quot; ${sentence.includes(word) ? &#39;is&#39; : &#39;is not&#39;} in the sentence`);// expected output: &quot;The word &quot;fox&quot; is in the sentence&quot;</code></pre><h3 id="string-indexOf"><a href="#string-indexOf" class="headerlink" title="string.indexOf"></a>string.indexOf</h3><p>查找传入的字符串第一次出现在该字符串的位置，如果没找到返回<code>-1</code>，第二个参数是开始检索的位置</p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#39;;const searchTerm = &#39;dog&#39;;const indexOfFirst = paragraph.indexOf(searchTerm);console.log(`The index of the first &quot;${searchTerm}&quot; from the beginning is ${indexOfFirst}`);// expected output: &quot;The index of the first &quot;dog&quot; from the beginning is 40&quot;console.log(`The index of the 2nd &quot;${searchTerm}&quot; is ${paragraph.indexOf(searchTerm, (indexOfFirst + 1))}`);// expected output: &quot;The index of the 2nd &quot;dog&quot; is 52&quot;</code></pre><h3 id="string-lastIndexOf"><a href="#string-lastIndexOf" class="headerlink" title="string.lastIndexOf"></a>string.lastIndexOf</h3><p>查找传入的字符串最后一次出现在该字符串的位置，如果没找到就返回<code>-1</code>，第二个参数是开始检索的位置</p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#39;;const searchTerm = &#39;dog&#39;;console.log(`The index of the first &quot;${searchTerm}&quot; from the end is ${paragraph.lastIndexOf(searchTerm)}`);// expected output: &quot;The index of the first &quot;dog&quot; from the end is 52&quot;</code></pre><h3 id="string-length"><a href="#string-length" class="headerlink" title="string.length"></a>string.length</h3><p>获取字符串的长度</p><pre><code class="js">const str = &#39;Life, the universe and everything. Answer:&#39;;console.log(`${str} ${str.length}`);// expected output: &quot;Life, the universe and everything. Answer: 42&quot; </code></pre><h3 id="string-match"><a href="#string-match" class="headerlink" title="string.match"></a>string.match</h3><p>针对正则表达式的匹配</p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. It barked.&#39;;const regex = /[A-Z]/g;const found = paragraph.match(regex);console.log(found);// expected output: Array [&quot;T&quot;, &quot;I&quot;]</code></pre><h3 id="string-normalize"><a href="#string-normalize" class="headerlink" title="string.normalize"></a>string.normalize</h3><p>将字符码转化成字符串</p><pre><code class="js">const name1 = &#39;\u0041\u006d\u00e9\u006c\u0069\u0065&#39;;const name2 = &#39;\u0041\u006d\u0065\u0301\u006c\u0069\u0065&#39;;console.log(`${name1}, ${name2}`);// expected output: &quot;Amélie, Amélie&quot;console.log(name1 === name2);// expected output: falseconsole.log(name1.length === name2.length);// expected output: falseconst name1NFC = name1.normalize(&#39;NFC&#39;);const name2NFC = name2.normalize(&#39;NFC&#39;);console.log(`${name1NFC}, ${name2NFC}`);// expected output: &quot;Amélie, Amélie&quot;console.log(name1NFC === name2NFC);// expected output: trueconsole.log(name1NFC.length === name2NFC.length);// expected output: true</code></pre><h3 id="string-padEnd"><a href="#string-padEnd" class="headerlink" title="string.padEnd"></a>string.padEnd</h3><p>在字符串的末尾添加重复的字符串，如果没有参数，填充空格</p><pre><code class="js">const str1 = &#39;Breaded Mushrooms&#39;;console.log(str1.padEnd(25, &#39;.&#39;));// expected output: &quot;Breaded Mushrooms........&quot;const str2 = &#39;200&#39;;console.log(str2.padEnd(5));// expected output: &quot;200  &quot;</code></pre><h3 id="string-padStart"><a href="#string-padStart" class="headerlink" title="string.padStart"></a>string.padStart</h3><p>在字符串的开头添加重复的字符串，如果没有参数，填充空格</p><pre><code class="js">const str1 = &#39;5&#39;;console.log(str1.padStart(2, &#39;0&#39;));// expected output: &quot;05&quot;const fullNumber = &#39;2034399002125581&#39;;const last4Digits = fullNumber.slice(-4);const maskedNumber = last4Digits.padStart(fullNumber.length, &#39;*&#39;);console.log(maskedNumber);// expected output: &quot;************5581&quot;</code></pre><h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw"></a>String.raw</h3><p>直接保存该字符串到内存中，忽略转义字符</p><pre><code class="js">// Create a variable that uses a Windows// path without escaping the backslashes:const filePath = String.raw`C:\Development\profile\aboutme.html`;console.log(`The file was uploaded from: ${filePath}`);// expected output: &quot;The file was uploaded from: C:\Development\profile\aboutme.html&quot;</code></pre><h3 id="string-repeat"><a href="#string-repeat" class="headerlink" title="string.repeat"></a>string.repeat</h3><p>生成指定重复次数的字符串，输入负数会报错，输入小数会被规范成整数，类似<code>Math.floor()</code></p><pre><code class="js">const chorus = &#39;Because I\&#39;m happy. &#39;;console.log(`Chorus lyrics for &quot;Happy&quot;: ${chorus.repeat(27)}`);// expected output: &quot;Chorus lyrics for &quot;Happy&quot;: Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. &quot;</code></pre><h3 id="string-replace"><a href="#string-replace" class="headerlink" title="string.replace"></a>string.replace</h3><p>替换字符串中的内容，如果匹配的内容是字符串就只替换第一个匹配到的内容，它的用法很多，建议直接看文档<a href="https://devdocs.io/javascript/global_objects/string/replace" target="_blank" rel="noopener">链接</a></p><pre><code class="js">const p = &#39;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#39;;const regex = /dog/gi;console.log(p.replace(regex, &#39;ferret&#39;));// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?&quot;console.log(p.replace(&#39;dog&#39;, &#39;monkey&#39;));// expected output: &quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;</code></pre><h3 id="String-search"><a href="#String-search" class="headerlink" title="String.search"></a>String.search</h3><p>匹配正则表达式，返回找到的第一个元素的位置，如果没有找到就返回<code>-1</code></p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#39;;// any character that is not a word character or whitespaceconst regex = /[^\w\s]/g;console.log(paragraph.search(regex));// expected output: 43console.log(paragraph[paragraph.search(regex)]);// expected output: &quot;.&quot;</code></pre><h3 id="string-slice"><a href="#string-slice" class="headerlink" title="string.slice"></a>string.slice</h3><p>提取字符串的一部分出来，不改变原先的字符串，如果起始位置超过了源字符串的长度，返回<code>&quot;&quot;</code></p><pre><code class="js">const str = &#39;The quick brown fox jumps over the lazy dog.&#39;;console.log(str.slice(31));// expected output: &quot;the lazy dog.&quot;console.log(str.slice(4, 19));// expected output: &quot;quick brown fox&quot;console.log(str.slice(-4));// expected output: &quot;dog.&quot;console.log(str.slice(-9, -5));// expected output: &quot;lazy&quot;</code></pre><h3 id="string-split"><a href="#string-split" class="headerlink" title="string.split"></a>string.split</h3><p>将字符串根据分隔符分割进数组</p><pre><code class="js">const str = &#39;The quick brown fox jumps over the lazy dog.&#39;;const words = str.split(&#39; &#39;);console.log(words[3]);// expected output: &quot;fox&quot;const chars = str.split(&#39;&#39;);console.log(chars[8]);// expected output: &quot;k&quot;</code></pre><h3 id="string-startsWith"><a href="#string-startsWith" class="headerlink" title="string.startsWith"></a>string.startsWith</h3><p>判断该字符串是否以传入的字符串开头，传入的第二个参数是开始匹配的位置</p><pre><code class="js">const str1 = &#39;Saturday night plans&#39;;console.log(str1.startsWith(&#39;Sat&#39;));// expected output: trueconsole.log(str1.startsWith(&#39;Sat&#39;, 3));// expected output: false</code></pre><h3 id="string-substring"><a href="#string-substring" class="headerlink" title="string.substring"></a>string.substring</h3><p>很像<code>string.slice</code>，获取字符串的一部分字串</p><pre><code class="js">const str = &#39;Mozilla&#39;;console.log(str.substring(1, 3));// expected output: &quot;oz&quot;console.log(str.substring(2));// expected output: &quot;zilla&quot;</code></pre><h3 id="string-toLocaleLowerCase"><a href="#string-toLocaleLowerCase" class="headerlink" title="string.toLocaleLowerCase"></a>string.toLocaleLowerCase</h3><p>将字符串本地化并转化为小写</p><pre><code class="js">const dotted = &#39;İstanbul&#39;;console.log(`EN-US: ${dotted.toLocaleLowerCase(&#39;en-US&#39;)}`);// expected output: &quot;i̇stanbul&quot;console.log(`TR: ${dotted.toLocaleLowerCase(&#39;tr&#39;)}`);// expected output: &quot;istanbul&quot;</code></pre><h3 id="string-toLocaleUpperCase"><a href="#string-toLocaleUpperCase" class="headerlink" title="string.toLocaleUpperCase"></a>string.toLocaleUpperCase</h3><p>将字符串本地化并转化为大写</p><pre><code class="js">const city = &#39;istanbul&#39;;console.log(city.toLocaleUpperCase(&#39;en-US&#39;));// expected output: &quot;ISTANBUL&quot;console.log(city.toLocaleUpperCase(&#39;TR&#39;));// expected output: &quot;İSTANBUL&quot;</code></pre><h3 id="string-toLowerCase"><a href="#string-toLowerCase" class="headerlink" title="string.toLowerCase"></a>string.toLowerCase</h3><p>将字符串转化为小写</p><pre><code class="js">const sentence = &#39;The quick brown fox jumps over the lazy dog.&#39;;console.log(sentence.toLowerCase());// expected output: &quot;the quick brown fox jumps over the lazy dog.&quot;</code></pre><h3 id="string-toString"><a href="#string-toString" class="headerlink" title="string.toString"></a>string.toString</h3><p>将字符串对象转化为字符串</p><pre><code class="js">const stringObj = new String(&#39;foo&#39;);console.log(stringObj);// expected output: String { &quot;foo&quot; }console.log(stringObj.toString());// expected output: &quot;foo&quot;</code></pre><h3 id="string-toUpperCase"><a href="#string-toUpperCase" class="headerlink" title="string.toUpperCase"></a>string.toUpperCase</h3><p>将字符串转化为大写</p><pre><code class="js">const sentence = &#39;The quick brown fox jumps over the lazy dog.&#39;;console.log(sentence.toUpperCase());// expected output: &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.&quot;</code></pre><h3 id="string-trim"><a href="#string-trim" class="headerlink" title="string.trim"></a>string.trim</h3><p>去除开头和结尾的所有空白，包括但不限于空格、回车</p><pre><code class="js">const greeting = &#39;   Hello world!   &#39;;console.log(greeting);// expected output: &quot;   Hello world!   &quot;;console.log(greeting.trim());// expected output: &quot;Hello world!&quot;;</code></pre><h3 id="string-trimEnd"><a href="#string-trimEnd" class="headerlink" title="string.trimEnd"></a>string.trimEnd</h3><p>去除结尾的所有空白，包括但不限于空格、回车，<code>trimRight</code>是该方法的别称</p><pre><code class="js">const greeting = &#39;   Hello world!   &#39;;console.log(greeting);// expected output: &quot;   Hello world!   &quot;;console.log(greeting.trimEnd());// expected output: &quot;   Hello world!&quot;;</code></pre><h3 id="string-trimStart"><a href="#string-trimStart" class="headerlink" title="string.trimStart"></a>string.trimStart</h3><p>去除开头的所有空白，包括但不限于空格、回车，<code>trimLeft</code>是该方法的别称</p><pre><code class="js">const greeting = &#39;   Hello world!   &#39;;console.log(greeting);// expected output: &quot;   Hello world!   &quot;;console.log(greeting.trimStart());// expected output: &quot;Hello world!   &quot;;</code></pre><h3 id="string-valueOf"><a href="#string-valueOf" class="headerlink" title="string.valueOf"></a>string.valueOf</h3><p>返回字符串对象的原始值</p><pre><code class="js">const stringObj = new String(&#39;foo&#39;);console.log(stringObj);// expected output: String { &quot;foo&quot; }console.log(stringObj.valueOf());// expected output: &quot;foo&quot;</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环赛日程安排</title>
    <link href="undefined2020/06/round-robin/"/>
    <url>2020/06/round-robin/</url>
    
    <content type="html"><![CDATA[<h1 id="循环赛日程安排-–-170521328-赵英博"><a href="#循环赛日程安排-–-170521328-赵英博" class="headerlink" title="循环赛日程安排 – 170521328 赵英博"></a>循环赛日程安排 – 170521328 赵英博</h1><h2 id="问题背景（自定）"><a href="#问题背景（自定）" class="headerlink" title="问题背景（自定）"></a>问题背景（自定）</h2><p>设有<code>n=2^k</code>个选手要进行循环赛，设计一个满足以下要求的比赛日程表：</p><ul><li>每个选手必须与其他<code>n-1</code>个选手各比赛一次</li><li>每个选手一天只能比赛一次</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>每个选手必须与其他选手比赛一次，那么就设计一个<code>n×(n-1)</code>的二维表，其中，<code>(i, j)</code>表示和第<code>i</code>个选手在第<code>j</code>天比赛的选手。</p><p>我们可以对这个二维表进行分割，分割成两个部分，譬如<code>n＝2^k</code>个选手的日程表就可以分成两个<code>n/2＝2^(k-1)</code>的日程表</p><p>在进行递归分割</p><p>分割直到只剩下两个选手</p><blockquote><p>比赛日程表在这个时候就很简单了，让这两个人直接进行比赛就好了</p></blockquote><p>假设有八个人比赛</p><p>整个求解过程是自底向上的迭代过程，其中表格<code>c</code>左上角和左下角分别为选手1到选手8前三天的比赛日程</p><p>将左上角复制到右下角，将左下角复制到右上角，就安排了选手1到选手8后四天的比赛日程</p><ul><li>表格a</li></ul><table><thead><tr><th>1</th><th>2</th></tr></thead><tbody><tr><td>2</td><td>1</td></tr></tbody></table><ul><li>表格b</li></ul><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>4</td><td>3</td></tr><tr><td>3</td><td>4</td><td>1</td><td>2</td></tr><tr><td>4</td><td>3</td><td>2</td><td>1</td></tr></tbody></table><ul><li>表格c</li></ul><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>4</td><td>3</td><td>6</td><td>5</td><td>8</td><td>7</td></tr><tr><td>3</td><td>4</td><td>1</td><td>2</td><td>7</td><td>8</td><td>5</td><td>6</td></tr><tr><td>4</td><td>3</td><td>2</td><td>1</td><td>8</td><td>7</td><td>6</td><td>5</td></tr><tr><td>5</td><td>6</td><td>7</td><td>8</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>6</td><td>5</td><td>8</td><td>7</td><td>2</td><td>1</td><td>4</td><td>3</td></tr><tr><td>7</td><td>8</td><td>5</td><td>6</td><td>3</td><td>4</td><td>1</td><td>2</td></tr><tr><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td></tr></tbody></table><p>将求解<code>2^k</code>个选手比赛日程规划分解为<code>2^1</code>，<code>2^2</code>，<code>2^k</code>个选手的比赛日程问题，通过迭代的方法将问题解决</p><h2 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a>流程描述</h2><p>每次迭代中，将问题划分为了四部分</p><h3 id="左上角"><a href="#左上角" class="headerlink" title="左上角"></a>左上角</h3><p>是<code>2^(k-1)</code>个选手在前半程的比赛日程</p><h3 id="左下角"><a href="#左下角" class="headerlink" title="左下角"></a>左下角</h3><p>是另外<code>2^(k-1)</code>个选手在前半程的比赛日程</p><h3 id="右上角"><a href="#右上角" class="headerlink" title="右上角"></a>右上角</h3><p>左下角复制得来，是<code>2^(k-1)</code>个选手在后半程的比赛日程</p><h3 id="右下角"><a href="#右下角" class="headerlink" title="右下角"></a>右下角</h3><p>左上角复制得来，是另外<code>2^(k-1)</code>个选手在后半程的比赛日程</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用语言Javascript</p><pre><code class="js">// 根据人员数创建合适大小的空数组function createArray(k) {  let arr = new Array(k).map(item =&gt; return new Array(k))  return arr}// 主函数需要传入选手参数数kfunction gameTable(k) {  // n=2^k(k≥1)个选手参加比赛  let table = createArray(k)  let n = 2;  //求解2个选手比赛日程，得到左上角元素  table[0][0]=1; table[0][1]=2;     table[1][0]=2; table[1][1]=1;  // 如果k 就是1，那么直接返回  if(k == 1) return table  // 其余情况进行迭代运算  for(let time = 1; time &lt; k; time++) {    //迭代处理，依次处理2^2, …, 2^k个选手比赛日程    temp=n; n=n*2;       //填左下角元素    for (i=temp+1; i&lt;=n; i++ )          for (j=1; j&lt;=temp; j++)                table[i][j]=table[i-temp][j]+temp;    //左下角元素和左上角元素的对应关系    //填右上角元素    for (i=1; i&lt;=temp; i++)           for (j=temp+1; j&lt;=n; j++)                table[i][j]=table[i+temp][(j+temp)% n];    //填右下角元素    for (i=temp+1; i&lt;=n; i++)          for (j=temp+1; j&lt;=n; j++)                table[i][j]=table[i-temp][j-temp];  }  // 返回整个时间表  return table}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>循环赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--Array</title>
    <link href="undefined2020/06/js-api-array/"/>
    <url>2020/06/js-api-array/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="array-concat"><a href="#array-concat" class="headerlink" title="array.concat"></a>array.concat</h3><p>用于合并两个或更多个数组，此方法不改变现有的数组，而是返回一个新的数组。</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const array2 = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;];const array3 = array1.concat(array2);console.log(array3);// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</code></pre><h3 id="array-copyWithin"><a href="#array-copyWithin" class="headerlink" title="array.copyWithin"></a>array.copyWithin</h3><p>用于将该数组的一部分覆写到另一部分上，用法：<code>arr.copyWithin(target, start, end)</code></p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];// copy to index 0 the element at index 3console.log(array1.copyWithin(0, 3, 4));// expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]// copy to index 1 all elements from index 3 to the endconsole.log(array1.copyWithin(1, 3));// expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;]</code></pre><h3 id="array-entries"><a href="#array-entries" class="headerlink" title="array.entries"></a>array.entries</h3><p>用于获取数组的Iterator，但是比正常的多了当前的index</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const iterator1 = array1.entries();console.log(iterator1.next().value);// expected output: Array [0, &quot;a&quot;]console.log(iterator1.next().value);// expected output: Array [1, &quot;b&quot;]let iterator2 = array1[Symbol.iterator]();console.log(iterator2.next().value);// expected output: String &quot;a&quot;</code></pre><h3 id="array-every"><a href="#array-every" class="headerlink" title="array.every"></a>array.every</h3><p>传入一个方法，会遍历该数组到方法里，方法返回<code>true</code>或者<code>false</code>，只要有一个是<code>false</code>就返回<code>false</code>，用于检测该数组的内容是不是都符合某条件</p><pre><code class="js">const isBelowThreshold = (currentValue) =&gt; currentValue &lt; 40;const array1 = [1, 30, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true</code></pre><h3 id="array-fill"><a href="#array-fill" class="headerlink" title="array.fill"></a>array.fill</h3><p>用于填充数组的指定段，用法：<code>arr.fill(value[, start[, end]])</code></p><pre><code class="js">const array1 = [1, 2, 3, 4];// fill with 0 from position 2 until position 4console.log(array1.fill(0, 2, 4));// expected output: [1, 2, 0, 0]// fill with 5 from position 1console.log(array1.fill(5, 1));// expected output: [1, 5, 5, 5]console.log(array1.fill(6));// expected output: [6, 6, 6, 6]</code></pre><h3 id="array-filter"><a href="#array-filter" class="headerlink" title="array.filter"></a>array.filter</h3><p>用于过滤数组内容，传入一个方法，遍历数组到该方法里，方法返回<code>true</code>则将该元素放进新数组，然后返回新数组</p><pre><code class="js">const words = [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</code></pre><h3 id="array-find"><a href="#array-find" class="headerlink" title="array.find"></a>array.find</h3><p>找到数组中第一个满足条件的元素并返回，如果没有满足的元素就返回<code>undefined</code></p><pre><code class="js">const array1 = [5, 12, 8, 130, 44];const found = array1.find(element =&gt; element &gt; 10);console.log(found);// expected output: 12</code></pre><h3 id="array-findIndex"><a href="#array-findIndex" class="headerlink" title="array.findIndex"></a>array.findIndex</h3><p>找到数组中第一个满足条件的元素的下标并返回，如果没有满足的元素就返回<code>-1</code></p><pre><code class="js">const array1 = [5, 12, 8, 130, 44];const isLargeNumber = (element) =&gt; element &gt; 13;console.log(array1.findIndex(isLargeNumber));// expected output: 3</code></pre><h3 id="array-forEach"><a href="#array-forEach" class="headerlink" title="array.forEach"></a>array.forEach</h3><p>遍历数组，如果有第二个参数就绑定到第一个方法的this</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];array1.forEach(element =&gt; console.log(element));// expected output: &quot;a&quot;// expected output: &quot;b&quot;// expected output: &quot;c&quot;</code></pre><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p>生成一个新数组，还可以传入一个遍历的函数，对每个元素进行遍历操作，用法：<code>Array.from(arrayLike[, mapFn[, thisArg]])</code></p><p>可转化Set和Map还有arguments为真实的数组</p><pre><code class="js">console.log(Array.from(&#39;foo&#39;));// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6]Array.from({length: 5}, (v, i) =&gt; i);// [0, 1, 2, 3, 4]</code></pre><h3 id="array-includes"><a href="#array-includes" class="headerlink" title="array.includes"></a>array.includes</h3><p>查询数组是否包含某元素</p><pre><code class="js">const array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: trueconst pets = [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;];console.log(pets.includes(&#39;cat&#39;));// expected output: trueconsole.log(pets.includes(&#39;at&#39;));// expected output: false</code></pre><h3 id="array-indexOf"><a href="#array-indexOf" class="headerlink" title="array.indexOf"></a>array.indexOf</h3><p>用于查询数组中第一个该元素的位置，没有该元素就返回<code>-1</code>，用法：<code>arr.indexOf(searchElement[, fromIndex])</code>，<code>fromIndex</code>可省，指定开始搜索的位置</p><pre><code class="js">const beasts = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;bison&#39;];console.log(beasts.indexOf(&#39;bison&#39;));// expected output: 1// start from index 2console.log(beasts.indexOf(&#39;bison&#39;, 2));// expected output: 4console.log(beasts.indexOf(&#39;giraffe&#39;));// expected output: -1</code></pre><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><p>用于判定传入的参数是否是数组，返回<code>boolean</code></p><pre><code class="js">Array.isArray([1, 2, 3]);  // trueArray.isArray({foo: 123}); // falseArray.isArray(&#39;foobar&#39;);   // falseArray.isArray(undefined);  // false</code></pre><h3 id="array-join"><a href="#array-join" class="headerlink" title="array.join"></a>array.join</h3><p>用于将数组的内容拼成字符串，传入的参数就是分割符</p><pre><code class="js">const elements = [&#39;Fire&#39;, &#39;Air&#39;, &#39;Water&#39;];console.log(elements.join());// expected output: &quot;Fire,Air,Water&quot;console.log(elements.join(&#39;&#39;));// expected output: &quot;FireAirWater&quot;console.log(elements.join(&#39;-&#39;));// expected output: &quot;Fire-Air-Water&quot;</code></pre><h3 id="array-lastIndexOf"><a href="#array-lastIndexOf" class="headerlink" title="array.lastIndexOf"></a>array.lastIndexOf</h3><p>返回给定的内容在数组中最后一次出现的位置，如果没有返回<code>-1</code>，用法：<code>arr.lastIndexOf(searchElement[, fromIndex])</code>，<code>fromIndex</code>可省，指定开始搜索的位置</p><pre><code class="js">const animals = [&#39;Dodo&#39;, &#39;Tiger&#39;, &#39;Penguin&#39;, &#39;Dodo&#39;];console.log(animals.lastIndexOf(&#39;Dodo&#39;));// expected output: 3console.log(animals.lastIndexOf(&#39;Tiger&#39;));// expected output: 1</code></pre><h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>获取数组的长度，是一个32位整数</p><pre><code class="js">const clothing = [&#39;shoes&#39;, &#39;shirts&#39;, &#39;socks&#39;, &#39;sweaters&#39;];console.log(clothing.length);// expected output: 4</code></pre><h3 id="array-map"><a href="#array-map" class="headerlink" title="array.map"></a>array.map</h3><p>根据遍历函数的返回值返回一个新的数组</p><pre><code class="js">const array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]</code></pre><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h3><p>根据参数创建一个新数组，与直接new的差别在于对整数的处理，传入数字表示创建一个包含该数字的数组而不是创建一个长度为该数字的空数组</p><pre><code class="js">Array.of(7);       // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7);          // [ , , , , , , ]Array(1, 2, 3);    // [1, 2, 3]</code></pre><h3 id="array-pop"><a href="#array-pop" class="headerlink" title="array.pop"></a>array.pop</h3><p>弹出数组的最后一个元素，返回该元素，同时会改变原数组</p><pre><code class="js">const plants = [&#39;broccoli&#39;, &#39;cauliflower&#39;, &#39;cabbage&#39;, &#39;kale&#39;, &#39;tomato&#39;];console.log(plants.pop());// expected output: &quot;tomato&quot;console.log(plants);// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]</code></pre><h3 id="array-push"><a href="#array-push" class="headerlink" title="array.push"></a>array.push</h3><p>向数组末尾添加一个元素，返回添加后的数组长度</p><pre><code class="js">const animals = [&#39;pigs&#39;, &#39;goats&#39;, &#39;sheep&#39;];const count = animals.push(&#39;cows&#39;);console.log(count);// expected output: 4console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]animals.push(&#39;chickens&#39;, &#39;cats&#39;, &#39;dogs&#39;);console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;, &quot;cats&quot;, &quot;dogs&quot;]</code></pre><blockquote><p>可以用这个模拟cancat，但是没什么用就是了</p></blockquote><pre><code class="js">var vegetables = [&#39;parsnip&#39;, &#39;potato&#39;];var moreVegs = [&#39;celery&#39;, &#39;beetroot&#39;];// Merge the second array into the first one// Equivalent to vegetables.push(&#39;celery&#39;, &#39;beetroot&#39;);Array.prototype.push.apply(vegetables, moreVegs);console.log(vegetables); // [&#39;parsnip&#39;, &#39;potato&#39;, &#39;celery&#39;, &#39;beetroot&#39;]</code></pre><h3 id="array-reduce"><a href="#array-reduce" class="headerlink" title="array.reduce"></a>array.reduce</h3><p>执行传入的方法最终返回一个值，传入的方法有四个参数，依次是：累加器(acc)，当前遍历的值(cur)，当前遍历的下标(idx)，整个数组(src)，第二个参数是一个初始的默认值，可以不加</p><pre><code class="js">const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15</code></pre><h3 id="array-reduceRight"><a href="#array-reduceRight" class="headerlink" title="array.reduceRight"></a>array.reduceRight</h3><p>和上边一样，不过是从右边开始遍历</p><pre><code class="js">const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight(  (accumulator, currentValue) =&gt; accumulator.concat(currentValue));console.log(array1);// expected output: Array [4, 5, 2, 3, 0, 1]</code></pre><h3 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array.reverse"></a>array.reverse</h3><p>反转整个数组`</p><pre><code class="js">const array1 = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];console.log(&#39;array1:&#39;, array1);// expected output: &quot;array1:&quot; Array [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]const reversed = array1.reverse();console.log(&#39;reversed:&#39;, reversed);// expected output: &quot;reversed:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]// Careful: reverse is destructive -- it changes the original array.console.log(&#39;array1:&#39;, array1);// expected output: &quot;array1:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</code></pre><blockquote><p>注意：这个方法会改变原数组</p></blockquote><h3 id="array-shift"><a href="#array-shift" class="headerlink" title="array.shift"></a>array.shift</h3><p>弹出数组的第一个元素，会改变原数组的长度</p><pre><code class="js">const array1 = [1, 2, 3];const firstElement = array1.shift();console.log(array1);// expected output: Array [2, 3]console.log(firstElement);// expected output: 1</code></pre><h3 id="array-slice"><a href="#array-slice" class="headerlink" title="array.slice"></a>array.slice</h3><p>获得数组某一段的<strong>浅拷贝</strong>，用法：<code>arr.slice([begin[, end]])</code></p><pre><code class="js">const animals = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;elephant&#39;];console.log(animals.slice(2));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice(1, 5));// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</code></pre><h3 id="array-some"><a href="#array-some" class="headerlink" title="array.some"></a>array.some</h3><p>和<code>array.every</code>相反，传入一个方法，会遍历该数组到方法里，方法返回<code>true</code>或者<code>false</code>，只要有一个是<code>true</code>就返回<code>true</code>，用于检测该数组是不是有符合某条件的元素</p><pre><code class="js">const array = [1, 2, 3, 4, 5];// checks whether an element is evenconst even = (element) =&gt; element % 2 === 0;console.log(array.some(even));// expected output: true</code></pre><h3 id="array-sort"><a href="#array-sort" class="headerlink" title="array.sort"></a>array.sort</h3><p>用于进行数组排序，可以传入自定义排序函数，默认情况下是转成<code>UTF-16</code>比较首字符进行排序的，会改变原数组</p><pre><code class="js">const months = [&#39;March&#39;, &#39;Jan&#39;, &#39;Feb&#39;, &#39;Dec&#39;];months.sort();console.log(months);// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]const array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// expected output: Array [1, 100000, 21, 30, 4]var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) {  return a - b;  // 如果大于0将a后移，如果小于0将b后移});console.log(numbers);// [1, 2, 3, 4, 5]</code></pre><h3 id="array-splice"><a href="#array-splice" class="headerlink" title="array.splice"></a>array.splice</h3><p>用于替换数组中某一部分</p><pre><code class="js">const months = [&#39;Jan&#39;, &#39;March&#39;, &#39;April&#39;, &#39;June&#39;];months.splice(1, 0, &#39;Feb&#39;);// inserts at index 1console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]months.splice(4, 1, &#39;May&#39;);// replaces 1 element at index 4console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;]</code></pre><h3 id="array-toString"><a href="#array-toString" class="headerlink" title="array.toString"></a>array.toString</h3><p>将数组转化成字符串</p><pre><code class="js">const array1 = [1, 2, &#39;a&#39;, &#39;1a&#39;];console.log(array1.toString());// expected output: &quot;1,2,a,1a&quot;</code></pre><h3 id="array-unshift"><a href="#array-unshift" class="headerlink" title="array.unshift"></a>array.unshift</h3><p>将一个或者多个元素添加到数组的开头，并返回改变后的数组长度</p><pre><code class="js">const array1 = [1, 2, 3];console.log(array1.unshift(4, 5));// expected output: 5console.log(array1);// expected output: Array [4, 5, 1, 2, 3]</code></pre><h3 id="array-keys"><a href="#array-keys" class="headerlink" title="array.keys"></a>array.keys</h3><p>返回一个数组下标的迭代器</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const iterator = array1.keys();for (const key of iterator) {  console.log(key);}// expected output: 0// expected output: 1// expected output: 2</code></pre><blockquote><p>对于空元素Array.keys和Object.keys不太一样</p></blockquote><pre><code class="js">var arr = [&#39;a&#39;, , &#39;c&#39;];var sparseKeys = Object.keys(arr);var denseKeys = [...arr.keys()];console.log(sparseKeys); // [&#39;0&#39;, &#39;2&#39;]console.log(denseKeys);  // [0, 1, 2]</code></pre><h3 id="array-values"><a href="#array-values" class="headerlink" title="array.values"></a>array.values</h3><p>返回一个数组内容的迭代器</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const iterator = array1.values();for (const value of iterator) {  console.log(value);}// expected output: &quot;a&quot;// expected output: &quot;b&quot;// expected output: &quot;c&quot;var a = [&#39;w&#39;, &#39;y&#39;, &#39;k&#39;, &#39;o&#39;, &#39;p&#39;]; var iterator = a.values();console.log(iterator.next().value); // w console.log(iterator.next().value); // y console.log(iterator.next().value); // k console.log(iterator.next().value); // o console.log(iterator.next().value); // p</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript（下）学习笔记</title>
    <link href="undefined2020/06/js2/"/>
    <url>2020/06/js2/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><p>用法<code>var input = prompt(text,defaultText)</code></p><blockquote><p>text     可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）。<br>defaultText     可选。默认的输入文本。</p></blockquote><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>如果两边任意一边出现 <code>true</code> 或者 <code>false</code> 使用 <strong>===</strong></p><p>如果两边任意一边可能是特定值<code>0,&quot;&quot;, []</code> 使用 <strong>===</strong></p><p>剩下的所有情况,使用 <strong>==</strong></p><p>对于引用类型来说,比较仅仅是比较其引用是否是同一个,另外在和字符串比较时,数组会自动转成字符串</p><pre><code class="js">var a = [1,2,3]var b = [1,2,3]var c = &quot;1,2,3&quot;console.log(a == b) // falseconsole.log(a == c) // trueconsole.log(b == c) // true</code></pre><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><pre><code class="js">switch(a) {  case 2:  case 10:    // 2 或者 10 执行    break;  default:    // 条件都不满足默认执行}</code></pre><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>let 尽量将变量声明放在代码块开始,避免在(Temproal Dead Zone, TDZ)<strong>临时死亡区</strong>使用而报错</p><blockquote><p>尽量使用for…let,在每次循环中都会声明一个新的变量,生成了一个闭包。避免for里边的函数在调用的时候引用不到正确的变量。</p></blockquote><p>const声明,相对于保护其中的内容更注重其语意所带来的规范性</p><p>如果把方法定义在{}内,那么在块外执行会报ReferenceError</p><h3 id="spread-rest解构重构"><a href="#spread-rest解构重构" class="headerlink" title="spread/rest解构重构"></a>spread/rest解构重构</h3><p>spread/rest<code>...</code>放在数组前用于展开数组,放在变量前就是收集变量到一个数组里,例如 <code>function a(...arg){} a(a,b,c) -&gt; arg = [a,b,c]</code></p><p>解构 <code>var [a, b, c] = foo()</code> 如果foo返回的是一个长度为三的数组其内容将会被依次赋值给abc</p><p>对象属性复制模式<code>var {a, b, c} = foo()</code>这里省略的其实是<code>a:, b:, c:</code>,对象的属性名要和函数返回的属性名相同,然后将值一一赋值给属性值<code>var {a: x, b: y, c: z} = foo()</code>最后使用的是<code>xyz</code>而不是<code>abc</code></p><blockquote><p>对于这个形式,如果省略声明符就需要用小括号括起来<code>({a, b, c} = foo())</code></p></blockquote><p>使用<strong>对象属性名的计算属性</strong><code>var which = &#39;w&#39;; o1 = {which: &#39;w&#39;}; =&gt; {which: &#39;w&#39;}   o2 = {[which]: &#39;w&#39;}; =&gt; {w: &#39;w&#39;}</code>使用中括号即可使用变量里边的内容作为属性名</p><p>简单的交换两个元素<code>[a, b] = [b, a]</code></p><p>允许出现多次列出同一个源属性<code>{a: {x: X, x: Y}, a} = {a: {x: 1}} =&gt; X == Y == 1, a = {x :1}</code></p><blockquote><p>不必都写在一行里,解构的目的不是为了打字更少,而是为了可读性更强</p></blockquote><p>赋值的时候用不到的东西可以抛弃<code>[,a,b] = [1, 2, 3] =&gt; a = 2, b = 3</code></p><p>赋值的时候多余的东西会赋值undefined<code>[a, b] = [1] =&gt; a = 1, b = undefined</code></p><p>赋值的时候可以使用spread/rest<code>...</code>进行收集操作<code>[...a,b] = [1, 2, 3] =&gt; a = [1, 2], b = 3</code></p><p>赋值的时候可以使用默认值<code>{a, b: WW = 20} = {a: 10}  =&gt; a = 10, WW = 20</code></p><p>赋值的时候可以嵌套结构</p><p>在形参中使用这个就接近了命名参数,得到了任意位置的可选参数功能</p><p>设置默认参数<code>{x = 10} = {}</code>,</p><blockquote><p>比较一下<code>{y} = {y: 10}</code>与<code>{x = 10} = {}</code><br>对于x这种新式的用法来说，如果第一个参数省略或者是undefined，就会应用{}空对象默认值，然后，在第一个参数位置传入的任何值——或者是默认{}或者是你传入的任何值，都是用<code>{x = 10}</code>进行解构，这会检查是否存在x属性，如果没有或者是undefined，就会自动赋值为10，所以x不论传入什么，只要没指定x就是10，y则在未传入或者传入undefined嗯嗯时候才会赋值为10</p></blockquote><h3 id="对象字面量拓展"><a href="#对象字面量拓展" class="headerlink" title="对象字面量拓展"></a>对象字面量拓展</h3><p>简洁属性<code>{x}</code></p><p>简洁方法<code>{x(){}}</code></p><blockquote><p>这个操作会生成一个匿名的函数,如果需要递归请不要使用</p></blockquote><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>使用<code>...${foo(`${name}s`)}</code></p><h4 id="标签模板字面量"><a href="#标签模板字面量" class="headerlink" title="标签模板字面量"></a>标签模板字面量</h4><pre><code class="js">  function foo(strings, ...args) {    console.log(strings)    console.log(args)  }  var desc = &quot;awesome&quot;  foo`Every thing is ${desc}!`  // [&quot;Every this is &quot;, &quot;!&quot;]  // [&quot;awesome&quot;]</code></pre><p>配合String.reduce遍历字符串可以达成本地化之类的功能</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>合理使用，函数越短越适合用，函数长了反而会使函数边界模糊</p><p>主要的功能是为了this的规范化而不是减少代码量</p><p>尽可能减少非必要情况下的箭头函数使用</p><h3 id="for-…-of-循环"><a href="#for-…-of-循环" class="headerlink" title="for … of 循环"></a>for … of 循环</h3><p><code>for ... in</code> 遍历的时候遍历的是 index（从0开始） <code>for ... of</code>遍历的是值</p><p>适用所有带迭代器的变量</p><p>自带迭代器的有Arrays,Strings,Generators,Collections/TypedArrays</p><p><code>...</code>可以是赋值表达式也可以是声明</p><blockquote><p>Object 不可迭代所以用不了，非要用自己写个<code>[Symbol.iterator]</code>挂prototype上或者自己extend一个</p></blockquote><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><h4 id="定点标识"><a href="#定点标识" class="headerlink" title="定点标识"></a>定点标识</h4><p><code>re = /d/ re.lastIndex</code></p><p>定点定位<code>/f../y</code>会从lastIndex开始搜索,不会更新lastIndex</p><p>g模式使用exec 会更新lastIndex</p><p>^ 总是指向输入起始处的锚点,不受lastIndex的影响</p><p>y 加上 ^ 加上lastIndex &gt; 0 是一个不兼容的组合,总是会导致失败</p><h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><p><code>re = /foo/ig re.flags =&gt; gi</code>查看应用的哪些标识</p><p>顺序总是<code>gimuy</code></p><h3 id="数字字面量扩展"><a href="#数字字面量扩展" class="headerlink" title="数字字面量扩展"></a>数字字面量扩展</h3><p><code>doc = 12</code></p><p><code>oct = 0o52</code></p><p><code>hex = 0x2a</code></p><p><code>bin = 0b101010</code></p><p><code>a = 42 a.toString(10 || 8 || 6 || 2)</code>可以进行转换</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><code>var snowman = &#39;\u2603&#39;</code> \u转义</p><p><code>var gclef = &#39;\uD834\uDD1E&#39;</code> 替代对</p><p><code>var gclef = &#39;\u{1D11E}&#39;</code> 码点转义</p><h4 id="精确判断字符串长度"><a href="#精确判断字符串长度" class="headerlink" title="精确判断字符串长度"></a>精确判断字符串长度</h4><p><code>[...str].length</code></p><p><code>Array.from(str).length</code></p><h3 id="符号Symbol"><a href="#符号Symbol" class="headerlink" title="符号Symbol"></a>符号Symbol</h3><p>使用例子<code>var sym = Symbol(&#39;something&#39;)</code></p><blockquote><p>不应该使用new</p></blockquote><p>使用<code>typeof</code>识别</p><p>获取全局符号（如果全局不存在则新建一个放在全局）<code>Symbol.for(&quot;exec.name&quot;)</code></p><p>通过符号获取字符串<code>Symbol.keyFor(sym)</code></p><p>设置为对象的属性之后不可枚举,但是可以通过<code>Object.getOwnPropertySymbols(sym)</code>获取</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>可以用来满足消费者生产者模型</p><p>必须拥有一个next()</p><p>可选return()用于消费者向生产者发送所有消费过程完成的信号,生产者应进行销毁程序</p><p>可选throw()用于向生产者发送错误信号,终止生产</p><p>for of 可以消费迭代器,使用break退出会触发return</p><p>通过spread/rest运算符可以消耗迭代器<code>it = arr[Symbol.iterator]() var [x, y] = it; var [z, ...w] = it;</code> it最终会被消耗光</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><code>function *foo() {yield 1;} it = foo() it.next() // value 1</code> next里边的参数会替换掉 yield后边的东西</p><p>就是用迭代器来控制生成器</p><p>可以用throw()配合try catch实现错误的双向或 内外双向传递</p><p>每次被调用的时候都会是一个新的生成器</p><p>加* </p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><code>import</code> 和 <code>export</code> 必须在使用它们的最顶层作用域</p><h4 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h4><pre><code class="js">// 方式一export var bar = [1,3,4]; export function foo() {}// 方式二var bar = []; function foo() {}; export {bar, foo}</code></pre><h4 id="导出的是在模块内的最后的值"><a href="#导出的是在模块内的最后的值" class="headerlink" title="导出的是在模块内的最后的值"></a>导出的是在模块内的最后的值</h4><pre><code class="js">var a = 1export { a }a = 2// -&gt; 最后导出的是2而不是1</code></pre><h4 id="导出可以指定名称"><a href="#导出可以指定名称" class="headerlink" title="导出可以指定名称"></a>导出可以指定名称</h4><pre><code class="js">var a = 1export { a as b }// -&gt; 只有b可以被导入,a被隐藏</code></pre><blockquote><p>导入不是赋值操作,而是类似指针一样的绑定<br>es6倾向于一个文件一个export,可以使import变得简单</p></blockquote><h4 id="默认导出的两种形式"><a href="#默认导出的两种形式" class="headerlink" title="默认导出的两种形式"></a>默认导出的两种形式</h4><pre><code class="js">export default function foo() {} // -&gt; 导出的是表达式的绑定function foo() {} export default foo // -&gt; 同上,即`export default`接受的是一个表达式function foo() {} export { foo as default } // -&gt; 导出的是标识符的绑定,也就是导出foo在文件中最后的值</code></pre><blockquote><p>一个模块只能有一个default</p></blockquote><pre><code class="js">// 方式一export default function foo() {}export function bar() {}// 方式二function foo() {}function bar() {}export { foo as default, bar }</code></pre><h4 id="可以导出别的模块的导出-gt-感觉可以用来集成模块-也没啥用"><a href="#可以导出别的模块的导出-gt-感觉可以用来集成模块-也没啥用" class="headerlink" title="可以导出别的模块的导出 -&gt; 感觉可以用来集成模块,,也没啥用"></a>可以导出别的模块的导出 -&gt; 感觉可以用来集成模块,,也没啥用</h4><pre><code class="js">export { foo, bar } from &#39;baz&#39;export { foo as FOO, bar as BAR } from &#39;baz&#39;export * from &#39;baz&#39;</code></pre><p>导入模块如果有default<code>import foo from &quot;baz&quot;</code>引入那个default</p><p>对导入进行重命名<code>import { foo as Foo } from &quot;baz&quot; -&gt; Foo()</code></p><p>对复合导入<code>import FOOFN, { bar, baz } from &quot;baz&quot;</code></p><p>命名空间导入<code>import * as foo from &quot;foo&quot; -&gt; foo.bar()</code>当前只能全部导入</p><p>如果有默认导出,就是<code>foo.default()</code></p><p>默认+命名空间<code>import foofn, * as hello from &quot;world&quot;</code> <code>foofn -&gt; hello.default</code> 尽量不要用这种迷惑操作</p><p>所有导入的绑定都是只读的,所有的赋值操作都会报错</p><p>所有导入都会被提升,全局访问</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用<code>class</code>声明类,类名大写</p><pre><code class="js">class Foo {  constructor(a, b) {    this.x = a;    this.y = b;  }  gimmeXY() {    return this.x * this.y  }}</code></pre><p>不能使用call所以只能通过new实例化</p><p>类不能被提升,所以实例化之前必须声明</p><p>声明一个class并没有创建一个同名的全局对象属性</p><p>class本身并不是一个实体,而是一个包裹着其他像函数和属性这样的具体实体并把它们组合到一起的元概念</p><p>class也可以是一个表达式</p><pre><code class="js">var x = class Y {} // -&gt; 对于把类定义(严格说是构造器本身)作为函数参数传递,或者把它赋值给一个对象属性的时候特别管用</code></pre><p>把类理解为一个宏,用于自动产生一个prototype对象</p><p>类对extends以及super提供语法糖</p><pre><code class="js">class Bar extends Foo {  constructor(a, b, c) {    super(a, b)    this.z = c  }  gimmeXYZ() {    return super.gimmeXY() * this.z  }}</code></pre><p>如果子类不定义构造函数就会</p><pre><code class="js">constructor(...args) {  super(...args)}</code></pre><blockquote><p>子类不在构造器中使用<code>super</code>是无法使用<code>this</code>的</p></blockquote><p>可以拓展原生类</p><pre><code class="js">class MyCoolArray extends Array {  first() {return this[0]}  last() {return this[this.length -1 ]}}a = new MyCoolArray(1, 2, 3)a.first()</code></pre><p><code>new.target</code>在构造器中访问new直接调用的构造器</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>决议的结果只可能是完成或者拒绝,附带一个可选的单个值,如果拒绝,那么最终的值称为原因</p><p>只能被完成或者拒绝一次,之后完成或者拒绝的操作都会被忽略</p><p>创建一个Promise</p><pre><code class="js">var p = new Promise(function(resolve, reject) {  // 成功  resolve(arg)  // 采用另一个Promise的决议值  resolve(promise)  // 拒绝  reject(why)})// 调用// then接受两个函数第一个是完成,第二个是拒绝时执行p().then(  function fulfilled(res) {},  funcrion rejected(err){},)</code></pre><p>不论是<code>.then</code>还是<code>.catch</code>都会返回一个Promise,可以用<code>.then</code>进行处理</p><p>只要是函数里边包含<code>then</code>方法都会被认为是一个<code>thenable</code>所以不要盲目信任自称是Promise的东西</p><h4 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h4><p><code>Promise.resolve</code></p><pre><code class="js">var p1 = Promise.resolve(42)var p2 = new Promise(function pr(resolve){resolve(42)})// p1 和 p2 的最终行为方式是相同的</code></pre><p>这个接口提供了一个规范化Promise的方法,可以将刚刚不可信任的thenable放进去规范化</p><h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a><code>Promise.reject</code></h5><p>和上边的一样创建一个立即被拒绝的promise,但是如果他的参数是Promise,它不会理会传进来得Promise的决议值</p><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([])"></a><code>Promise.all([])</code></h5><p>接受一个或者多个值的数组,比如立即值、Promise、thenable,它返回一个promise,如果里边的所有值都是完成则决议结果是完成,其中某一个被拒绝这个Promise就立即被拒绝</p><blockquote><p>是等待所有都完成或者第一个拒绝</p></blockquote><h5 id="Promise-rase"><a href="#Promise-rase" class="headerlink" title="Promise.rase([])"></a><code>Promise.rase([])</code></h5><p>等待第一个完成或者拒绝</p><blockquote><p>也就是说返回第一个完成的决议值</p></blockquote><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h4><pre><code class="js">// 创建一个buffer,长度为32字节,一共256位var buf = new ArrayBuffer(32)console.log(buf.byteLength) // 32// 将这256位映射成一个16位无符号整型的类型数组var arr = new Uint16Array(buf)console.log(arr.length) // 16</code></pre><h4 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h4><p>是指多字节数字中的低字节位于这个数字字节表示中的右侧还是左侧</p><p>举个例子,设想一个十进制数字3085,我们需要用16位来表示它。如果只是用一个十六位数字容器,那么不论大小端配置如何都是0000110000001101B,或者0c0dH</p><p>但是如果用两个八位数组表示数字3085,那么大小端就会明显影响他在内存中的存储表示：</p><ul><li>0000110000001101/0c0d（大端）</li><li>0000110100001100/0d0c（小端）</li></ul><p>快速监测JavaScript大小端的方法</p><pre><code class="js">var littleEndian = (function() {  var buffer = new ArrayBuffer(2);  new DataView( buffer ).setInt16(0, 256, true)  return new Int16Array(buffer)[0] === 256;})();</code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>当前的js的对象的键只支持字符串</p><pre><code class="js">var m = {}var x = { id : 1 }var y = { id : 2 }m[x] = &quot;foo&quot;m[y] = &quot;bar&quot;m[x] // &quot;bar&quot;m[y] // &quot;bar&quot;</code></pre><p>因为x,y两个对象字符串化都是”[object object]”, 所以m中只有一个键</p><h5 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h5><pre><code class="js">var m = new Map();var x = { id : 1 }var y = { id : 2 }m.set(x, &quot;foo&quot;)m.set(y, &quot;bar&quot;)m.get(x)m.get(y)m.delete(x)m.clear()m.size</code></pre><p>只是不能使用<code>[]</code>的方式来进行访问了,但是可以用set、get完美替换,删除的话不能用<code>delete</code>操作符,要用<code>delete()</code>方法,完全清空map用<code>clear()</code>方法,访问映射的大小用<code>size</code>属性</p><p><code>new</code>的时候可以传入一个二维数组<code>[[key, value]]</code></p><h5 id="Map值"><a href="#Map值" class="headerlink" title="Map值"></a>Map值</h5><p>使用<code>value()</code></p><pre><code class="js">var m = new Map()var x = {id: 1},    y = {id: 2}m.set(x, &quot;foo&quot;)m.set(y, &quot;bar&quot;)var vals = [...m.values()]vals // [&quot;foo&quot;,&quot;bar&quot;]Array.from( m.values())// 使用entries迭代vals = [...m.entries()]vals[0][0] === x; // truevals[0][1];       // &quot;foo&quot;vals[1][0] === y; // falsevals[1][1];       // &quot;bar&quot;</code></pre><h5 id="Map键"><a href="#Map键" class="headerlink" title="Map键"></a>Map键</h5><p>使用<code>keys()</code></p><pre><code class="js">var keys = [...m.keys()]keys[0] === x;    // truekeys[1] === y;    // true</code></pre><p>查看是否有给定的键</p><pre><code class="js">m.has(x);         // truem.has(z);         // false</code></pre><p>map的本质是允许你把某些额外的信息关联到一个对象上,而无需把这个信息放入对象本身</p><h5 id="weakmap"><a href="#weakmap" class="headerlink" title="weakmap"></a>weakmap</h5><p>作为键的对象被回收后会被自动删除,多用于dom中</p><blockquote><p>没有size,没有clear()</p></blockquote><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>是一个值得集合,其中得值唯一（重复会被忽略）</p><p>用add()代替set(),没有get()</p><pre><code class="js">var s = new Set()var x = {id: 1}var y = {id: 2}s.add(x) s.add(y) s.add(x)s.size // 2s.delete(y)s.size // 1s.clear() // 0s.size // 0</code></pre><p>初始化可以放进去一个构造器</p><pre><code class="js">var x = {id: 1}var y = {id: 2}var s = new Set([x, y])s.has(x) // true</code></pre><h3 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><h5 id="静态函数Array-of"><a href="#静态函数Array-of" class="headerlink" title="静态函数Array.of()"></a>静态函数Array.of()</h5><p>正常使用<code>new Array(4)</code>会生成一个长度为4得空数组,但是使用<code>of</code>就能生成长度为1值为4的数组</p><h5 id="静态函数Array-from"><a href="#静态函数Array-from" class="headerlink" title="静态函数Array.from()"></a>静态函数Array.from()</h5><p><code>Array.from({length:4})</code> 生成4个undefined可以避免空槽位</p><p>映射<code>Array.from(arr, function(val, idx){return}, this)</code>对每一个值进行进行映射处理,类似.map(),如果有第三个参数,则会被绑定为第二个函数的this</p><h5 id="原型方法copyWithin"><a href="#原型方法copyWithin" class="headerlink" title="原型方法copyWithin()"></a>原型方法copyWithin()</h5><p>从一个数组中复制一部分到同一个数组的另一个位置,覆盖这个位置所有原来的值,如果有任何一个参数是负值,就被当作是相对于数组结束的相对值</p><pre><code class="js">[1,2,3,4,5].copyWithin(3,0); // [1,2,3,1,2][1,2,3,4,5].copyWithin(3,0,1); // [1,2,3,1,5][1,2,3,4,5].copyWithin(0,-2); // [4,5,3,4,5][1,2,3,4,5].copyWithin(0,-2,-1); // [4,2,3,4,5]</code></pre><blockquote><p>用的时候输出一下结果,避免不是想要的结果</p></blockquote><h5 id="原型方法fill"><a href="#原型方法fill" class="headerlink" title="原型方法fill()"></a>原型方法fill()</h5><p>填充数组,第一个参数是要填充的内容,然后是填充的开始和结束</p><pre><code class="js">[null, null, null, null].fill(42, 1, 3) // [null, 42, 42, null]</code></pre><h5 id="原型方法find"><a href="#原型方法find" class="headerlink" title="原型方法find()"></a>原型方法find()</h5><p>indexOf是用的===导致’2’不能与2匹配</p><p>es5中的变通方法是用some方法对每个元素调用一个函数回调,直到某次返回为true为止,因为可以定义回调函数,所以拥有了对匹配方式的完全控制,但是最后只能得到匹配的true或者false提示,无法的到真正的匹配值本身</p><p>find()与some()基本一致,除了一旦返回值是真值,会返回实际的数组值,如果没找到会返回undefined</p><pre><code class="js">var a = [1,2,3,4,5]var b = a.find(function matcher(v){  return v == &#39;2&#39;})console.log(b) // 2</code></pre><h5 id="原型方法findIndex"><a href="#原型方法findIndex" class="headerlink" title="原型方法findIndex()"></a>原型方法findIndex()</h5><p>和find()一样对每个元素调用一个函数回调,但是如果返回是true则会返回index,如果没找到返回-1</p><blockquote><p>不要使用findIndex(..) != -1(这是indexOf的惯用法)从搜索中得到布尔值,因为some()已经yield出你想要的true/false。也不要用a[a.findIndex(..)]来得到匹配值,因为这是find()所作的事。最后如果需要严格匹配的索引值,那么使用indexOf()；如果需要自定义匹配的索引值,那么使用findIndex()</p></blockquote><p>接受回调的数组方法接收一个可选的第二个参数,如果设定这个参数就绑定到第一个参数回调的this,否则this就是undefined</p><p>原型方法entries()、values()、keys()</p><blockquote><p>同SET,MAP差不多</p></blockquote><pre><code class="js">var a = [1, 2, 3][...a.values()] // [1,2,3][...a.keys()]   // [0,1,2][...a.entries()] // [[0,1],[1,2],[2,3]][...a[Symbol.iterator]()] // [1,2,3]</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="静态函数Object-is"><a href="#静态函数Object-is" class="headerlink" title="静态函数Object.is()"></a>静态函数Object.is()</h5><p>执行比===更严格的值比较,应该继续使用===进行严格相等比较,不可当作这个运算符的替代,如果需要严格识别NaN或者-0,则应该选择Object.is()</p><pre><code class="js">var x = NaN, y = 0, z = -0x === x  // falsey === z  // trueObject.is(x,x) // trueObject.is(y,z) // false</code></pre><h5 id="静态函数Object-getOwnPropertySymbols"><a href="#静态函数Object-getOwnPropertySymbols" class="headerlink" title="静态函数Object.getOwnPropertySymbols()"></a>静态函数Object.getOwnPropertySymbols()</h5><p>Symbol可能会成为对象最经常使用的特殊(元)属性。所以引入了这个工具直接从对象上回去所有的符号属性</p><pre><code class="js">var o = {  foo: 42,  [Symbol(&quot;bar&quot;)]: &quot;hello world&quot;,  baz: true}Object.getOwnPropertySymbols(o); // [Symbol(bar)]</code></pre><h5 id="静态函数Object-setPrototypeOf"><a href="#静态函数Object-setPrototypeOf" class="headerlink" title="静态函数Object.setPrototypeOf()"></a>静态函数Object.setPrototypeOf()</h5><p>用于设置对象的[[Prototype]]用于行为委托</p><pre><code class="js">var o1 = {foo() {}}var o2 = {baz() {}}Object.setPrototypeOf(o2, o1)o2.foo()// 或者var o2 = Object.setPrototypeOf({baz(){}},o1)o2.foo()</code></pre><h5 id="静态函数Object-assign"><a href="#静态函数Object-assign" class="headerlink" title="静态函数Object.assign()"></a>静态函数Object.assign()</h5><p>第一个参数是target,剩下的所有参数的传入的源,按照传入的顺序依次处理,对于每个源来讲,他的可枚举属性和自己拥有的简直,包括符号都会通过简单的=赋值被复制,会返回目标对象,经过实测,后边的会覆盖前边的值,如果不想这样就使用符号,只读属性可被复制：复制后是个普通属性，不可枚举属性不可复制，不可枚举符号不可被复制</p><p>而且除了setPrototypeOf可以链接[[prototype]]还可以使用</p><pre><code class="js">var o1 = {foo(){}}var o2 = Object.assign(Object.create(o1),{// o2 的定义})o2.foo()</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><h5 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h5><p>Number.EPSILON任意两个值之间的最小差</p><p>Number.MAX_SAFE_INTEGER可以用数字值无歧义“安全表达”的最大整数：2^53 - 1</p><p>Number.MIN_SAFE_INTEGER可以用数字值无歧义“安全表达” 的最小整数：-(2^53-1) 或 (-2)^53 + 1</p><h5 id="静态函数Number-isNaN"><a href="#静态函数Number-isNaN" class="headerlink" title="静态函数Number.isNaN()"></a>静态函数Number.isNaN()</h5><p>是对于全局函数isNaN()的修正，可以按期望工作</p><h5 id="静态函数Number-isFinite"><a href="#静态函数Number-isFinite" class="headerlink" title="静态函数Number.isFinite()"></a>静态函数Number.isFinite()</h5><p>判断数字是不是非无限的，能排除掉NaN和Infinity</p><p>全局的isFinite()会强制进行类型转换，而这个不会</p><h5 id="整型相关静态函数"><a href="#整型相关静态函数" class="headerlink" title="整型相关静态函数"></a>整型相关静态函数</h5><p>正常情况下是检查小数部分是否非0 x===Math.floor(x)</p><p>ES6新增Number.isInteger(),可以更有效的判断这个性质，同时排除了NaN 和 Infinity 返回false，对于4,4.0,4.00都会返回true</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="原型函数repeat"><a href="#原型函数repeat" class="headerlink" title="原型函数repeat()"></a>原型函数repeat()</h5><p>在python和ruby这样的语言中，可以这样重复字符串<code>&quot;foo&quot; * 3 // &#39;foofoofoo&#39;</code></p><p>ES6中<code>&quot;foo&quot;.repeat(3) // &#39;foofoofoo&#39;</code></p><h5 id="字符串检查函数"><a href="#字符串检查函数" class="headerlink" title="字符串检查函数"></a>字符串检查函数</h5><p><code>str.startsWith(&quot;some&quot;) // true</code></p><p><code>str.endsWith(&quot;some&quot;) // true</code></p><p><code>str.includes(&quot;some&quot;) // true</code></p><p>不会接受正则表达式用于搜索，而且如果搜索空字符串一般会在开始或者结尾找到</p><h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><pre><code class="js">(function(){...}); // name:(function*(){...}); // name:window.foo = function(){...}; // name:class Awesome{  constructor(){...} // name: Awesome  funny(){...} // name: funny}var c = class Awesome {..}; // name: Awesomevar o = {  foo(){...}, // name: foo  *bar(){...}, // name: bar  baz: () =&gt; {...}, // name: baz  bam: function() {...}, // name: bam  get qux() {...}, // name: get qux  set fuz() {...}, // name: set fuz  [&quot;b&quot;+&quot;lz&quot;]: function() {...}, // name: blz  [Symbol(&quot;buz&quot;)]: function() {...} // name: [buz]};var x = o.foo.bind(o); // bound foo(function(){..}).bind(0); // boundexport default function() {...} // name: defaultvar y = new Function(); // name: anonymousvar GeneratorFunction = function*(){}.__proto__.constructor;var z = new GeneratorFunction() // name: anonymous</code></pre><blockquote><p>默认情况下name属性不可写，但是可以通过Object.defineProperty(..)手动修改</p></blockquote><h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p><code>new.target</code>可以指向调用new的目标构造器，也就是说如果在构造器里想区分直接调用还是子类调用使用如下代码</p><pre><code class="js">class Parent {  constructor() {    if (new.target === Parent) console.log(&#39;from parent&#39;)    else console.log(&#39;from child&#39;)  }}class Child extends Parent {}var a = new Parent(); // from parentvar b = new Child(); // from child</code></pre><h4 id="公开符号"><a href="#公开符号" class="headerlink" title="公开符号"></a>公开符号</h4><h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>表示任意对象上的一个专门位置（属性），语言机制自动在这个位置上寻找一个方法，这个方法构造一个迭代器来消耗这个对象的值。很多对象定义有这个符号的默认值</p><pre><code class="js">var arr = [4,5,6,7,8,9];for(let v of arr) {  console.log(v) // 4 5 6 7 8 9}// 定义一个只在奇数位置产生索引值的迭代器arr[Symbol.iterator] = function *() {  var idx = 1;  do {    yield this[idx];  } while((idx += 2) &lt; this.length);};for (let v of arr) {  console.log(v) // 5 7 9}</code></pre><h5 id="Symbol-toStringTag-与-Symbol-hasInstance"><a href="#Symbol-toStringTag-与-Symbol-hasInstance" class="headerlink" title="Symbol.toStringTag 与 Symbol.hasInstance"></a>Symbol.toStringTag 与 Symbol.hasInstance</h5><pre><code class="js">function Foo(greeting) {  this.greeting = greeting;}Foo.prototype[Symbol.toSringTag] = &quot;Foo&quot;;Object.defineProperty(Foo, Symbol.hasInstance, {  value: function(inst) {    return inst.greeting == &#39;hello&#39;  }})var a = new Foo(&quot;hello&quot;)var b = new Foo(&quot;world&quot;)b[Symbol.toStringTag] = &#39;cool&#39;a.toString() // [Object Foo]b.toString() // [Object cool]a instanceof Foo; // trueb instanceof Foo; // false</code></pre><blockquote><p>原型（或者是实例本身）的@@toStringTag符号指定了在[Object ___]字符串化时使用的字符串值</p></blockquote><blockquote><p>@@hasInstance 符号是在构造器函数上的一个方法，接收实例对象值，通过返回true 或者 false 来指示这个值是否可以被认为是一个实例<br>要在一个函数上设置@@hasInstance必须使用Object.defineProperty，因为默认的那个是不可写的</p></blockquote><h5 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h5><p>这个符号控制要生成新实例的时候，类的内置方法使用哪一个构造器</p><pre><code class="js">class Cool {  // 把@@species推迟到子类  static get [Symbol.species]() {return this;} // 这个就是默认的行为  again(){    return new this.constructor[Symbol.species]();  }}class Fun extends Cool {}class Awesome extends Cool {  // 强制指定@@species为父构造器  static get [Symbol.species]() {    return Cool;  }}var a = new Fun(),b = new Awesome(),c = a.again(),d = b.again();c instanceof Fun; // trued instanceof Awesome; // falsed instanceof Cool; // true</code></pre><h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>如果一个对象或者数组要使用== 或者+那么就必须被强制转化成一个原生类型</p><pre><code class="js">var arr = [1,2,3,4,5]arr + 10 // 1,2,3,4,510arr[Symbol.toPrimitive] = function (hint) {  if(hint == &#39;default&#39; || hint == &#39;number&#39;) {    return this.reduce(function(acc, curr){      return acc + curr;    }, 0)  } }arr + 10 // 25</code></pre><blockquote><p>Symbol.toPrimitive方法根据调用ToPrimitive的运算期望的类型，会提供一个提示<code>hint</code>指定”string”、”number”或者”default”（这应该被解释成”number”）。在前面的代码中，加法运算没有提示（传入”default”）。而乘法运算提示为”number”，String(arr)提示为”string”。</p></blockquote><h5 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h5><p>可以被定义为任何对象（比如数组或者其他可迭代对象）的布尔属性，用来指示如果把它传给一个数组的<code>concat()</code>是否应该将其<strong>展开</strong></p><pre><code class="js">var a = [1,2,3],b = [4,5,6];b[Symbol.isConcatSpreadable] = false;[].contact(a,b); // [1,2,3,[4,5,6]]</code></pre><h5 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h5><p>可以被定义为任意对象的对象属性，用来指示使用with语句时那些属性可以或不可以暴露为词法变量</p><pre><code class="js">var o = {a:1, b:2, c:3},a = 10, b = 20, c = 30;o[Symbol.unscopables] = {  a: false, // 能暴露为词法变量，因为是unscopables  b: true,  c: false}with (o) {  console.log(a,b,c)  // 1 20 3}</code></pre><blockquote><p>strict 模式下不允许使用with属性，应该尽量避免使用with，所以这个没有什么用</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript（上）学习笔记</title>
    <link href="undefined2020/04/js1/"/>
    <url>2020/04/js1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>L 和 R 代表左右</p><blockquote><p>LHS 赋值操作的目标是谁<br>RHS 谁是赋值操作的源头</p></blockquote><p>变量出现在赋值操作的左边对其进行<code>LHS</code>查询，即试图找到该容器并可对其进行赋值操作，<strong>与其原先是否有内容无关</strong></p><p>变量出现在赋值操作的右边对其进行<code>RHS</code>查询，即试图找到该容器中的<strong>内容</strong></p><h3 id="ReferenceError同作用域判别失败有关"><a href="#ReferenceError同作用域判别失败有关" class="headerlink" title="ReferenceError同作用域判别失败有关"></a>ReferenceError同作用域判别失败有关</h3><p>严格模式下进行LHS查询失败就会出现，<strong>非严格模式</strong>下会自动创建一个变量</p><p>RHS查询失败一定会报这个错误</p><p>TypeError代表作用域判别成功了但是对<strong>结果的操作</strong>是非法的或者不合理的</p><p>LHS查询是从底层一层一层<strong>向上</strong>找的，所以下一级的变量会对上级的变量形成“遮蔽”现象</p><p><code>eval(&lt;str&gt;)</code>中间的str可以当成一开始就写在那个位置的代码使用，可以对上一级的变量进行“遮蔽”</p><p><code>with(obj){ a = 1 } =&gt; obj.a = 1</code> with会创建一个作用域，并把obj的所有属性和方法放进去，进行的是正常的LHS查询，但是这就导致了当obj中没有被赋值的属性的时候就会在全局作用域中创建一个变量导致变量泄露到全局作用域即<code>obj.a =&gt; undefined</code>,<code>window.a =&gt; 2</code></p><blockquote><p>eval和with都会导致引擎对代码的优化失败从而降低运行效率</p></blockquote><h3 id="IIFE-Immediately-Invoked-Function-Expression-：立即执行函数"><a href="#IIFE-Immediately-Invoked-Function-Expression-：立即执行函数" class="headerlink" title="IIFE(Immediately Invoked Function Expression)：立即执行函数"></a>IIFE(Immediately Invoked Function Expression)：立即执行函数</h3><p>可以把window当成参数直接传进去，形参是global</p><p>将一个参数命名为undefined但是不传参数就能保证undefined是真的undefined，防止被覆盖，例如<code>undefined = true</code>这种代码</p><p>尽量减少使用匿名函数，直接加上个名字就好，这样在出错的时候更容易找到位置</p><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><ul><li><strong>with</strong></li><li><strong>try/catch</strong> (ES3就有了)<ul><li>catch里边就是一个作用域，看上去像是一个函数作用域（类似）</li></ul></li><li><strong>let</strong>创建的变量并不会被提升，所以在声明之前使用都会报ReferenceError错误<ul><li>为代码提供一个显式的作用域并使用let可以让引擎在合适的时间回收垃圾</li></ul></li><li><strong>const</strong> 可以创建块作用域变量</li></ul><blockquote><p>词法作用域关注函数在何处声明，动态作用域关注函数从何处调用</p></blockquote><h3 id="Traceur"><a href="#Traceur" class="headerlink" title="Traceur"></a>Traceur</h3><p>使用google的Traceur可以将es6转换为es5，将let转换为try/catch</p><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>提升的时候函数优先也就是说</p><pre><code class="js">foo() //1var foo // 重复声明而被忽略function foo(){ // 由于优先而被提升到最顶，然后就执行了foo  console.log(1)}foo = function() {  console.log(2)}</code></pre><p><code>var a = 2; =&gt; var a; a = 2;</code>引擎将其拆成两个声明，一个是在编译阶段的任务，一个是在执行阶段的任务</p><p>声明本身会被提升，但是包括函数表达式的赋值在内的赋值操作都不会被提升</p><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>为创建内部作用域而调用了一个包装函数</p><p>包装函数的返回值至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包</p><h2 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>箭头函数会使this继承上一级的this</p><p>使用bind将外边的this传进入也更加靠谱</p><p>this既不指向函数自身，也不指向函数的作用域</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><ul><li>独立函数调用，此时this指向全局作用域，但是如果使用严格模式则会绑定undefined</li><li>虽然this绑定规则完全取决于调用位置，但是只有函数运行在非strict mode下时，默认绑定才能绑定到全局对象；在严格模式下调用函数则不会影响默认绑定</li></ul><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><ul><li>调用位置是否有上下文对象，或者说时被某个对象拥有或者包含</li><li><code>function foo(){} var obj = {foo:foo} obj.foo()</code>此时this指向obj</li><li><code>function foo(){} var obj1 = {foo:foo} var obj2 = {obj1:obj1} obj2.obj1.foo()</code>此时this指向obj1，即对象属性引用链中只有上一层或者说最后一层调用位置中起作用</li><li><code>function foo(){} var obj = {foo:foo} var bar = obj.foo bar()</code>此时bar的this指向全局对象（隐式丢失），虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定</li></ul><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><ul><li>call和apply以及bind的详细介绍<a href="https://blog.csdn.net/wyyandyou_6/article/details/81488103" target="_blank" rel="noopener">链接</a></li><li><code>arr.forEach(fn(currentValue, index, arr),thisValue)</code>在thisValue显式绑定this</li></ul><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><ul><li>包括内置对象函数在内的所有函数都可以使用new来调用，这种函数调用被称为构造函数调用</li><li>使用new来调用函数，或者发生构造函数调用时，会自动执行下面的操作<ul><li>创建（或者说构造）一个全新的对象</li><li>这个新对象会执行Prototype连接</li><li>这个新对象会绑定到函数调用的this（<strong>new绑定</strong>）</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li></ul></li></ul><blockquote><p>优先级 new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定，在bind函数中会判断是不是new调用，new优先</p></blockquote><blockquote><p>如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候或被忽略，实际应用的是默认绑定规则<br>接上，但是假如函数中确实使用到了this就会污染全局作用域，所以使用<code>Object.create(null)</code>,来创建一个空对象，比{}还少一个prototype，用这个代替null当作this的绑定对象</p></blockquote><p>柯里化<a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">链接</a></p><p>软绑定<a href="https://segmentfault.com/q/1010000006223479" target="_blank" rel="noopener">链接</a></p><h4 id="箭头函数下的this"><a href="#箭头函数下的this" class="headerlink" title="箭头函数下的this"></a>箭头函数下的this</h4><ul><li>箭头函数不适用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this</li><li>箭头函数绑定的this无法被改变，即使是new也不行</li><li>this指向调用时上级的this</li><li>以后要尽量减少that=this的写法，多用bind以及箭头函数</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>可以通过声明形式(可以添加多个键值对)和构造模式(必须逐个添加属性)定义</li></ul><h3 id="六种主要类型（语言类型）"><a href="#六种主要类型（语言类型）" class="headerlink" title="六种主要类型（语言类型）"></a>六种主要类型（语言类型）</h3><p><code>string number boolean null undefined object</code>,除了<strong>object</strong>都不是对象类型</p><blockquote><p>由于对象底层表示为二进制，前三位为0被判定为object，但是null二进制全为零，<strong>所以执行typeof会返回object</strong></p></blockquote><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p><code>String Number Boolean Object Function Array Date RegExp Error</code></p><ul><li><p>一般情况下，引擎会把字面量转化为对应的对象，但是<code>null</code>和<code>undefined</code>只有<strong>文字形式</strong>，<code>Date</code>只有<strong>构造形式</strong></p></li><li><p>对于 <code>Object Function Array RegExp</code> 来说不论是文字形式还是构造形式都是对象，不是字面量</p></li><li><p><code>.a</code>属性访问 <code>[&#39;a&#39;]</code> 键访问,键访问可以接受任意UTF-8/Unicode字符串作为属性名，例如’Super-Fun!’</p></li><li><p>es6中在字面量定义对象属性时，加上<code>[变量]</code>就可以做到可计算属性名</p></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><code>JSON.parse(JSON.stringify(obj))</code>的方式复制不了function</li><li><code>Object.assign({}, obj1,...)</code>的方式可以浅复制，包括function</li></ul><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><ul><li>查看<code>Object.getOwnPropertyDiscriptor(obj, &lt;key&gt;)</code></li><li>设置<pre><code class="js">Object.defineProperty(obj,&#39;a&#39;,{  value: 2, //值  writable: true, // 可写，设置false时类似设置setter为空，此时修改值会报typeError（严格模式），非严格模式会静默失败  configurable: true, // 可配置，单向操作，设置为false之后就改不回来了并且不可删除(delete，非严格模式会静默失败)，但是仍可以设置writable为false，不管是不是严格模式修改不可配置的属性描述符都会出错  enumerable: true // 可枚举，如果不想让其出现在for...in 循环中就设置为false})</code></pre></li><li>不变性<ul><li>对象常量：结合<code>configurable: false,writable: false,</code>就可以创建一个真正的常量属性（不可修改，重定义或删除）</li><li>禁止拓展：<code>Object.preventExtensions(obj)</code>禁止对象添加新的属性并且保留已有属性</li><li>密封：<code>Object.seal(obj)</code>相当于禁止拓展加<code>configurable: false</code>即不能添加新的属性也不能重新配置或删除任何现有属性</li><li>冻结：<code>Object.freeze()</code>相当于先密封再<code>writable: false</code>，但是仍不能冻结这个对象引用的对象<ul><li>深度冻结，先冻结该对象，然后遍历其子对象然后冻结</li></ul></li></ul></li><li><code>[[get]]</code>先在obj中查找属性名相同的属性，没有就去查询原型链</li><li><code>[[put]]</code>先看有没有setter（优先使用），然后看是不是writable</li><li>get 和 set<ul><li><pre><code class="js">var obj = {  // 给a定义一个getter  get a() {    return this._a_  },  set a(val) {    this._a_ = val * 2  }}Object.defineProperty(  obj,  &#39;b&#39;,  {    get: function() {return this._a_ * 2},    //确保b会出现在对象的属性列表中    enumerable: true  })obj.a = 2obj.a // 4obj.b // 4</code></pre></li><li>以上操作都会在obj中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，返回值即是被当作属性访问的返回值</li><li>在定义新属性时，get和set不能同value或者writable一起出现否则报TypeError</li></ul></li><li>存在性<ul><li><code>a in obj</code>in操作符或检查对象及其原型链<ul><li>in操作符只检查的是属性名，而不是值，所以 <code>4 in [4,1,2] -&gt; false</code></li></ul></li><li><code>obj.hasOwnProperty(&#39;a&#39;)</code>只检查对象，不检查原型链<ul><li>对于没有原型链的对象如<code>Object.create(null)</code>可<code>Object.prototype.hasOwnProerty.call(obj)</code>显式绑定</li></ul></li><li><code>Object.keys(obj)</code>查看对象中所有键，只显示可枚举属性，并且不会查找原型链，返回数组</li><li><code>Object.getOwnPropertyNames(obj)</code>返回数组，包含所有属性，不论是否可枚举，不会查找原型链</li><li><code>obj.propertyIsEnumerable(&#39;a&#39;)</code>返回Boolean，查看该元素是否可枚举</li></ul></li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>forEach：忽略回调函数的返回值</li><li>every：会一直运行到回调函数返回false</li><li>some：会一直运到到回调函数返回true</li><li>数组可以直接for of循环出所有的值</li><li>for of实际上是调用的迭代器对象</li><li>数组<pre><code class="js">var arr = []var it = arr[Symbol.iterator]()it.next() // {value: 1, done: false}//...it.next() // {done: true}</code></pre>注意:最后会出现这个<code>{done: true}</code></li></ul><h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><ul><li>对象并没有@@iterator所以无法完成for of 遍历，但是可以自己写一个<pre><code class="js">// 会生成无限个随机数var randoms = {  [Symbol.iterator]: function() {    return :function() {      return {value: Math.random()}    }  }}// -----------------------------------var obj = {  a: 2,  b: 3}Object.defineProperty(obj, Symbol.iterator,{  enumerable: false,  writable: false,  configurable: true,  value: function(){    var o = this;    var idx = 0;    var ks = Object.keys(o)    return {      next: function(){        return {          value: o[ks[idx++]],          done: (idx &gt; ks.length)        }      }    }  }})// 手动遍历var it = obj[Symbol.iterator]()it.next() //{ value: 2, done:false}it.next() //{ value: 3, done:false}it.next() //{ done:true}// 使用for offor(var v of obj) {  console.log(v)}// 2// 3</code></pre></li></ul><h2 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h2><ul><li>设计模式：实例化，继承，(相对)多态</li><li>多态并不能表示子类和父类有关联，子类得到的只是父类的一个副本，类的继承实际上就是复制</li><li>super关键字用于访问和调用一个对象的父对象上的函数。<code>super.prop</code>和<code>super[expr]</code>表达式在类和对象字面量任何方法定义中都是有效的。</li><li>js本身并不支持多重继承</li><li>类意味着复制，js并不会自动创建对象的副本</li><li>混入模式可以模拟类的复制行为，但是会产生丑陋并且脆弱的语法。</li><li>而且对象（函数）只能复制引用，无法复制被引用的对象或者函数本身，所以在js中模拟类是得不偿失的，虽然可以解决当前的问题，但是可能会留下更多的隐患</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><code>Object.create(...)</code>创建一个对象并将其<code>prototype</code>关联到指定对象</li><li>所有对象的<code>prototype</code>最终都指向了内置的<code>Object.prototype</code>其中包含类如<code>.toString();.valueOf()</code>之类的方法</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>如果foo不直接存在于obj上而是存在于原型链上层时会出现的三种情况</p><ul><li>如果上层的foo是普通的数据访问属性，并且没有被标记为只读，那就会在对象上直接创建foo属性，它是遮蔽属性</li><li>如果上层的foo是只读属性的话，严格模式下会抛出一个错误，正常模式下静默失败，可以理解为obj继承了foo但是foo是只读属性，所以不可更改（实际上js并没有继承这一概念，只是为了理解、<ul><li>而且仅限于 = 赋值中，使用<code>Object.defineProperty()</code>并不会受到任何影响</li><li>如果上层的foo存在且是一个setter，就会调用这个setter，foo不会重新定义也不会直接添加到obj中</li></ul></li></ul><h4 id="模仿类"><a href="#模仿类" class="headerlink" title="模仿类"></a>模仿类</h4><ul><li>利用所有函数都会拥有一个名为<code>prototype</code>的共有且不可枚举的属性，并且会指向另一个对象</li><li>通过<code>new foo()</code>最后我们得到了两个对象，并且他们互相关联，实际上new并没有直接创建关联，这个关联只是一个意外的副作用</li><li>new 会劫持所有的函数并用构造对象的形式来调用它，而且无论如何都会构造一个对象，换句话说在js中对于“构造函数”最准确的解释是：所有带new的函数调用</li><li>函数被创建的时候会默认在其<code>prototype</code>中声明一个不可枚举的<code>construct</code>属性，指向它自己，使用<code>new</code>创建一个对象的时候由于其<code>prototype</code>会链接到函数的<code>prototype</code>上，所以<code>obj.construct</code>会委托到<code>prototype</code>上也就是指向了函数，但是如果那个函数重定义了整个<code>prototype</code>，再去查找<code>obj.construct</code>就会一层一层委托到<code>Object</code>的<code>construct</code>上，也就是指向<code>Object</code>，总结一下就是说construct并不能表示由“某函数”创建，尽量不要使用它以减少麻烦</li><li>实现类的继承,实际上是委托<ul><li>方法一<code>Bar.prototype = Object.create(Foo.prototype)</code></li><li>方法二<code>Object.setPrototypeOf(Bar.prototype, Foo.prototype)</code> ES6语法</li></ul></li><li><code>__proto__</code>存在于<code>Object.prototype</code>中，看起来像一个属性，但是更像是getter/setter</li><li>创建关联最好的方式不是创建一个类，而是使用<code>Object.create()</code></li><li>所有包含”继承”之类的词语都不适合形容js的操作，更应该使用”委托”，因为“继承”是复制操作（由上至下的），”委托”是链接操作（由下至上的）</li></ul><h4 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h4><ul><li><p>js中<code>[[prototype]]</code>这个机制的本质就是<strong>对象之间的关联关系</strong></p></li><li><p>在正常的模仿类的设计中，上代码！  </p><pre><code class="js">function Foo(who) {  this.me = who}Foo.prototype.indetify = function() {  return &quot;I am&quot; + this.me}function Bar(who) {  Foo.call(this, who)}   Bar.prototype = Object.create(Foo.prototype)Bar.prototype.speak = function() {  alert(&#39;Hello,&#39;+ this.indetify() + &#39;.&#39;)}var b1 = new Bar(&#39;b1&#39;)var b2 = new Bar(&#39;b2&#39;)b1.speak()b2.speak()</code></pre></li><li><p>在es6的语法糖中，上代码！</p><pre><code class="js">class Foo {  constructor(who) {    this.me = who  }  indetify(){    return &quot;I am&quot; + this.me  }}class Bar extends Foo {  constructor(who) {    super(who)  }  speak(){    alert(&#39;Hello,&#39;+ super.indetify() + &#39;.&#39;)  }}var b1 = new Bar(&#39;b1&#39;)var b2 = new Bar(&#39;b2&#39;)b1.speak()b2.speak()</code></pre></li><li><p>在关联风格代码中的实现，上代码！</p><pre><code class="js"> var Foo = {   init: function(who) {     this.me = who   },   indetify: function() {     return &quot;I am&quot; + this.me   } } var Bar = Object.create(Foo) Bar.speak = function() {   alert(&#39;Hello,&#39;+ this.indetify() + &#39;.&#39;) } var b1 = Object.create(Bar) b1.init(&#39;b1&#39;) var b2 = Object.create(Bar) b2.init(&#39;b2&#39;) b1.speak() b2.speak()</code></pre></li><li><p>同为关联风格代码，但是进行了语法上的优化（es6中的简洁方法声明）（Object.setPrototypeOf后置关联）这样看起来舒服不少  </p><pre><code class="js"> var Foo = {   init(who) {     this.me = who   },   indetify() {     return &quot;I am&quot; + this.me   } } var Bar = {   speak() {     alert(&#39;Hello,&#39;+ this.indetify() + &#39;.&#39;)   } } Object.setPrototypeOf(Bar, Foo) var b1 = Object.create(Bar) b1.init(&#39;b1&#39;) var b2 = Object.create(Bar) b2.init(&#39;b2&#39;) b1.speak() b2.speak()</code></pre></li></ul><ul><li>instanceof 如果 Bar”继承了“Foo 那么就是 <code>Bar.prototype instanceof Foo =&gt; true</code></li><li>如果<code>Bar = Object.create(Foo)</code>则<code>Foo.isPrototypeOf(Bar) =&gt; true</code>,<code>Object.getPrototypeOf(Bar) === Foo =&gt; ture</code> </li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（高级篇</title>
    <link href="undefined2020/04/ts3/"/>
    <url>2020/04/ts3/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript高级"><a href="#TypeScript高级" class="headerlink" title="TypeScript高级"></a>TypeScript高级</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起个新名字。</p><pre><code class="ts">type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name {    if (typeof n === &#39;string&#39;) {        return n;    } else {        return n();    }}</code></pre><p>上例中，我们使用 <code>type</code> 创建类型别名。</p><blockquote><p>类型别名常用于联合类型。</p></blockquote><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><pre><code class="ts">type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 报错，event 不能为 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><blockquote><p>注意，类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</p></blockquote><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>定义一对值分别为 <code>string</code> 和 <code>number</code> 的元组</p><pre><code class="ts">let tom: [string, number] = [&#39;Tom&#39;, 25];let tom2: [string, number]tom2[0] = &#39;Tom&#39;  // 直接赋值会在node和浏览器中报错，但是ts不会报错tom2[1] = 1 // 可以对它赋值，也可以不赋值，不会报错tom2[1] = &#39;tox&#39; // 这个地方就会报错，因为指定了是numbertom2 = [&#39;Tom&#39;] // 会报错，因为整体赋值必须要符合定义tom2.push(&#39;d&#39;) // 新加入得元素只要符合tom2.push(1)let tom3: any = [] // 经测试正常还是用这个把</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p><pre><code class="ts">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};</code></pre><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p><pre><code class="ts">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true// 会被编译为var Days;(function (Days) {    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;})(Days || (Days = {}));</code></pre><p><strong>手动赋值</strong></p><pre><code class="ts">enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 7); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // true</code></pre><blockquote><p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的，小心被覆盖<br>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1</p></blockquote><p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)</p><pre><code class="ts">enum Days {Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;};</code></pre><p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p><pre><code class="ts">enum Color {Red, Green, Blue = &quot;blue&quot;.length};  // &quot;blue&quot;.length 就是一个计算所得项。</code></pre><p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项</strong>，那么它就会因为无法获得初始值而报错</p><p><strong>常数枚举</strong></p><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p><p><strong>外部枚举</strong></p><p>是使用 <code>declare enum</code> 定义的枚举类型</p><blockquote><p>同时使用 declare 和 const 也是可以的</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>TypeScript</strong> 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><p><strong>TypeScript</strong> 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public、private</code> 和 <code>protected</code>。</p><p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化</p><p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承</p><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁</p><pre><code class="ts">class Animal {    // public name: string;    public constructor (public name) {        // this.name = name;    }}class Animal {    readonly name;    public constructor(name) {        this.name = name;    }}a.name = &#39;Tom&#39;; //会报错</code></pre><blockquote><p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法</p><p>首先，抽象类是不允许被实例化的</p><p>其次，抽象类中的抽象方法必须被子类实现</p><pre><code class="ts">abstract class Animal {    public name;    public constructor(name) {        this.name = name;    }    public abstract sayHi();}class Cat extends Animal {    public sayHi() {        console.log(`Hello`);    }}let animal =  new Animal(&#39;dd&#39;) // 会报错，抽象类不能被实例化let cat = new Cat(&#39;dd&#39;)  // ok</code></pre><blockquote><p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类</p></blockquote><h3 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h3><p>给类加上 TypeScript 的类型很简单，与接口类似</p><pre><code class="ts">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    sayHi(): string {      return `My name is ${this.name}`;    }}let a: Animal = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><p>接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。</p><p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p><h3 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h3><p>实现（<code>implements</code>）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它</p><p>一个类可以实现多个接口</p><pre><code class="ts">interface Alarm {    alert(): void;}interface Light {    lightOn(): void;    lightOff(): void;}class Door {}class SecurityDoor extends Door implements Alarm {    alert() {        console.log(&#39;SecurityDoor alert&#39;);    }}class Car implements Alarm, Light {    alert() {        console.log(&#39;Car alert&#39;);    }    lightOn() {        console.log(&#39;Car light on&#39;);    }    lightOff() {        console.log(&#39;Car light off&#39;);    }}</code></pre><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><pre><code class="ts">interface Alarm {    alert(): void;}interface LightableAlarm extends Alarm {    lightOn(): void;    lightOff(): void;}</code></pre><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><pre><code class="ts">class Point {    x: number;    y: number;    constructor(x: number, y: number) {        this.x = x;        this.y = y;    }}interface Point3d extends Point {    z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3};</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><pre><code class="ts">function createArray(length: number, value: any): Array&lt;any&gt; {    let result = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray&lt;string&gt;(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><pre><code class="ts">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {    return [tuple[1], tuple[0]];}swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]</code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</p><pre><code class="ts">interface Lengthwise {    length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {    console.log(arg.length);    return arg;}</code></pre><p>上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。</p><p>此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了</p><p>多个类型参数之间也可以互相约束</p><pre><code class="ts">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T {    for (let id in source) {        target[id] = (&lt;T&gt;source)[id];    }    return target;}let x = { a: 1, b: 2, c: 3, d: 4 };copyFields(x, { b: 10, d: 20 });</code></pre><p>上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code class="ts">interface CreateArrayFunc&lt;T&gt; {    (length: number, value: T): Array&lt;T&gt;;}let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><h3 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><pre><code class="ts">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}</code></pre><h2 id="声明的合并"><a href="#声明的合并" class="headerlink" title="声明的合并"></a>声明的合并</h2><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</p><h3 id="函数的合并"><a href="#函数的合并" class="headerlink" title="函数的合并"></a>函数的合并</h3><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string {    if (typeof x === &#39;number&#39;) {        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    } else if (typeof x === &#39;string&#39;) {        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);    }}</code></pre><h3 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h3><pre><code class="ts">interface Alarm {    price: number;}interface Alarm {    weight: number;}// 相当于interface Alarm {    price: number;    weight: number;}</code></pre><blockquote><p>合并的属性的类型必须是唯一的</p></blockquote><p>接口中方法的合并，与函数的合并一样</p><pre><code class="ts">interface Alarm {    price: number;    alert(s: string): string;}interface Alarm {    weight: number;    alert(s: string, n: number): string;}// 相当于interface Alarm {    price: number;    weight: number;    alert(s: string): string;    alert(s: string, n: number): string;}</code></pre><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://ts.xcatliu.com/advanced/further-reading" target="_blank" rel="noopener">索引链接</a></p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（基础篇2</title>
    <link href="undefined2020/04/ts2/"/>
    <url>2020/04/ts2/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数声明定义</p><pre><code class="ts">function sum(x: number, y: number): number {  return x + y;}</code></pre><blockquote><p>输入多余的（或者少于要求的）参数，是不被允许的</p></blockquote></li><li><p>函数表达式定义</p><pre><code class="ts">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {  return x + y;};</code></pre><blockquote><p>注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。<br>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。<br>在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。</p></blockquote></li><li><p>用接口定义函数的形状</p><pre><code class="ts">interface SearchFunc {  (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {  return source.search(subString) !== -1;}</code></pre><blockquote><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p></blockquote></li><li><p>可选参数<br>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数</p><pre><code class="ts">function buildName(firstName: string, lastName?: string) {  if (lastName) {      return firstName + &#39; &#39; + lastName;  } else {      return firstName;  }}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);</code></pre><blockquote><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了</p></blockquote></li><li><p>参数默认值<br>TypeScript 会将添加了默认值的参数识别为可选参数</p><pre><code class="ts">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {  return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);</code></pre><blockquote><p>此时就不受「可选参数必须接在必需参数后面」的限制了</p></blockquote></li><li><p>剩余参数<br>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）</p></li></ul><p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它</p><pre><code class="ts">function push(array: any[], ...items: any[]) {    items.forEach(function(item) {        array.push(item);    });}let a = [];push(a, 1, 2, 3);</code></pre><blockquote><p>rest 参数只能是最后一个参数</p></blockquote><ul><li>重载</li></ul><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。</p><p>利用联合类型，我们可以这么实现：</p><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string {    if (typeof x === &#39;number&#39;) {        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    } else if (typeof x === &#39;string&#39;) {        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);    }}</code></pre><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p><blockquote><p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p></blockquote><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>使用 <code>值</code> as <code>类型</code> 的语法</p><pre><code class="ts">interface Cat {    name: string;    run(): void;}interface Fish {    name: string;    swim(): void;}function isFish(animal: Cat | Fish) {    if (typeof animal.swim === &#39;function&#39;) {  // 会报错，因为swim不是Cat和Fish的共有属性        return true;    }    return false;}function isFish(animal: Cat | Fish) {    if (typeof (animal as Fish).swim === &#39;function&#39;) { // 使用断言，避免错误        return true;    }    return false;}</code></pre><blockquote><p>类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误</p></blockquote><pre><code class="ts">window.foo = 1; // 直接赋值会提示你window上边没有foo属性(window as any).foo = 1; // 把window断言成一个any就可以随便赋值了</code></pre><ul><li>总结</li></ul><p>联合类型可以被断言为其中一个类型</p><p>父类可以被断言为子类</p><p>任何类型都可以被断言为 any</p><p>any 可以被断言为任何类型</p><p>要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可</p><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p><p>声明文件必需以 <code>.d.ts</code> 为后缀。</p><pre><code class="ts">// src/jQuery.d.tsdeclare var jQuery: (selector: string) =&gt; any;</code></pre><blockquote><p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files、include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p></blockquote><h2 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h2><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。</p><p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p><p><code>@types</code> 的使用方式很简单，直接用 <code>npm</code> 安装对应的声明模块即可，以 <code>jQuery</code> 举例</p><pre><code class="cmd">cnpm install @types/jquery --save-dev</code></pre><p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个页面</a>搜索你需要的声明文件。</p><h2 id="书写声明文件"><a href="#书写声明文件" class="headerlink" title="书写声明文件"></a>书写声明文件</h2><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p><ul><li>全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>npm包<a href="https://ts.xcatliu.com/basics/declaration-files#npm-bao" target="_blank" rel="noopener">教程链接</a></li><li>UMD库<a href="https://ts.xcatliu.com/basics/declaration-files#umd-ku" target="_blank" rel="noopener">教程链接</a></li><li>直接扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#zhi-jie-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>在 npm 包或 UMD 库中扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>模块插件<a href="https://ts.xcatliu.com/basics/declaration-files#mo-kuai-cha-jian" target="_blank" rel="noopener">教程链接</a></li><li>声明文件中的依赖<a href="https://ts.xcatliu.com/basics/declaration-files#sheng-ming-wen-jian-zhong-de-yi-lai" target="_blank" rel="noopener">教程链接</a></li><li>自动生成声明文件<a href="https://ts.xcatliu.com/basics/declaration-files#zi-dong-sheng-cheng-sheng-ming-wen-jian" target="_blank" rel="noopener">教程链接</a></li></ul><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>ECMAScript 标准提供的内置对象有：<code>Boolean、Error、Date、RegExp</code> 等。</p><pre><code class="ts">let b: Boolean = new Boolean(1);let e: Error = new Error(&#39;Error occurred&#39;);let d: Date = new Date();let r: RegExp = /[a-z]/;</code></pre><blockquote><p>更多的内置对象，可以查看 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">文档</a>。</p></blockquote><h2 id="DOM-和-BOM-的内置对象"><a href="#DOM-和-BOM-的内置对象" class="headerlink" title="DOM 和 BOM 的内置对象"></a>DOM 和 BOM 的内置对象</h2><p>DOM 和 BOM 提供的内置对象有：<code>Document、HTMLElement、Event、NodeList</code> 等。</p><pre><code class="ts">let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&#39;div&#39;);document.addEventListener(&#39;click&#39;, function(e: MouseEvent) {  // Do something});</code></pre><h2 id="用-TypeScript-写-Node-js"><a href="#用-TypeScript-写-Node-js" class="headerlink" title="用 TypeScript 写 Node.js"></a>用 TypeScript 写 Node.js</h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p><pre><code class="cmd">npm install @types/node --save-dev</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（基础篇1</title>
    <link href="undefined2020/04/ts1/"/>
    <url>2020/04/ts1/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>cnpm install -g typescript</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><pre><code>tsc hello.ts</code></pre><blockquote><p>我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>TypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以。</p><blockquote><p>TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。<br>如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json，请参阅<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html" target="_blank" rel="noopener">官方手册</a></p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。</p><p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>boolean</code></p><pre><code class="ts">let isDone: boolean = false;</code></pre><p>注意，使用构造函数 <strong>Boolean</strong> 创造的对象不是布尔值：</p><pre><code class="ts">let createdByNewBoolean: boolean = new Boolean(1); // 会报错的，是一个Boolean对象let createdByNewBoolean: boolean = Boolean(1); // 通过，是一个boolean</code></pre><blockquote><p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p></blockquote><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p><code>number</code></p><pre><code class="ts">let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;</code></pre><blockquote><p>编译完会自动转成十进制</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>string</code></p><pre><code class="ts">let myName: string = &#39;Tom&#39;;let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is ${myName}.I&#39;ll be ${myAge + 1} years old next month.`;</code></pre><blockquote><p>编译完模板字符串会变成加号串联的形式，自动加<code>/n</code></p></blockquote><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p><code>void</code></p><p><strong>JavaScript</strong> 没有空值（Void）的概念，在 <strong>TypeScript</strong> 中，可以用 <code>void</code> 表示没有任何返回值的函数：</p><pre><code class="ts">function alertName(): void {    alert(&#39;My name is Tom&#39;);}</code></pre><blockquote><p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code></p></blockquote><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p><code>null undefined</code></p><pre><code class="ts">let u: undefined = undefined;let n: null = null;</code></pre><blockquote><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给其他类型的变量，但是反过来 <code>void</code> 不能赋值给任何类型的变量</p></blockquote><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p><code>any</code><br>如果是一个普通类型，在赋值中改变类型是不被允许的。</p><p>但是如果是<code>any</code>类型，则允许被赋值为任意类型</p><pre><code class="ts">let myFavoriteNumber: any = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><blockquote><p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p></blockquote><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</p><pre><code class="ts">let something;something = &#39;seven&#39;;something = 7;something.setName(&#39;Tom&#39;);</code></pre><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果变量在定义的时候赋值，但是没指定类型，会自动进行推论</p><pre><code class="ts">let myFavoriteNumber = &#39;seven&#39;;// 等价于let myFavoriteNumber: string = &#39;seven&#39;;myFavoriteNumber = 7; // 会报错</code></pre><blockquote><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查：</p></blockquote><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型使用 | 分隔每个类型。</p><pre><code class="ts">let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;; // okmyFavoriteNumber = 7; // okmyFavoriteNumber = true; // 会报错</code></pre><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p><pre><code class="ts">function getLength(something: string | number): number {    return something.length; // 会报错，.length不是string和number共有的属性    return something.toString(); // ok}</code></pre><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p><pre><code class="ts">let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;;console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 会报错</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><pre><code class="ts">interface IPerson {    name: string;    age: number;}let tom: IPerson = {    name: &#39;Tom&#39;,    age: 25};</code></pre><p>接口一般首字母大写，有的编程语言会建议接口的名称加上<code>I</code>前缀</p><p>定义的变量比接口多属性少属性都是不允许的，<strong>赋值的时候，变量的形状必须和接口的形状保持一致。</strong></p><ul><li>可选属性</li></ul><p><strong>可选属性的含义是该属性可以不存在</strong>，这时<strong>仍然不允许添加未定义的属性</strong></p><pre><code class="ts">interface Person {    name: string;    age?: number;}let tom: Person = {    name: &#39;Tom&#39;,    gender: &#39;male&#39; // 这句就会报错，因为出现了未加定义的属性};</code></pre><ul><li>任意属性</li></ul><p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是<strong>它的类型的子集</strong></p><pre><code class="ts">interface Person {    name: string;    age?: number;    [propName: string]: string;}let tom: Person = {    name: &#39;Tom&#39;,    age: 25, // 这句就会报错，因为不是string，即使上边定义age是number也不行    gender: &#39;male&#39;,};interface Person {    name: string;    age?: number;    [propName: string]: string | number; // 接口定义成这样使用联合类型age就不会报错了}</code></pre><ul><li>只读属性</li></ul><p>一些字段只能在创建的时候被赋值</p><pre><code class="ts">interface Person {    readonly id: number;    name: string;    age?: number;    [propName: string]: any;}let tom: Person = {    id: 89757,    name: &#39;Tom&#39;,    gender: &#39;male&#39;};tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre><blockquote><p>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</p></blockquote><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><ul><li><p>「类型 + 方括号」表示法</p><pre><code class="ts">let fibonacci: number[] = [1, 1, 2, 3, 5];</code></pre><blockquote><p>数组的项中<strong>不允许</strong>出现其他的类型<br>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制,如果约定是<code>number</code>类型,<strong>push</strong>一个<code>string</code>类型就会报错</p></blockquote></li><li><p>数组泛型</p><pre><code class="ts">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre></li><li><p>用接口表示数组<br><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p><pre><code class="ts">interface NumberArray {  [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre></li><li><p>类数组<br>类数组（Array-like Object）不是数组类型，比如 arguments：</p><pre><code class="ts">function sum() {  let args: {      [index: number]: number;      length: number;      callee: Function;  } = arguments;}</code></pre></li><li><p>any 在数组中的应用<br>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p><pre><code class="ts">let list: any[] = [&#39;xcatliu&#39;, 25, { website: &#39;http://xcatliu.com&#39; }];</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa学习笔记</title>
    <link href="undefined2020/04/js-koa/"/>
    <url>2020/04/js-koa/</url>
    
    <content type="html"><![CDATA[<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>cnpm install koa --save</code></pre><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h2><pre><code class="js">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use(async ctx =&gt; {  ctx.body = &#39;Hello World&#39;;});app.listen(3000);</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>使用yield以及next,当一个中间件调用<code>next()</code>函数时，函数挂起并控件传递给定义的下一个中间件。在没有更多的中间件执行下游之后，堆栈将退出，并且每个中间件被恢复以执行其上游行为。</p><pre><code class="js">const Koa = require(&#39;koa&#39;);const app = new Koa();const one = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; one&#39;);  next();  console.log(&#39;&lt;&lt; one&#39;);}const two = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; two&#39;);  next();  console.log(&#39;&lt;&lt; two&#39;);}const three = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; three&#39;);  next();  console.log(&#39;&lt;&lt; three&#39;);}app.use(one);app.use(two);app.use(three);app.listen(3000);/*&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one*/</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>应用配置是 app 实例属性，目前支持的配置项如下</p><ul><li>app.env node运行环境，默认为 NODE_ENV or “development”</li><li>app.proxy 表示是否开启代理信任开关,默认为false，如果为 true，则解析 “Host” 的 header 域，对于获取request请求中的host，protocol，ip分别优先从Header字段中的<a href="https://cloud.tencent.com/developer/section/1190030" target="_blank" rel="noopener">X-Forwarded-Host</a>，X-Forwarded-Proto，X-Forwarded-For获取</li><li>app.subdomainOffset 表示子域名是从第几级开始的，这个参数决定了request.subdomains的返回结果，默认值为2，表示 .subdomains 所忽略的字符偏移量。<pre><code class="js">//比如有netease.youdata.163.com域名app.subdomainOffset = 2;console.log(ctx.request.subdomains);  //返回[&quot;youdata&quot;, &quot;netease&quot;]app.subdomainOffset = 3;console.log(ctx.request.subdomains);  //返回[&quot;netease&quot;]//koa获取subdomains的源码get subdomains() {    const offset = this.app.subdomainOffset;    const hostname = this.hostname;    if (net.isIP(hostname)) return [];    return hostname    .split(&#39;.&#39;)    .reverse()    .slice(offset);}</code></pre></li></ul><h2 id="app-listen-…"><a href="#app-listen-…" class="headerlink" title="app.listen(…)"></a>app.listen(…)</h2><p><code>app.listen(...)</code> 实际上是以下代码的语法糖</p><pre><code class="js">http.createServer(app.callback()).listen(3000);</code></pre><p>这意味着您可以同时支持 <strong>HTTP</strong> 和 <strong>HTTPS</strong>，或者在多个端口监听同一个应用</p><pre><code class="js">const http = require(&#39;http&#39;);const https = require(&#39;https&#39;);const Koa = require(&#39;koa&#39;);const app = new Koa();http.createServer(app.callback()).listen(3000);https.createServer(app.callback()).listen(3001);</code></pre><h2 id="app-callback"><a href="#app-callback" class="headerlink" title="app.callback()"></a>app.callback()</h2><p>返回一个适合 <code>http.createServer()</code> 方法的回调函数用来处理请求。 您也可以使用这个回调函数将您的app挂载在 Connect/Express 应用上。</p><pre><code class="js">//koa的callback函数实现源码function callback() {      const fn = compose(this.middleware);   //koa-compose包负责将多个中间件组装成一个中间件  if (!this.listeners(&#39;error&#39;).length) this.on(&#39;error&#39;, this.onerror);      const handleRequest = (req, res) =&gt; {          const ctx = this.createContext(req, res);  //这个函数负责生成中间件接收器ctx，绑定一些对象的关联关系      return this.handleRequest(ctx, fn);  //使用中间件函数fn处理路由请求    };        return handleRequest;  }  //handleRequest函数的源码实现也很简单，执行中间件函数，并做一些返回处理和异常处理  function handleRequest(ctx, fnMiddleware) {        const res = ctx.res;    res.statusCode = 404;        const onerror = err =&gt; ctx.onerror(err);        const handleResponse = () =&gt; respond(ctx);    onFinished(res, onerror);        return fnMiddleware(ctx).then(handleResponse).catch(onerror);  }</code></pre><h2 id="app-use-function"><a href="#app-use-function" class="headerlink" title="app.use(function)"></a>app.use(function)</h2><p>use函数主要作用是给app.middleware数组中添加中间件</p><h2 id="app-keys"><a href="#app-keys" class="headerlink" title="app.keys="></a>app.keys=</h2><p>该密钥会被传递给KeyGrip, 当然，您也可以自己生成 KeyGrip. 例如:</p><pre><code class="js">app.keys = [&#39;im a newer secret&#39;, &#39;i like turtle&#39;];app.keys = new KeyGrip([&#39;im a newer secret&#39;, &#39;i like turtle&#39;], &#39;sha256&#39;);</code></pre><p>在进行cookie签名时，只有设置 signed 为 true 的时候，才会使用密钥进行加密：</p><pre><code class="js">ctx.cookies.set(&#39;name&#39;, &#39;tobi&#39;, { signed: true });</code></pre><h2 id="app-context"><a href="#app-context" class="headerlink" title="app.context"></a>app.context</h2><p>app.context是从中创建ctx的原型。 可以通过编辑app.context向ctx添加其他属性。当需要将ctx添加到整个应用程序中使用的属性或方法时，这将会非常有用。这可能会更加有效（不需要中间件）和/或更简单（更少的require()），而不必担心更多的依赖于ctx，这可以被看作是一种反向模式。</p><p>例如，从ctx中添加对数据库的引用：</p><pre><code class="js">app.context.db = db();app.use(async ctx =&gt; {  console.log(ctx.db);});</code></pre><blockquote><p>ctx上的很多属性是被限制的，在app.context只能通过使用Object.defineProperty()来编辑这些属性（不推荐）。可以在 <a href="https://github.com/koajs/koa/issues/652上查阅" target="_blank" rel="noopener">https://github.com/koajs/koa/issues/652上查阅</a><br>已安装的APP沿用父级的ctx和配置。因此，安装的应用程序只是一组中间件。</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>默认情况下Koa会将所有错误信息输出到 stderr， 除非 app.silent 是 true.当err.status是404或者err.expose时，默认错误处理程序也不会输出错误。要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个”错误”事件侦听器：</p><pre><code class="js">app.on(&#39;error&#39;, err =&gt; {  log.error(&#39;server error&#39;, err)});</code></pre><p>如果错误发生在 请求/响应 环节，并且其不能够响应客户端时，Contenxt 实例也会被传递到 error 事件监听器的回调函数里。</p><pre><code class="js">app.on(&#39;error&#39;, (err, ctx) =&gt; {  log.error(&#39;server error&#39;, err, ctx)});</code></pre><p>当发生错误但仍能够响应客户端时（比如没有数据写到socket中），Koa会返回一个500错误(Internal Server Error)。 无论哪种情况，Koa都会生成一个应用级别的错误信息，以便实现日志记录等目的。</p><h1 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context(上下文)"></a>Context(上下文)</h1><p>在每个<code>requset</code>请求中被创建，在中间件中作为接收器(receiver)来引用</p><pre><code class="js">app.use(async ctx =&gt; {  ctx; // is the Context  ctx.request; // is a koa Request  ctx.response; // is a koa Response});</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Context 详细的方法和访问器。</p><h3 id="ctx-req"><a href="#ctx-req" class="headerlink" title="ctx.req"></a>ctx.req</h3><p><strong>Node</strong> 的 request 对象。</p><h3 id="ctx-res"><a href="#ctx-res" class="headerlink" title="ctx.res"></a>ctx.res</h3><p><strong>Node</strong> 的 response 对象</p><blockquote><p>Koa 不支持 直接调用底层 res 进行响应处理。请避免使用以下 node 属性：<br>res.statusCode<br>res.writeHead()<br>res.write()<br>res.end()</p></blockquote><h3 id="ctx-request"><a href="#ctx-request" class="headerlink" title="ctx.request"></a>ctx.request</h3><p><strong>Koa</strong> 的 Request 对象。</p><h3 id="ctx-response"><a href="#ctx-response" class="headerlink" title="ctx.response"></a>ctx.response</h3><p><strong>Koa</strong> 的 Response 对象。</p><h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>推荐的命名空间，用于通过中间件传递信息到前端视图<code>ctx.state.user = await User.find(id);</code></p><h3 id="ctx-app"><a href="#ctx-app" class="headerlink" title="ctx.app"></a>ctx.app</h3><p>应用实例引用。</p><h3 id="ctx-cookies-get-name-options"><a href="#ctx-cookies-get-name-options" class="headerlink" title="ctx.cookies.get(name, [options])"></a>ctx.cookies.get(name, [options])</h3><p>获得 <strong>cookie</strong> 中名为 <strong>name</strong> 的值，options 为可选参数;signed 如果为 true，表示请求时 cookie 需要进行签名。</p><blockquote><p>注意：Koa 使用了 Express 的 cookies 模块，options 参数只是简单地直接进行传递。</p></blockquote><h3 id="ctx-cookies-set-name-value-options"><a href="#ctx-cookies-set-name-value-options" class="headerlink" title="ctx.cookies.set(name, value, [options])"></a>ctx.cookies.set(name, value, [options])</h3><p>设置 cookie 中名为 name 的值，options 为可选参数：</p><ul><li>maxAge 一个数字，表示 Date.now()到期的毫秒数</li><li>signed 是否要做签名</li><li>expires cookie有效期</li><li>pathcookie 的路径，默认为 ‘/‘</li><li>domain cookie 的域</li><li>secure false 表示 cookie 通过 HTTP 协议发送，true 表示 cookie 通过 HTTPS 发送。</li><li>httpOnly true 表示 cookie 只能通过 HTTP 协议发送</li><li>overwrite 一个布尔值，表示是否覆盖以前设置的同名的Cookie（默认为false）。 如果为true，在设置此cookie时，将在同一请求中使用相同名称（不管路径或域）设置的所有Cookie将从Set-Cookie头部中过滤掉。</li></ul><h3 id="ctx-throw-status-msg-properties"><a href="#ctx-throw-status-msg-properties" class="headerlink" title="ctx.throw([status], [msg], [properties])"></a>ctx.throw([status], [msg], [properties])</h3><p>抛出包含 .status 属性的错误，默认为 500。该方法可以让 Koa 准确的响应处理状态。 Koa支持以下组合： </p><pre><code class="js">ctx.throw(400);ctx.throw(400, &#39;name required&#39;);ctx.throw(400, &#39;name required&#39;, { user: user });//该对象被合并到错误中，这对装饰机器友好错误非常有用，并且这些错误会被报给上层请求。</code></pre><p>this.throw(‘name required’, 400) 等价于：</p><pre><code class="js">const err = new Error(&#39;name required&#39;);err.status = 400;err.expose = true;throw err;</code></pre><blockquote><p>注意：这些用户级错误被标记为 err.expose，其意味着这些消息被准确描述为对客户端的响应，而并非使用在您不想泄露失败细节的场景中。</p></blockquote><h3 id="ctx-assert-value-status-msg-properties"><a href="#ctx-assert-value-status-msg-properties" class="headerlink" title="ctx.assert(value, [status], [msg], [properties])"></a>ctx.assert(value, [status], [msg], [properties])</h3><p>当!value时， Helper 方法抛出一个类似.throw()的错误。 类似node’s assert() 方法。 </p><pre><code class="js">ctx.assert(ctx.state.user, 401, &#39;User not found. Please login!&#39;);</code></pre><p>koa 使用 <a href="https://github.com/jshttp/http-assert" target="_blank" rel="noopener">http-assert</a> 来<a href="https://www.runoob.com/w3cnote/c-assert.html" target="_blank" rel="noopener">断言</a>。</p><h3 id="ctx-respond"><a href="#ctx-respond" class="headerlink" title="ctx.respond"></a>ctx.respond</h3><p>为了避免使用 Koa 的内置响应处理功能，您可以直接赋值 this.repond = false;。如果您不想让 Koa 来帮助您处理 reponse，而是直接操作原生 res 对象，那么请使用这种方法。</p><blockquote><p>注意： 这种方式是不被 Koa 支持的。其可能会破坏 Koa 中间件和 Koa 本身的一些功能。其只作为一种 hack 的方式，并只对那些想要在 Koa 方法和中间件中使用传统 fn(req, res) 方法的人来说会带来便利。</p></blockquote><h3 id="Request-aliases"><a href="#Request-aliases" class="headerlink" title="Request aliases"></a>Request aliases</h3><p>ctx会代理ctx.response和ctx.request上的一些属性和函数(这个代理逻辑是在ctx.response和ctx.request的原型上实现的)</p><pre><code class="js">//以下是koa源码（method表示代理方法，access表示代理属性可读可写，getter表示代理属性可读）：delegate(proto, &#39;response&#39;)  .method(&#39;attachment&#39;) //将Content-Disposition 设置为 “附件” 以指示客户端提示下载  .method(&#39;redirect&#39;) //返回重定向，如果没有code设置，默认设置code为302  /*    // 字符串 &quot;back&quot; 是一个特殊参数，其提供了 Referrer 支持。当没有Referrer时，使用 alt 或者 / 代替。    ctx.redirect(&#39;back&#39;);    ctx.redirect(&#39;back&#39;, &#39;/index.html&#39;);    ctx.redirect(&#39;/login&#39;);    ctx.redirect(&#39;http://google.com&#39;);  */  .method(&#39;remove&#39;)   //删除响应头的某个属性  .method(&#39;vary&#39;)  //设置Vary响应头  .method(&#39;set&#39;) //设置响应头，可以传递对象，数组，单个值的形式  .method(&#39;append&#39;) //给response.headers中的某个key值追加其它value  .method(&#39;flushHeaders&#39;)  //执行this.res.flushHeaders()  .access(&#39;status&#39;)  //http返回code码，优先选择用户的设置，如果用户没有主动设置，而设置了ctx.body的值， 如果设置值为null，则返回204，如果设置值不为null，那么返回200，否则默认情况下是404  .access(&#39;message&#39;)  //获取响应的状态消息. 默认情况下, response.message 与 response.status 关联  .access(&#39;body&#39;)   //response的返回结果  .access(&#39;length&#39;)  //response的headers的Content-Length，可以自己设置，默认根据body二进制大小设置  .access(&#39;type&#39;)   //设置响应的content-type  .access(&#39;lastModified&#39;)  //设置响应头Last-Modified  .access(&#39;etag&#39;)  //设置包含 &quot; 包裹的 ETag 响应头  .getter(&#39;headerSent&#39;)  //检查是否已经发送了一个响应头。 用于查看客户端是否可能会收到错误通知  .getter(&#39;writable&#39;);   //返回是否可以继续写入delegate(proto, &#39;request&#39;)  .method(&#39;acceptsLanguages&#39;)  .method(&#39;acceptsEncodings&#39;)  .method(&#39;acceptsCharsets&#39;)  .method(&#39;accepts&#39;)        //accepts函数用于判断客户端请求是否接受某种返回类型  .method(&#39;get&#39;)   //获取请求头中的某个属性值  .method(&#39;is&#39;)  //判断请求头希望返回什么类型  /*    检查请求所包含的 &quot;Content-Type&quot; 是否为给定的 type 值。 如果没有 request body，返回 undefined。 如果没有 content type，或者匹配失败，返回 false。 否则返回匹配的 content-type。    // With Content-Type: text/html; charset=utf-8    ctx.is(&#39;html&#39;); // =&gt; &#39;html&#39;    ctx.is(&#39;text/html&#39;); // =&gt; &#39;text/html&#39;    ctx.is(&#39;text/*&#39;, &#39;text/html&#39;); // =&gt; &#39;text/html&#39;    // When Content-Type is application/json    ctx.is(&#39;json&#39;, &#39;urlencoded&#39;); // =&gt; &#39;json&#39;    ctx.is(&#39;application/json&#39;); // =&gt; &#39;application/json&#39;    ctx.is(&#39;html&#39;, &#39;application/*&#39;); // =&gt; &#39;application/json&#39;    ctx.is(&#39;html&#39;); // =&gt; false    //比如说您希望保证只有图片发送给指定路由    if (ctx.is(&#39;image/*&#39;)) {      // process    } else {      ctx.throw(415, &#39;images only!&#39;);    }  */  .access(&#39;querystring&#39;) //获取原始查询字符串  .access(&#39;idempotent&#39;)  .access(&#39;socket&#39;) //返回请求套接字  .access(&#39;search&#39;) //搜索字符串  .access(&#39;method&#39;)  //请求方法  .access(&#39;query&#39;)  //获取请求的查询字符串对象  .access(&#39;path&#39;)  //获取请求路径名  .access(&#39;url&#39;)  //请求的url,该url可以被重写  .getter(&#39;origin&#39;)  //获取url的来源：包括 protocol 和 host（http://example.com）  .getter(&#39;href&#39;) //获取完整的请求URL，包括 protocol，host 和 url（http://example.com/foo/bar?q=1）  .getter(&#39;subdomains&#39;) //以数组形式返回子域名    /* 举例来说，如果域名是 &quot;tobi.ferrets.example.com&quot;:    如果没有设置 app.subdomainOffset，其 subdomains 为 [&quot;ferrets&quot;, &quot;tobi&quot;]。 如果设置 app.subdomainOffset 为3，其 subdomains 为 [&quot;tobi&quot;]  */  .getter(&#39;protocol&#39;) //返回请求协议  .getter(&#39;host&#39;) //获取当前主机的host(hostname:port)  .getter(&#39;hostname&#39;) //获取当前主机的host  .getter(&#39;URL&#39;) //获取 WHATWG 解析的 URL 对象  .getter(&#39;header&#39;) //返回请求头对象  .getter(&#39;headers&#39;)  //返回请求头对象  .getter(&#39;secure&#39;) //通过 ctx.protocol == &quot;https&quot; 来检查请求是否通过 TLS 发出  .getter(&#39;stale&#39;)   .getter(&#39;fresh&#39;) //检查请求缓存是否 &quot;fresh&quot;(内容没有发生变化)。该方法用于在 If-None-Match / ETag, If-Modified-Since 和 Last-Modified 中进行缓存协调。当在 response headers 中设置一个或多个上述参数后，该方法应该被使用。  .getter(&#39;ips&#39;)  //当 X-Forwarded-For 存在并且 app.proxy 被启用时，这些 ips 的数组被返回  .getter(&#39;ip&#39;); //请求远程地址//比如以下操作是等价的：ctx.body = {  code: 200,  result: {      nick: &quot;zhangdianpeng&quot;  }}ctx.response.body = {    code: 200,    result: {        nick: &quot;zhangdianpeng&quot;    }}console.log(&#39;ctx.method:&#39;, ctx.method);console.log(&#39;ctx.request.method:&#39;, ctx.request.method);/*作者：网易云社区链接：https://www.jianshu.com/p/20cf1c476d22来源：简书改进：RainSun*/</code></pre><h1 id="使用Make构建网站"><a href="#使用Make构建网站" class="headerlink" title="使用Make构建网站"></a>使用Make构建网站</h1><p><a href="http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html" target="_blank" rel="noopener">阮一峰教程</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>Web后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b安装aria2</title>
    <link href="undefined2020/04/pi-aria2/"/>
    <url>2020/04/pi-aria2/</url>
    
    <content type="html"><![CDATA[<h1 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h1><h2 id="安装aria2"><a href="#安装aria2" class="headerlink" title="安装aria2"></a>安装<code>aria2</code></h2><pre><code>sudo apt-get install aria2</code></pre><h2 id="配置aria2的文件"><a href="#配置aria2的文件" class="headerlink" title="配置aria2的文件"></a>配置<code>aria2</code>的文件</h2><pre><code>mkdir ~/.aria2touch ~/.aria2/aria2.sessionmkdir /home/pi/data/aria2mkdir /home/pi/data/aria2/downloadnano ~/.aria2/aria2.conf</code></pre><p><code>conf</code>文件里边写</p><pre><code>dir=/home/pi/data/aria2/downloaddisable-ipv6=trueenable-rpc=truerpc-allow-origin-all=truerpc-listen-all=truecontinue=trueinput-file=/home/pi/.aria2/aria2.sessionsave-session=/home/pi/.aria2/aria2.session max-concurrent-downloads=5save-session-interval=60peer-id-prefix=-TR2770-user-agent=Transmission/2.77bt-seed-unverified=truebt-save-metadata=true</code></pre><p>测试运行看看有没有错误</p><pre><code>aria2c –conf-path=/home/pi/.aria2/aria2.conf</code></pre><p>把它做成系统服务</p><pre><code>sudo nano /etc/init.d/aria2c</code></pre><p>输入</p><pre><code>#!/bin/sh### BEGIN INIT INFO# Provides:          aria2# Required-Start:    $remote_fs $network# Required-Stop:     $remote_fs $network# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: Aria2 Downloader### END INIT INFOcase &quot;$1&quot; instart)echo -n &quot;Starting aria2c&quot;sudo -u pi aria2c --conf-path=/home/pi/.aria2/aria2.conf -D;;stop)echo -n &quot;Shutting down aria2c &quot;killall aria2c;;restart)killall aria2csudo -u pi aria2c --conf-path=/home/pi/.aria2/aria2.conf -D;;esacexit</code></pre><h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><pre><code>sudo chmod 755 /etc/init.d/aria2c</code></pre><h2 id="测试服务是否能启动"><a href="#测试服务是否能启动" class="headerlink" title="测试服务是否能启动"></a>测试服务是否能启动</h2><pre><code>sudo service aria2c start</code></pre><p>报错就再输入一句</p><pre><code>sudo update-rc.d aria2c defaults</code></pre><h2 id="添加aria2c服务自动运行"><a href="#添加aria2c服务自动运行" class="headerlink" title="添加aria2c服务自动运行"></a>添加aria2c服务自动运行</h2><pre><code>sudo update-rc.d aria2c defaults</code></pre><h2 id="进文件夹下载yaaw"><a href="#进文件夹下载yaaw" class="headerlink" title="进文件夹下载yaaw"></a>进文件夹下载yaaw</h2><pre><code>cd data/aria2git clone http://github.com/wzhy90/yaaw</code></pre><p>之后就在teaweb里边设置代理就ok</p>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>aria2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>aria2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记</title>
    <link href="undefined2020/04/docker/"/>
    <url>2020/04/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>查看全部网桥</p><pre><code>docker network ls</code></pre><p>查看某个网桥</p><pre><code>docker network inspect &lt;name&gt;</code></pre><p>创建一个名为<code>lacus</code>的网桥</p><pre><code>docker network create --driver bridge lacus</code></pre><p>允许指定网段 上一句指定参数在名之前</p><pre><code>--subnet 172.22.16.0/24 --gateway 172.22.16.1</code></pre><p>删除<code>lacus</code>网桥</p><pre><code>docker network rm lacus</code></pre><p>连接到<code>lacus</code>网桥</p><pre><code>--network=lacus</code></pre><hr><h2 id="容器间通信的三种方式"><a href="#容器间通信的三种方式" class="headerlink" title="容器间通信的三种方式"></a>容器间通信的三种方式</h2><p><strong>IP通信</strong></p><p>只要放在了一个网桥下就可以通过ip进行访问了</p><p><strong>Docker DNS Server</strong></p><p>docker内嵌了DNS Server，只要使用<code>--name=&lt;name&gt;</code>指定容器名并且绑定在一个网桥中就可以使用名字<code>ping -c 3 name</code>连通</p><blockquote><p>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。</p></blockquote><p><strong>joined 容器</strong></p><p>通过<code>--network=container:&lt;name&gt;</code>指定<code>jointed</code>容器</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运行portainer</strong></p><pre><code>docker run -d -p 127.0.0.1:5001:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer  portainer/portainer</code></pre><p><strong>运行mongodb</strong></p><pre><code>// pidocker run -d --name mongo -v /home/pi/db/mongo:/data/db -p 27017:27017 --restart=always --network=lacus casualsimulation/rpi-mongodb3 mongod --auth// aldocker run -d --name mongo -v /root/db/mongo:/data/db -p 127.0.0.1:5000:27017 --restart=always --network=lacus mongo mongod --auth</code></pre><p><strong>打包</strong></p><pre><code>// al tracer_backenddocker build -t lacus/tracer_backend:1.0 .// al tracer_userdocker build -t lacus/tracer_user:1.0 .// al tracer_admindocker build -t lacus/tracer_admin:1.0 .// al canary_backenddocker build -t lacus/canary_backend:1.0 .// al canary_frontenddocker build -t lacus/canary_frontend:1.0 .// al cherry_backenddocker build -t lacus/cherry_backend:1.0 .// al cherry_frontenddocker build -t lacus/cherry_frontend:1.0 .</code></pre><p><strong>运行</strong></p><pre><code>// al tracer_backenddocker run -it --name tracer_backend -v /root/data/tracer/backEnd/logs:/app/logs -v /root/data/tracer/backEnd/upload:/app/upload -p 127.0.0.1:5002:80 --network=lacus lacus/tracer_backend:1.0 /bin/sh// al tracer_userdocker run -d --name tracer_user -p 127.0.0.1:5003:80 --restart=always --network=lacus lacus/tracer_user:1.0// al tracer_admindocker run -d --name tracer_admin -p 127.0.0.1:5004:80 --restart=always --network=lacus lacus/tracer_admin:1.0// al canary_backenddocker run -it --name canary_backend -v /root/data/canary/backEnd/logs:/app/logs -p 127.0.0.1:5005:80 --network=lacus lacus/canary_backend:1.0 /bin/sh// al canary_frontenddocker run -d --name canary_frontend -p 127.0.0.1:5006:80 --restart=always --network=lacus lacus/canary_frontend:1.0// al cherry_backenddocker run -it --name cherry_backend -v /root/data/cherry/backEnd/logs:/app/logs -p 127.0.0.1:5007:80 --network=lacus lacus/cherry_backend:1.0 /bin/sh// al cherry_frontenddocker run -d --name cherry_frontend -p 127.0.0.1:5008:80 --restart=always --network=lacus lacus/cherry_frontend:1.0// pi ccb frontEnddocker run -d --name ccb_frontend -p 127.0.0.1:5003:80 --restart=always --network=lacus lacus/ccb_frontend:1.0// pi ccb backEnddocker run -it --name ccb -v /home/pi/data/ccb/docker/logs:/app/logs -p 127.0.0.1:5002:80 --restart=always --network=lacus lacus/ccb_backend:1.0 /bin/sh// vueview docker run  -d --name canary_frontEnd -p 127.0.0.1:5006:80 --restart=always -v /root/data/canary/frontEnd:/vue lacus/vueview // flask_env docker run -it --name phonebook_backend -p 127.0.0.1:5011:80 -v /root/data/phonebook/backEnd:/app --network=lacus lacus/flask_env /bin/sh // blog docker run -d --name blog -v /root/data/blog/blog:/usr/share/nginx/html -p 127.0.0.1:5019:80 --network=lacus lacus/blog:1.0</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器初始化</title>
    <link href="undefined2020/03/init-centos/"/>
    <url>2020/03/init-centos/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h1><p>因为是阿里的服务器，装的centos8，已经自己换好阿里的镜像源了，很nice<br>更新<code>yum</code></p><pre><code>sudo yum -y update</code></pre><p>Todo</p><ol><li><input checked="" disabled="" type="checkbox"> nginx</li><li><input checked="" disabled="" type="checkbox"> mongodb </li><li><input checked="" disabled="" type="checkbox"> docker</li><li><input checked="" disabled="" type="checkbox"> htop<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2>使用<code>yum</code>安装<pre><code>sudo yum -y install nginx   # 安装 nginxsudo yum remove nginx  # 卸载 nginx</code></pre>配置<code>nginx</code>服务<pre><code>sudo systemctl enable nginx # 设置开机启动sudo service nginx start # 启动nginx服务sudo service nginx stop # 停止nginx服务sudo service nginx restart # 重启nginx服务sudo service nginx reload # 重新加载配置，一般是在修改过nginx配置文件时使用</code></pre><h2 id="安装htop"><a href="#安装htop" class="headerlink" title="安装htop"></a>安装htop</h2>使用<code>yum</code>安装<pre><code>yum install epel-release -yyum install htop -y</code></pre><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">网页链接</a><br>如果报错<code>package docker-ce-3:19.03.8-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of the providers can be installed</code><br>就执行以下命令<pre><code>dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmsudo yum install docker-ce docker-ce-clisudo systemctl start docker</code></pre><h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2>使用<code>docker</code>安装<pre><code>docker run -d --name mongo -v /root/db/mongo:/data/db -p 127.0.0.1:5000:27017 --network=lacus mongo mongod --auth</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>部署新服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongoDB学习笔记</title>
    <link href="undefined2019/11/mongodb/"/>
    <url>2019/11/mongodb/</url>
    
    <content type="html"><![CDATA[<h1 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h1><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><pre><code class="js">db.createUser(  {    user: &quot;yingbo&quot;,    pwd: &quot;&quot;,    roles: [ { role: &quot;dbAdmin&quot;, db: &quot;yingbo&quot; },{ role: &#39;readWrite&#39;, db: &quot;yingbo&quot;} ]  })db.createUser(  {    user: &quot;admin&quot;,    pwd: &quot;&quot;,    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]  })</code></pre><h3 id="log目录-var-log-mongodb-mongod-log"><a href="#log目录-var-log-mongodb-mongod-log" class="headerlink" title="log目录 /var/log/mongodb/mongod.log"></a>log目录 <code>/var/log/mongodb/mongod.log</code></h3><h3 id="db目录-var-lib-mongo"><a href="#db目录-var-lib-mongo" class="headerlink" title="db目录 /var/lib/mongo"></a>db目录 <code>/var/lib/mongo</code></h3><h3 id="配置文件-etc-mongod-conf"><a href="#配置文件-etc-mongod-conf" class="headerlink" title="配置文件 /etc/mongod.conf"></a>配置文件 <code>/etc/mongod.conf</code></h3><h3 id="启动-重启-停止-sudo-service-mongod-start-restart-stop"><a href="#启动-重启-停止-sudo-service-mongod-start-restart-stop" class="headerlink" title="启动/重启/停止  sudo service mongod start/restart/stop"></a>启动/重启/停止  <code>sudo service mongod start/restart/stop</code></h3><h3 id="开启用户认证-conf-文件加"><a href="#开启用户认证-conf-文件加" class="headerlink" title="开启用户认证 conf 文件加"></a>开启用户认证 conf 文件加</h3><pre><code>security:  authorization: enabled</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre><code class="c">//方法一mongo --port 12236 -u &quot;admin&quot; -p &quot;&quot; --authenticationDatabase &quot;admin&quot;//方法二db.auth(&quot;yingbo&quot;, &quot;&quot;)</code></pre><h3 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h3><p><code>show dbs</code></p><h3 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h3><pre><code>use &lt;dbname&gt;db.dropDatabase()</code></pre><h3 id="显示所有集合"><a href="#显示所有集合" class="headerlink" title="显示所有集合"></a>显示所有集合</h3><p><code>show tables</code> 或者 <code>show collections</code></p><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><pre><code class="js">//正常情况下直接插入数据就可以自动新建一个集合//创建固定集合 mycol，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。db.createCollection(&quot;&lt;collectionName&gt;&quot;, { capped : true, autoIndexId : true, size :    6142800, max : 10000 } )//单纯的新建一个集合db.createCollection(&quot;&lt;collectionName&gt;&quot;)</code></pre><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><p><code>db.&lt;collectionName&gt;.drop()</code></p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><code>db.&lt;collectionName&gt;.insert(&lt;object&gt;)</code></p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><code>db.&lt;collectionName&gt;.remove({key:value})</code> find里边可以为{}删除全部</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code>db.&lt;collectionName&gt;.update(   &lt;query&gt;,   &lt;update&gt;,   {     upsert: &lt;boolean&gt;,     multi: &lt;boolean&gt;,     writeConcern: &lt;document&gt;   })/*    query : update的查询条件，类似sql update查询内where后面的。    update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的    upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。    multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。    writeConcern :可选，抛出异常的级别。*/</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><code>db.&lt;collectionName&gt;.find({key:value})</code> find里边可以没有参数</p><pre><code>//格式化显示db.col.find().pretty()//条件语句db.col.find({likes : {$lt :200, $gt : 100}}).pretty() //限制 100&lt;likes&lt;200$lt:小于$lte:小于或等于$gt:大于$gte:大于或等于$ne: 不等于$type:     Double     1          String     2          Object     3          Array     4          Binary data     5          Undefined     6     已废弃。    Object id     7          Boolean     8          Date     9          Null     10          Regular Expression     11          JavaScript     13          Symbol     14          JavaScript (with scope)     15          32-bit integer     16          Timestamp     17          64-bit integer     18          Min key     255     Query with -1.    Max key     127//ANDdb.col.find({key1:value1, key2:value2}).pretty()//ORdb.col.find({$or:[{&quot;by&quot;:&quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()//AND+ORdb.col.find({&quot;likes&quot;: {$gt:50}, $or: [{&quot;by&quot;: &quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()// 排除某个字段，例如_iddb.col.find({},{&quot;_id&quot;: 0})// 指定返回某几个字段db.col.find({},{&quot;name&quot;: 1, &quot;sex&quot;: 1})</code></pre><hr><h2 id="Limit与Skip方法"><a href="#Limit与Skip方法" class="headerlink" title="Limit与Skip方法"></a>Limit与Skip方法</h2><p><code>db.&lt;collectionName&gt;.find().limit(&lt;number1&gt;).skip(&lt;number2&gt;)</code></p><p>number1 : 本次查询最多显示条数</p><p>number2 : 本次查询跳过的条数</p><hr><h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort() 方法"></a>sort() 方法</h2><p><code>db.&lt;collectionName&gt;.find().sort({&lt;key&gt;:&lt;number&gt;})</code></p><p>key : 需要进行排序的键名</p><p>number : 其中 1 为升序排列，而 -1 是用于降序排列</p><hr><h2 id="createIndex-方法"><a href="#createIndex-方法" class="headerlink" title="createIndex() 方法"></a>createIndex() 方法</h2><p><code>db.values.createIndex({&lt;key&gt;: &lt;number&gt;, &lt;key&gt;: &lt;number&gt;}, {background: true})</code></p><p>key : 需要进行排序的键名</p><p>number : 其中 1 为升序排列，而 -1 是用于降序排列</p><p>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。</p><hr><h2 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h2><pre><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}]){   &quot;result&quot; : [      {         &quot;_id&quot; : &quot;runoob.com&quot;,         &quot;num_tutorial&quot; : 2      },      {         &quot;_id&quot; : &quot;Neo4j&quot;,         &quot;num_tutorial&quot; : 1      }   ],   &quot;ok&quot; : 1}</code></pre><p>$sum    计算总和。    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</p><p>$avg    计算平均值    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</p><p>$min    获取集合中所有文档对应值得最小值。    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</p><p>$max    获取集合中所有文档对应值得最大值。    db.mycol.aggregate([{$group : {_id :<br>“$by_user”, num_tutorial : {$max : “$likes”}}}])</p><p>$push    在结果文档中插入值到一个数组中。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</p><p>$addToSet    在结果文档中插入值到一个数组中，但不创建副本。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</p><p>$first    根据资源文档的排序获取第一个文档数据。    db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</p><p>$last    根据资源文档的排序获取最后一个文档数据    db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</p><pre><code>结果中就只还有_id,tilte和author三个字段db.article.aggregate(    { $project : {        title : 1 ,        author : 1 ,    }} );连id一起删除db.article.aggregate(    { $project : {        _id : 0 ,        title : 1 ,        author : 1    }});</code></pre><p>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</p><pre><code>db.articles.aggregate( [  { $match : { score : { $gt : 70, $lte : 90 } } },  { $group: { _id: null, count: { $sum: 1 } } }] );</code></pre><p>$limit：用来限制MongoDB聚合管道返回的文档数。</p><p>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</p><pre><code>db.article.aggregate(    { $skip : 5 });</code></pre><p>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</p><p>$group：将集合中的文档分组，可用于统计结果。</p><p>$sort：将输入文档排序后输出。</p><p>$geoNear：输出接近某一地理位置的有序文档。</p><hr><h2 id="MongoDB-复制（副本集）"><a href="#MongoDB-复制（副本集）" class="headerlink" title="MongoDB 复制（副本集）"></a>MongoDB 复制（副本集）</h2><p>等树莓派装完再看</p><h2 id="MongoDB-分片"><a href="#MongoDB-分片" class="headerlink" title="MongoDB 分片"></a>MongoDB 分片</h2><p>等树莓派装完再看</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p><code>mongodump -h dbhost -d dbname -o dbdirectory</code></p><p>-h：<br>MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p><p>-d：<br>需要备份的数据库实例，例如：test</p><p>-o：<br>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 </p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p><code>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</code></p><pre><code>--host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017--db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2--drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！&lt;path&gt;：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。--dir：指定备份的目录你不能同时指定 &lt;path&gt; 和 --dir 选项。</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b更换国内软件源</title>
    <link href="undefined2019/11/pi-origin/"/>
    <url>2019/11/pi-origin/</url>
    
    <content type="html"><![CDATA[<h1 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h1><h2 id="切换到root用户"><a href="#切换到root用户" class="headerlink" title="切换到root用户"></a>切换到root用户</h2><p><code>su - root</code></p><h2 id="修改-etc-apt-sources-list"><a href="#修改-etc-apt-sources-list" class="headerlink" title="修改 /etc/apt/sources.list"></a>修改 /etc/apt/sources.list</h2><p><code>sudo nano /etc/apt/sources.list</code></p><pre><code>原文`deb http://mirrordirector.raspbian.org/raspbian/ stretch main contrib non-free rpi` 加#注释掉加入如下阿里源，`deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi`</code></pre><h2 id="修改-etc-apt-sources-list-d-raspi-list"><a href="#修改-etc-apt-sources-list-d-raspi-list" class="headerlink" title="修改/etc/apt/sources.list.d/raspi.list"></a>修改/etc/apt/sources.list.d/raspi.list</h2><p><code>sudo nano /etc/apt/sources.list.d/raspi.list</code></p><pre><code>原文`deb http://archive.raspberrypi.org/debian/ stretch main ui，` 加#加入如下科大源：`deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui`</code></pre><h2 id="更新系统和软件"><a href="#更新系统和软件" class="headerlink" title="更新系统和软件"></a>更新系统和软件</h2><p><code>sudo apt-get update</code></p><pre><code>`sudo apt-get upgrade`</code></pre>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>软件源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>软件源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b部署ngrok</title>
    <link href="undefined2019/11/pi-ngrok/"/>
    <url>2019/11/pi-ngrok/</url>
    
    <content type="html"><![CDATA[<h1 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h1><p>先去<a href="http://www.ngrok.cc/" target="_blank" rel="noopener">sunny ngrok</a>买个id</p><p>下载<br><code>wget &#39;hls.ctopus.com/sunny/linux_arm.zip?v=2&#39;</code></p><p>重命名<br><code>mv linux_arm.zip?v=2 linux_arm.zip</code></p><p>解压缩<br><code>unzip linux_arm.zip</code></p><p>切文件夹<br><code>cd linux_arm</code></p><p>启动！<br><code>./sunny clientid &lt;your-clientid&gt;</code></p><p>后台运行<br><code>setsid ./sunny clientid &lt;your-clientid&gt; &amp;</code></p><p>移动到 /use/local/bin 目录下并给予可执行权限</p><pre><code>sudo mv sunny /usr/local/bin/sunnysudo chmod +x /usr/local/bin/sunny</code></pre><p>编写启动脚本<br><code>sudo vim /etc/init.d/sunny</code></p><p>内容</p><pre><code>#!/bin/sh -e### BEGIN INIT INFO# Provides:          ngrok.cc# Required-Start:    $network $remote_fs $local_fs# Required-Stop:     $network $remote_fs $local_fs# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: autostartup of ngrok for Linux### END INIT INFONAME=sunnyDAEMON=/usr/local/bin/$NAMEPIDFILE=/var/run/$NAME.pid[ -x &quot;$DAEMON&quot; ] || exit 0case &quot;$1&quot; in  start)      if [ -f $PIDFILE ]; then        echo &quot;$NAME already running...&quot;        echo -e &quot;\033[1;35mStart Fail\033[0m&quot;      else        echo &quot;Starting $NAME...&quot;        start-stop-daemon -S -p $PIDFILE -m -b -o -q -x $DAEMON -- clientid &lt;your-clientid&gt; || return 2        echo -e &quot;\033[1;32mStart Success\033[0m&quot;    fi    ;;  stop)        echo &quot;Stoping $NAME...&quot;        start-stop-daemon -K -p $PIDFILE -s TERM -o -q || return 2        rm -rf $PIDFILE        echo -e &quot;\033[1;32mStop Success\033[0m&quot;    ;;  restart)    $0 stop &amp;&amp; sleep 2 &amp;&amp; $0 start    ;;  *)    echo &quot;Usage: $0 {start|stop|restart}&quot;    exit 1    ;;esacexit 0</code></pre><p>测试</p><pre><code>sudo chmod 755 /etc/init.d/sunnysudo /etc/init.d/sunny startsudo /etc/init.d/sunny start    #启动sudo /etc/init.d/sunny stop     #停止sudo /etc/init.d/sunny restart  #重启</code></pre><p>开机启动</p><pre><code>cd /etc/init.dsudo update-rc.d sunny defaults 90    #加入开机启动sudo update-rc.d -f sunny remove  #取消开机启动</code></pre>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>ngrok</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>ngrok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b安装gogs</title>
    <link href="undefined2019/11/pi-gogs/"/>
    <url>2019/11/pi-gogs/</url>
    
    <content type="html"><![CDATA[<h1 id="gogs"><a href="#gogs" class="headerlink" title="gogs"></a>gogs</h1><p>创建新用户git 如果不创建会导致主账号登陆不了ssh</p><p>切换为root用户为了获取创建用户的权限</p><p><code>sudo su</code></p><p>给root创建一个新的密码</p><p><code>sudo passwd root</code></p><p>添加一个新用户（如用户名为git）</p><p><code>useradd git</code></p><p>为该用户设定登录密码</p><p><code>passwd git</code></p><p>为该用户指定命令解释程序（通常为/bin/bash）</p><p><code>usermod -s /bin/bash git</code></p><p>为该用户指定用户主目录</p><p><code>usermod -d /home/git git</code></p><p>查看用户的属性</p><p><code>cat /etc/passwd</code></p><p>切换到用户git</p><p><code>su git</code></p><p>再次切换到root用户（不要用sudo su, 而用su root）</p><p><code>su root</code></p><p>执行visudo命令</p><p><code>visudo</code></p><p>该命令实际上打开的是/etc/sudoers文件，修改该文件，在“root ALL=(ALL:ALL) ALL”这一行下面加入一行：</p><p><code>git ALL=(ALL:ALL) ALL</code></p><p>ctrl+o（然后再按enter）保存，ctrl+c取消，ctrl+x退出</p><hr><p>下载<br><code>wget &#39;https://github.com/gogs/gogs/releases/download/v0.11.91/raspi_armv7.zip&#39;</code></p><p>解压<br><code>unzip raspi_armv7.zip</code></p><p>进文件夹<br><code>cd gogs</code></p><p>开启web服务<br><code>./gogs web</code></p><p>去3000端口进行设置，数据库设置成sqlite就行</p><p>在<code>/etc/systemd/system/gogs.service</code>新建文件</p><pre><code>[Unit]Description=Gogs (Go Git Service)After=syslog.targetAfter=network.target#After=mysqld.service#After=postgresql.service#After=memcached.service#After=redis.service[Service]# Modify these two values and uncomment them if you have# repos with lots of files and get an HTTP error 500 because# of that####LimitMEMLOCK=infinity#LimitNOFILE=65535Type=simpleUser=gitGroup=gitWorkingDirectory=/home/git/gogsExecStart=/home/git/gogs/gogs webRestart=alwaysEnvironment=USER=git HOME=/home/git[Install]WantedBy=multi-user.target</code></pre><p>更新 User、Group、WorkingDirectory、ExecStart 和 Environment 为相对应的值。其中 WorkingDirectory 为您的 Gogs 实际安装路径根目录。</p><p>[可选] 如果您 Gogs 安装示例使用 MySQL/MariaDB、PostgreSQL、Redis 或 memcached，请去掉相应 After 属性的注释。</p><p>然后通过 <code>sudo systemctl enable gogs</code> 命令激活，最后执行 <code>sudo systemd start gogs</code>，就可以做到开机启动了。</p><p>官方文件解释<a href="'https://gogs.io/docs/advanced/configuration_cheat_sheet'">docs</a></p><p>重启 <code>sudo systemctl restart gogs</code></p>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>gogs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>gogs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令总结</title>
    <link href="undefined2019/11/git/"/>
    <url>2019/11/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><ul><li><p>SSH <code>C:\Users\yingbo\.ssh</code></p><ul><li>创建： <code>ssh-keygen -t rsa -C &#39;邮件地址&#39;</code></li><li>测试： <code>ssh -T git@github.com</code></li><li>注意：上面创建语句完成后会让你输入密码，直接回车，不然之后提交的时候每次都会让你输入密码</li></ul></li><li><p><code>git init</code> 初始化仓库</p></li><li><p><code>git status</code> 查看仓库状态</p></li><li><p><code>git add &#39;文件名&#39;</code> 向暂存区添加文件，如果添加所有文件，’文件名’ =&gt; *</p></li><li><p><code>git commit -m &#39;text&#39;</code> </p><ul><li>提交，text为提交描述</li><li>直接 <code>git commit</code>会进入详细编辑的界面<ul><li>第一行简介</li><li>第二行空行</li><li>第三行详情</li></ul></li></ul></li><li><p><code>git log</code> 提交日志</p><ul><li>尾缀<ul><li><code>--pretty = short</code> 只显示概要</li><li><code>目录名/文件名</code> 只显示该目录或者该文件的记录</li><li><code>-P</code> 显示改动</li><li><code>-P</code> 文件名 显示该文件的改动</li></ul></li></ul></li><li><p><code>git diff</code> 查看区别</p><ul><li><code>git diff HEAD</code> 本次与上次的区别</li></ul></li><li><p><code>git branch</code> 显示所有分支</p><ul><li><code>git checkout -b name</code> 创建name分支并进入( 等同于下边两步)<ul><li>=&gt; <code>git branch name</code></li><li>=&gt; <code>git checkout name</code></li></ul></li><li><code>git checkout -</code> 切换回上一个分支</li><li>注：最好每做一件事就创建一个新的分支，保证代码无误再合并到主分支，保障主分支随时可用</li></ul></li><li><p>合并分支</p><ul><li><code>git checkout &#39;合并到的分支名&#39;</code></li><li><code>git merge --no--ff &#39;合并后消失的分支名&#39;</code></li><li><code>git log --graph</code> 图表形式提交日志</li></ul></li><li><p><code>git reset --hard &#39;哈希值&#39;</code> 回溯历史版本</p></li><li><p><code>git reflog</code> 操作日志</p></li><li><p>查看冲突并解决 git merge 后提示有冲突，此时冲突文件会被修改，进文件改成想要的样子，然后git add，git commit，done！</p></li><li><p><code>git commit --amend</code> 修改上一条的提交信息</p></li><li><p>压缩历史</p><ul><li><code>git commit -am</code> 一次性进暂存然后提交<ul><li>注：修改名称为 typo 例： fix typo</li></ul></li><li><code>git rebase -i HEAD~2</code> 合并两次最新提交</li><li>进入编辑器</li><li>pick 7a34294 Add feature-C</li><li>pick ofba227 Fix typo 将typo -&gt; fixup<br>然后保存 -&gt; ok</li></ul></li><li><p>添加远程仓库</p><ul><li><code>git remote add origin &#39;网址&#39;</code></li><li><code>git push -u origin master</code></li><li>//将当前分支推送到origin远端的master分支（master不存在的话自动新建）</li><li><code>git clone &#39;网址&#39;</code> 克隆仓库</li><li><code>git branch -a</code> 同时显示本地和远端的分支</li><li><code>git checkout -b feature-D origin/feature-D</code></li><li>//新建本地feature-D分支并把远端的feature-D同步过来</li></ul></li><li><p><code>git fetch</code> 与 <code>git pull</code> 的区别</p><ul><li>git pull = git fetch + git margin</li></ul></li><li><p>删除分支</p><ul><li><code>git branch -D &#39;分支名&#39;</code></li></ul></li><li><p>PR总结</p><pre><code>git checkout -b &lt;name&gt; //创建分支coding...git commit -m &#39;&lt;content&gt;&#39; //提交git pushd -u origin &lt;name&gt;  //推远端web -&gt; prgit branch -d &lt;name&gt;  //删除本地git push origin --delete &lt;name&gt; //删除远端</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 命令积累</title>
    <link href="undefined2019/11/linux/"/>
    <url>2019/11/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h3 id="切换用户su-root"><a href="#切换用户su-root" class="headerlink" title="切换用户su - root"></a>切换用户<code>su - root</code></h3><ul><li><code>-</code> 的含义是携带当前环境变量</li></ul><h3 id="增加用户useradd"><a href="#增加用户useradd" class="headerlink" title="增加用户useradd"></a>增加用户<code>useradd</code></h3><ul><li><code>-g</code> 指定用户所在群组 </li><li><code>-m</code> 自动建立用户的登入目录 </li><li><code>-n</code> 取消建立和用户同名的群组</li></ul><h3 id="更改对应用户密码passwd"><a href="#更改对应用户密码passwd" class="headerlink" title="更改对应用户密码passwd"></a>更改对应用户密码<code>passwd</code></h3><h3 id="查看进程ps"><a href="#查看进程ps" class="headerlink" title="查看进程ps"></a>查看进程<code>ps</code></h3><ul><li><code>-ef</code> 查看所有进程以及其pid </li><li><code>-aux</code> 查看所有进程并显示其占用的cpu以及mem </li><li><code>-w</code> 显示加宽可以显示更多信息</li><li><code>ps -auxwww</code>加宽三次</li></ul><h3 id="停止进程kill-pid"><a href="#停止进程kill-pid" class="headerlink" title="停止进程kill (pid)"></a>停止进程<code>kill (pid)</code></h3><ul><li><code>-s</code> 发送指定信号到进程</li><li><code>-p</code> 打印出进程号，但是不发送信号</li><li><code>-l</code> 打印出所有可用信号名称</li></ul><h3 id="查看磁盘fdisk-l"><a href="#查看磁盘fdisk-l" class="headerlink" title="查看磁盘fdisk -l"></a>查看磁盘<code>fdisk -l</code></h3><ul><li>必须使用<code>root</code>权限</li></ul><h3 id="切换目录cd"><a href="#切换目录cd" class="headerlink" title="切换目录cd ../"></a>切换目录<code>cd ../</code></h3><ul><li><code>./</code>当前目录</li><li><code>../</code>上级目录</li><li><code>cd -</code>返回到上个目录</li></ul><h3 id="显示当前文件夹下的文件夹以及文件ls"><a href="#显示当前文件夹下的文件夹以及文件ls" class="headerlink" title="显示当前文件夹下的文件夹以及文件ls"></a>显示当前文件夹下的文件夹以及文件<code>ls</code></h3><ul><li><code>-l</code> 显示详细信息</li><li><code>-a -all</code> 列出所有文件包括隐藏文件</li><li><code>-d</code> 将目录名和其他文件一样列出，而不是列出目录的内容</li><li><code>-f</code> 不排序目录内容，按他们在磁盘上存储的顺序列出</li></ul><h3 id="创建一个目录mkdir"><a href="#创建一个目录mkdir" class="headerlink" title="创建一个目录mkdir"></a>创建一个目录<code>mkdir</code></h3><ul><li><code>-m</code> 对新建目录设置权限</li><li><code>-p</code> 可以是一个路径，可以一次创建多层目录</li></ul><h3 id="查看文件内容cat-文件路径"><a href="#查看文件内容cat-文件路径" class="headerlink" title="查看文件内容cat (文件路径)"></a>查看文件内容<code>cat (文件路径)</code></h3><ul><li><code>-n</code> 输出行号</li><li><code>-b</code> 输出行号，对空白行不编号</li></ul><h3 id="复制文件cp"><a href="#复制文件cp" class="headerlink" title="复制文件cp"></a>复制文件<code>cp</code></h3><ul><li><code>-a</code> 保留链接，文件属性，复制其子目录，其作用等于dpr选项的组合</li><li><code>-d</code> 拷贝时保留链接</li><li><code>-f</code> 删除已经存在的目标文件而不提示</li><li><code>-i</code> 覆盖目标文件之前给出提示要求用户确认</li><li><code>-p</code> 除了复制内容，修改时间还有访问权限也复制到新文件中</li><li><code>-r</code> 若给出的文件是一目录文件，此时将会递归复制该目录下的所有文件以及子目录，此时目标文件必须为一个目录名</li></ul><h3 id="为文件改名或者移动mv"><a href="#为文件改名或者移动mv" class="headerlink" title="为文件改名或者移动mv"></a>为文件改名或者移动<code>mv</code></h3><ul><li><code>-i</code> 若操作会导致文件被覆写，将会提示用户确认</li><li><code>-f</code> 禁止交互 会让<code>-i</code> 失效</li><li><code>mv fromfile tofile</code>如把文件a.txt得命名为b.txt，可以是mv a.txt b.txt。</li></ul><h3 id="移除目录或者文件rm"><a href="#移除目录或者文件rm" class="headerlink" title="移除目录或者文件rm"></a>移除目录或者文件<code>rm</code></h3><ul><li><code>-i</code> 进行交互式删除</li><li><code>-f</code> 不需要提示</li><li><code>-r</code> 将所有目录以及子目录递归地删除</li><li><code>-d</code> 删除空目录</li></ul><h3 id="修改文件所有者chown"><a href="#修改文件所有者chown" class="headerlink" title="修改文件所有者chown"></a>修改文件所有者<code>chown</code></h3><h3 id="修改文件所有组chgrp"><a href="#修改文件所有组chgrp" class="headerlink" title="修改文件所有组chgrp"></a>修改文件所有组<code>chgrp</code></h3><h3 id="修改文件访问权限chmod"><a href="#修改文件访问权限chmod" class="headerlink" title="修改文件访问权限chmod"></a>修改文件访问权限<code>chmod</code></h3><ul><li><code>-c</code> 若文件权限更改成功才显示</li><li><code>-f</code> 若文件无法被更改也不打印错误信息</li><li><code>-v</code> 显示权限变更详细资料</li><li>修改文件权限<a href="'https://blog.csdn.net/slwhy/article/details/78876237'">链接</a></li></ul><h3 id="在指定文件中搜索内容"><a href="#在指定文件中搜索内容" class="headerlink" title="在指定文件中搜索内容"></a>在指定文件中搜索内容</h3><ul><li><code>grep</code> 选项 格式 文件</li><li><code>-c</code> 只输出匹配的行数</li><li><code>-i</code> 不区分大小写</li><li><code>-h</code> 查询多文件不显示文件名</li><li><code>-l</code> 查询多文件只显示包含匹配字符的文件名</li><li><code>-n</code> 显示匹配行以及行号</li><li><code>-s</code> 不显示不存在或者无匹配文本的错误信息</li><li><code>-v</code> 显示不包含匹配文本的所有行</li></ul><h3 id="查找指定文件find-路径-选项-描述"><a href="#查找指定文件find-路径-选项-描述" class="headerlink" title="查找指定文件find [路径] [选项] [描述]"></a>查找指定文件<code>find [路径] [选项] [描述]</code></h3><ul><li><code>-depth</code> 使用深度级别的查找过程方式，在某层指定目录中优先查找文件内容</li><li><code>-mount</code> 不在其他文件系统的目录个文件中查找</li><li><code>-name</code> 支持通配符* 和 ?</li><li><code>-user</code> 搜索文件所属为用户名的文件</li><li><code>-print</code> 输出搜索结果并打印</li><li><code>-and</code> 把两个查找参数链接起来</li></ul><h3 id="查找文件locate"><a href="#查找文件locate" class="headerlink" title="查找文件locate"></a>查找文件<code>locate</code></h3><ul><li>先建立一个所有文件名以及路径的数据库所以比find快</li><li><code>-u</code> 从根目录开始建立数据库</li><li><code>-U</code> 从指定位置开始建立数据库</li><li><code>-f</code> 将特定的文件系统排除在数据库外</li><li><code>-r</code> 使用正则表达式做寻找的条件</li><li><code>-o</code> 指定数据库的名成</li><li>创建后会在crontab中每天已更新</li><li>使用updatedb强制更新</li></ul><h3 id="创建链接ln-s-genromfs-0-5-1-tar-gz-hello"><a href="#创建链接ln-s-genromfs-0-5-1-tar-gz-hello" class="headerlink" title="创建链接ln -s ../genromfs-0.5.1.tar.gz ./hello"></a>创建链接<code>ln -s ../genromfs-0.5.1.tar.gz ./hello</code></h3><h3 id="gzip压缩解压"><a href="#gzip压缩解压" class="headerlink" title="gzip压缩解压"></a>gzip压缩解压</h3><ul><li>自动识别</li><li><code>-c</code> 将输出信息输出保留源文件</li><li><code>-d</code> 将压缩文件解压，但是不能压缩目录</li><li><code>-l</code> 显示详细信息</li><li><code>-r</code> 查找指定目录压缩或解压缩里边所有文件</li><li><code>-t</code> 测试，检查压缩文件是否完整</li><li><code>-v</code> 对每一个压缩或者解压的文件显示文件名和压缩比</li></ul><h3 id="对文件目录进行打包和解包tar"><a href="#对文件目录进行打包和解包tar" class="headerlink" title="对文件目录进行打包和解包tar"></a>对文件目录进行打包和解包<code>tar</code></h3><ul><li><code>tar [选项] [打包后文件名] 文件目录列表</code></li><li><code>-c</code> 建立新的打包文件</li><li><code>-r</code> 向打包文件末尾追加文件</li><li><code>-x</code> 从打包文件中解出文件</li><li><code>-o</code> 将文件解开到标准输出</li><li><code>-v</code> 显示处理过程中相关信息</li><li><code>-f</code> 对普通文件操作</li><li><code>-z</code> 调用gzip压缩打包文件，与<code>-x</code>连用解压缩</li><li><code>-j</code> 调用bzip2压缩打包文件，与<code>-x</code>连用解压缩</li><li><code>-Z</code> 调用Compress压缩打包文件，与<code>-x</code>连用解压缩</li></ul><h3 id="查看网络状态ifconfig"><a href="#查看网络状态ifconfig" class="headerlink" title="查看网络状态ifconfig"></a>查看网络状态<code>ifconfig</code></h3><h3 id="系统服务命令chkconfig-list"><a href="#系统服务命令chkconfig-list" class="headerlink" title="系统服务命令chkconfig --list"></a>系统服务命令<code>chkconfig --list</code></h3><ul><li>查看指定命令 <code>chkconfig --list|grep ntpd</code></li><li>操作指定服务 <code>chkconfig --level 3 ntpd on</code></li></ul><h3 id="查看当前文件夹pwd"><a href="#查看当前文件夹pwd" class="headerlink" title="查看当前文件夹pwd"></a>查看当前文件夹<code>pwd</code></h3><h3 id="查看所有端口占用情况"><a href="#查看所有端口占用情况" class="headerlink" title="查看所有端口占用情况"></a>查看所有端口占用情况</h3><p><code>netstat -ntlp</code></p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>touch</code></p><h3 id="查看-5000端口占用程序"><a href="#查看-5000端口占用程序" class="headerlink" title="查看 5000端口占用程序"></a>查看 5000端口占用程序</h3><p><code>sudo lsof -i:5000</code></p><h3 id="停止进程"><a href="#停止进程" class="headerlink" title="停止进程"></a>停止进程</h3><p><code>sudo kill (PID)</code></p><h3 id="下载到当前文件夹"><a href="#下载到当前文件夹" class="headerlink" title="下载到当前文件夹"></a>下载到当前文件夹</h3><p><code>wget&quot;&lt;url&gt;&quot;</code></p><h3 id="下载到-home-omio-Desktop"><a href="#下载到-home-omio-Desktop" class="headerlink" title="下载到 /home/omio/Desktop"></a>下载到 /home/omio/Desktop</h3><p><code>wget -P /home/omio/Desktop/&quot;&lt;url&gt;&quot;</code></p><h3 id="下载并重命名为NewFileName"><a href="#下载并重命名为NewFileName" class="headerlink" title="下载并重命名为NewFileName"></a>下载并重命名为NewFileName</h3><p><code>wget -O /home/omio/Desktop/NewFileName&quot;&lt;url&gt;&quot;</code></p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>zip -r archive_name.zip directory_to_compress</code></p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p><code>unzip archive_name.zip</code></p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><code>tar -cvf archive_name.tar directory_to_compress</code></p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p><code>tar -xvf archive_name.tar.gz</code></p><h3 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf archive_name.tar.gz directory_to_compress</code></p><h3 id="解压缩-1"><a href="#解压缩-1" class="headerlink" title="解压缩"></a>解压缩</h3><p><code>tar -zxvf archive_name.tar.gz</code></p><p><code>tar -zxvf archive_name.tar.gz -C /tmp/extract_here/</code></p><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p><code>mv fromfile tofile</code></p><ul><li>如把文件a.txt得命名为b.txt，可以是mv a.txt b.txt。</li></ul><h3 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h3><p><code>rm -d 目录名</code></p><h3 id="删除一个空目录-1"><a href="#删除一个空目录-1" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h3><p><code>rm -dir 目录名</code></p><h3 id="删除一个非空目录"><a href="#删除一个非空目录" class="headerlink" title="删除一个非空目录"></a>删除一个非空目录</h3><p><code>rm -r 目录名</code></p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>rm 文件名</code></p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><a href="'https://blog.csdn.net/slwhy/article/details/78876237'">链接</a></p><ul><li>sudo chmod o+rwx /usr/local/bin/sunny</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>system</tag>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask 简单安装和部署</title>
    <link href="undefined2019/11/flask/"/>
    <url>2019/11/flask/</url>
    
    <content type="html"><![CDATA[<h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><p>安装venv</p><p><code>python3 -m venv venv</code></p><p>启动venv</p><p><code>. venv/bin/activate</code></p><p>关闭venv</p><p><code>deactivate</code> </p><p>查看现在已经安装的依赖</p><p><code>pip3 list</code></p><p>更新pip</p><p><code>pip install --upgrade pip</code></p><p>安装Flask</p><p><code>pip install Flask</code></p><p>安装最新的flask</p><p><code>pip install -U https://github.com/pallets/flask/archive/master.tar.gz</code></p><p>安装pymongo</p><p><code>pip install pymongo</code></p><p>安装requests</p><p><code>pip install requests</code></p><p>安装payjs</p><p><code>pip install payjs</code></p><p>设置全局变量</p><p><code>export FLASK_APP=qrcode.py</code></p><p><code>export FLASK_ENV=development</code></p><p>启动</p><p><code>flask run --host=0.0.0.0</code></p><p>在虚拟环境下安装gunicorn </p><p><code>pip install gunicorn</code></p><p>添加配置文件 gunicorn.conf.py</p><pre><code># 并行工作线程数workers = 4# 监听内网端口5000【按需要更改】bind = &#39;127.0.0.1:5000&#39;# 设置守护进程【关闭连接时，程序仍在运行】daemon = True# 设置超时时间120s，默认为30s。按自己的需求进行设置timeout = 120# 设置访问日志和错误信息日志路径# accesslog = &#39;./logs/acess.log&#39;# errorlog = &#39;./logs/error.log&#39;# 自动重启autostart = ture</code></pre><p>启动gunicorn</p><p><code>gunicorn qrcode:app -c gunicorn.conf.py</code></p><p>查询gunicorn</p><p><code>pstree -ap|grep gunicorn</code></p><p>停止进程</p><p><code>kill (pid)</code></p><hr><p>在路由中</p><ol><li>同时有user/ 和 user 优先解释 user/</li><li>只有 user 的情况下 访问user/会报404</li><li>只有 user/ 的情况下 访问user会被重定向</li></ol>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/11/hello-world/"/>
    <url>2019/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><pre><code class="html">&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;nLbPI5Gbnr&quot; /&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>quickStart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>