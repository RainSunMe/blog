<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>webpack打包原理</title>
    <link href="undefined2020/07/webpack/"/>
    <url>2020/07/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="什么是-webpack"><a href="#什么是-webpack" class="headerlink" title="什么是 webpack"></a>什么是 webpack</h2><p>本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle。</p><p>webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。</p><p>webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好。 – 深入浅出 webpack 吴浩麟<br><img src="/img/wp.png" alt=""></p><h2 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念"></a>webpack 核心概念</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始。</p><p>进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p><p>每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>output 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。</p><p>基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。</p><h3 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h3><p>代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。</p><p>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。</p><p>本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。</p><p>插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p><h2 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h2><p>Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程 :</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。</li><li>确定入口：根据配置中的 entry 找出所有的入口文件。</li><li>编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</li><li>完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li><li>输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。</li><li>输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。</li></ol><p>在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><h2 id="实践加深理解-撸一个简易-webpack"><a href="#实践加深理解-撸一个简易-webpack" class="headerlink" title="实践加深理解,撸一个简易 webpack"></a>实践加深理解,撸一个简易 webpack</h2><h3 id="1-定义-Compiler-类"><a href="#1-定义-Compiler-类" class="headerlink" title="1. 定义 Compiler 类"></a>1. 定义 Compiler 类</h3><pre><code class="js">class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {}  // 重写 require函数,输出bundle  generate() {}}</code></pre><h3 id="2-解析入口文件-获取-AST"><a href="#2-解析入口文件-获取-AST" class="headerlink" title="2. 解析入口文件,获取 AST"></a>2. 解析入口文件,获取 AST</h3><p>我们这里使用@babel/parser,这是 babel7 的工具,来帮助我们分析内部的语法,包括 es6,返回一个 AST 抽象语法树。</p><pre><code class="js">// webpack.config.jsconst path = require(&#39;path&#39;)module.exports = {  entry: &#39;./src/index.js&#39;,  output: {    path: path.resolve(__dirname, &#39;./dist&#39;),    filename: &#39;main.js&#39;  }}//</code></pre><pre><code class="js">const fs = require(&#39;fs&#39;)const parser = require(&#39;@babel/parser&#39;)const options = require(&#39;./webpack.config&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    const ast = Parser.getAst(this.entry)  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="3-找出所有依赖模块"><a href="#3-找出所有依赖模块" class="headerlink" title="3. 找出所有依赖模块"></a>3. 找出所有依赖模块</h3><p>Babel 提供了@babel/traverse(遍历)方法维护这 AST 树的整体状态,我们这里使用它来帮我们找出依赖模块。</p><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    const { getAst, getDependecies } = Parser    const ast = getAst(this.entry)    const dependecies = getDependecies(ast, this.entry)  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="4-AST-转换为-code"><a href="#4-AST-转换为-code" class="headerlink" title="4. AST 转换为 code"></a>4. AST 转换为 code</h3><p>将 AST 语法树转换为浏览器可执行代码,我们这里使用@babel/core 和 @babel/preset-env。</p><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst { transformFromAst } = require(&#39;@babel/core&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  },  getCode: ast =&gt; {    // AST转换为code    const { code } = transformFromAst(ast, null, {      presets: [&#39;@babel/preset-env&#39;]    })    return code  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    const { getAst, getDependecies, getCode } = Parser    const ast = getAst(this.entry)    const dependecies = getDependecies(ast, this.entry)    const code = getCode(ast)  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="5-递归解析所有依赖项-生成依赖关系图"><a href="#5-递归解析所有依赖项-生成依赖关系图" class="headerlink" title="5. 递归解析所有依赖项,生成依赖关系图"></a>5. 递归解析所有依赖项,生成依赖关系图</h3><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst { transformFromAst } = require(&#39;@babel/core&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  },  getCode: ast =&gt; {    // AST转换为code    const { code } = transformFromAst(ast, null, {      presets: [&#39;@babel/preset-env&#39;]    })    return code  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    // 解析入口文件    const info = this.build(this.entry)    this.modules.push(info)    this.modules.forEach(({ dependecies }) =&gt; {      // 判断有依赖对象,递归解析所有依赖项      if (dependecies) {        for (const dependency in dependecies) {          this.modules.push(this.build(dependecies[dependency]))        }      }    })    // 生成依赖关系图    const dependencyGraph = this.modules.reduce(      (graph, item) =&gt; ({        ...graph,        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容        [item.filename]: {          dependecies: item.dependecies,          code: item.code        }      }),      {}    )  }  build(filename) {    const { getAst, getDependecies, getCode } = Parser    const ast = getAst(filename)    const dependecies = getDependecies(ast, filename)    const code = getCode(ast)    return {      // 文件路径,可以作为每个模块的唯一标识符      filename,      // 依赖对象,保存着依赖模块路径      dependecies,      // 文件内容      code    }  }  // 重写 require函数,输出bundle  generate() {}}new Compiler(options).run()</code></pre><h3 id="6-重写-require-函数-输出-bundle"><a href="#6-重写-require-函数-输出-bundle" class="headerlink" title="6. 重写 require 函数,输出 bundle"></a>6. 重写 require 函数,输出 bundle</h3><pre><code class="js">const fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)const options = require(&#39;./webpack.config&#39;)const parser = require(&#39;@babel/parser&#39;)const traverse = require(&#39;@babel/traverse&#39;).defaultconst { transformFromAst } = require(&#39;@babel/core&#39;)const Parser = {  getAst: path =&gt; {    // 读取入口文件    const content = fs.readFileSync(path, &#39;utf-8&#39;)    // 将文件内容转为AST抽象语法树    return parser.parse(content, {      sourceType: &#39;module&#39;    })  },  getDependecies: (ast, filename) =&gt; {    const dependecies = {}    // 遍历所有的 import 模块,存入dependecies    traverse(ast, {      // 类型为 ImportDeclaration 的 AST 节点 (即为import 语句)      ImportDeclaration({ node }) {        const dirname = path.dirname(filename)        // 保存依赖模块路径,之后生成依赖关系图需要用到        const filepath = &#39;./&#39; + path.join(dirname, node.source.value)        dependecies[node.source.value] = filepath      }    })    return dependecies  },  getCode: ast =&gt; {    // AST转换为code    const { code } = transformFromAst(ast, null, {      presets: [&#39;@babel/preset-env&#39;]    })    return code  }}class Compiler {  constructor(options) {    // webpack 配置    const { entry, output } = options    // 入口    this.entry = entry    // 出口    this.output = output    // 模块    this.modules = []  }  // 构建启动  run() {    // 解析入口文件    const info = this.build(this.entry)    this.modules.push(info)    this.modules.forEach(({ dependecies }) =&gt; {      // 判断有依赖对象,递归解析所有依赖项      if (dependecies) {        for (const dependency in dependecies) {          this.modules.push(this.build(dependecies[dependency]))        }      }    })    // 生成依赖关系图    const dependencyGraph = this.modules.reduce(      (graph, item) =&gt; ({        ...graph,        // 使用文件路径作为每个模块的唯一标识符,保存对应模块的依赖对象和文件内容        [item.filename]: {          dependecies: item.dependecies,          code: item.code        }      }),      {}    )    this.generate(dependencyGraph)  }  build(filename) {    const { getAst, getDependecies, getCode } = Parser    const ast = getAst(filename)    const dependecies = getDependecies(ast, filename)    const code = getCode(ast)    return {      // 文件路径,可以作为每个模块的唯一标识符      filename,      // 依赖对象,保存着依赖模块路径      dependecies,      // 文件内容      code    }  }  // 重写 require函数 (浏览器不能识别commonjs语法),输出bundle  generate(code) {    // 输出文件路径    const filePath = path.join(this.output.path, this.output.filename)    // 懵逼了吗? 没事,下一节我们捋一捋    const bundle = `(function(graph){      function require(module){        function localRequire(relativePath){          return require(graph[module].dependecies[relativePath])        }        var exports = {};        (function(require,exports,code){          eval(code)        })(localRequire,exports,graph[module].code);        return exports;      }      require(&#39;${this.entry}&#39;)    })(${JSON.stringify(code)})`    // 把文件内容写入到文件系统    fs.writeFileSync(filePath, bundle, &#39;utf-8&#39;)  }}new Compiler(options).run()</code></pre><h3 id="7-看完这节-彻底搞懂-bundle-实现"><a href="#7-看完这节-彻底搞懂-bundle-实现" class="headerlink" title="7. 看完这节,彻底搞懂 bundle 实现"></a>7. 看完这节,彻底搞懂 bundle 实现</h3><p>我们通过下面的例子来进行讲解,先死亡凝视 30 秒</p><pre><code class="js">;(function(graph) {  function require(moduleId) {    function localRequire(relativePath) {      return require(graph[moduleId].dependecies[relativePath])    }    var exports = {}    ;(function(require, exports, code) {      eval(code)    })(localRequire, exports, graph[moduleId].code)    return exports  }  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><h4 id="step-1-从入口文件开始执行"><a href="#step-1-从入口文件开始执行" class="headerlink" title="step 1 : 从入口文件开始执行"></a>step 1 : 从入口文件开始执行</h4><pre><code class="js">// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) {  // 重写require函数  function require(moduleId) {    console.log(moduleId) // ./src/index.js  }  // 从入口文件开始执行  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><h4 id="step-2-使用-eval-执行代码"><a href="#step-2-使用-eval-执行代码" class="headerlink" title="step 2 : 使用 eval 执行代码"></a>step 2 : 使用 eval 执行代码</h4><pre><code class="js">// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) {  // 重写require函数  function require(moduleId) {    ;(function(code) {      console.log(code) // &quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));      eval(code) // Uncaught TypeError: Cannot read property &#39;code&#39; of undefined    })(graph[moduleId].code)  }  // 从入口文件开始执行  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><p>可以看到,我们在执行”./src/index.js”文件代码的时候报错了,这是因为 index.js 里引用依赖 hello.js,而我们没有对依赖进行处理,接下来我们对依赖引用进行处理。</p><h4 id="step-3-依赖对象寻址映射-获取-exports-对象"><a href="#step-3-依赖对象寻址映射-获取-exports-对象" class="headerlink" title="step 3 : 依赖对象寻址映射,获取 exports 对象"></a>step 3 : 依赖对象寻址映射,获取 exports 对象</h4><pre><code class="js">// 定义一个立即执行函数,传入生成的依赖关系图;(function(graph) {  // 重写require函数  function require(moduleId) {    // 找到对应moduleId的依赖对象,调用require函数,eval执行,拿到exports对象    function localRequire(relativePath) {      return require(graph[moduleId].dependecies[relativePath]) // {__esModule: true, say: ƒ say(name)}    }    // 定义exports对象    var exports = {}    ;(function(require, exports, code) {      // commonjs语法使用module.exports暴露实现,我们传入的exports对象会捕获依赖对象(hello.js)暴露的实现(exports.say = say)并写入      eval(code)    })(localRequire, exports, graph[moduleId].code)    // 暴露exports对象,即暴露依赖对象对应的实现    return exports  }  // 从入口文件开始执行  require(&#39;./src/index.js&#39;)})({  &#39;./src/index.js&#39;: {    dependecies: { &#39;./hello.js&#39;: &#39;./src/hello.js&#39; },    code: &#39;&quot;use strict&quot;;\n\nvar _hello = require(&quot;./hello.js&quot;);\n\ndocument.write((0, _hello.say)(&quot;webpack&quot;));&#39;  },  &#39;./src/hello.js&#39;: {    dependecies: {},    code:      &#39;&quot;use strict&quot;;\n\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.say = say;\n\nfunction say(name) {\n  return &quot;hello &quot;.concat(name);\n}&#39;  }})</code></pre><p>这下应该明白了吧 ~ 可以直接复制上面代码到控制台输出哦~</p><p>完整代码地址<a href="https://github.com/webfansplz/article/tree/master/easy-webpack" target="_blank" rel="noopener">戳我</a> 👈</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Webpack 是一个庞大的 Node.js 应用,如果你阅读过它的源码,你会发现实现一个完整的 Webpack 需要编写非常多的代码。 但你无需了解所有的细节,只需了解其整体架构和部分细节即可。</p><p>对 Webpack 的使用者来说,它是一个简单强大的工具； 对 Webpack 的开发者来说,它是一个扩展性的高系统。</p><p>Webpack 之所以能成功,在于它把复杂的实现隐藏了起来,给用户暴露出的只是一个简单的工具,让用户能快速达成目的。 同时整体架构设计合理,扩展性高,开发扩展难度不高,通过社区补足了大量缺失的功能,让 Webpack 几乎能胜任任何场景。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.webpackjs.com" target="_blank" rel="noopener">webpack 中文文档</a></p><p><a href="https://webpack.wuhaolin.cn/" target="_blank" rel="noopener">深入浅出 webpack</a></p><blockquote><p>作者：null仔<br>链接：<a href="https://segmentfault.com/a/1190000021494964?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021494964?utm_source=tag-newest</a><br>来源：SegmentFault 思否</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>高级</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AST 抽象语法树</title>
    <link href="undefined2020/07/ast/"/>
    <url>2020/07/ast/</url>
    
    <content type="html"><![CDATA[<h1 id="AST-抽象语法树"><a href="#AST-抽象语法树" class="headerlink" title="AST 抽象语法树"></a>AST 抽象语法树</h1><blockquote><p>抽象语法树（AST），是一个非常基础而重要的知识点，但国内的文档却几乎一片空白。<br>本文将带大家从底层了解AST,并且通过发布一个小型前端工具，来带大家了解AST的强大功能</p></blockquote><h2 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h2><p>拆解一个简单的add函数</p><pre><code class="js">function add(a, b) {  return a + b}</code></pre><p>首先我们拿到了这个语法快，这是一个<code>FunctionDeclaration</code>(函数定义)对象</p><p>分解成三块</p><ul><li>一个id，就是他的名字，即<code>add</code></li><li>两个params，也就是它的参数，即[a,b]</li><li>一块body，也就是大括号里边的东西</li></ul><p>add没办法继续拆下去了，它是一个最基础的Identifier(标志)对象，用来作为函数的唯一标志，就像人的姓名一样</p><pre><code class="js">{  name: &#39;add&#39;,  type: &#39;identifier&#39;,  ...}</code></pre><p>params继续拆下去，其实是两个Identifier组成的数组。之后也没办法拆下去了。</p><pre><code class="js">[    {        name: &#39;a&#39;        type: &#39;identifier&#39;        ...    },    {        name: &#39;b&#39;        type: &#39;identifier&#39;        ...    }]</code></pre><p>接下来，我们继续拆开<code>body</code></p><p>我们发现,<code>body</code>其实是一个<code>BlockStatement</code>（块状域）对象，用来表示是<code>{return a + b}</code></p><p>打开<code>BlockStatement</code>，里边藏着一个<code>ReturnStatement</code>(Return域)对象，用来表示<code>return a + b</code></p><p>继续打开<code>ReturnStatement</code>,里边是一个<code>BinaryExpression</code>(二项式)对象，用来表示<code>a + b</code></p><p>继续打开<code>BinaryExpression</code>，它成了三部分, <code>left</code>, <code>operator</code>, <code>right</code></p><ul><li><code>operator</code> 即<code>+</code></li><li><code>left</code> 里面装的，是Identifier对象 <code>a</code></li><li><code>right</code> 里面装的，是Identifer对象 <code>b</code></li></ul><p>我们拆解完了,就是一个这样的树形结构<br><img src="https://image-static.segmentfault.com/214/084/2140843498-5b89e44deaa5c_articlex" alt=""></p><p>那么，上面我们提到的Identifier、Blockstatement、ReturnStatement、BinaryExpression， 这一个个小部件的说明书去哪查？</p><p><strong>请查看</strong> <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" target="_blank" rel="noopener">AST对象文档</a></p><h2 id="送给你的AST螺丝刀：recast"><a href="#送给你的AST螺丝刀：recast" class="headerlink" title="送给你的AST螺丝刀：recast"></a>送给你的AST螺丝刀：recast</h2><p>输入命令</p><p><code>npm i recast -s</code></p><p>你即可获得一把操纵语法树的螺丝刀</p><p>接下来，你可以在任意js文件下操纵这把螺丝刀，我们新建一个parse.js示意：</p><p>parse.js</p><pre><code class="js">// 给你一把&quot;螺丝刀&quot;——recastconst recast = require(&quot;recast&quot;);// 你的&quot;机器&quot;——一段代码// 我们使用了很奇怪格式的代码，想测试是否能维持代码结构const code =  `  function add(a, b) {    return a +      // 有什么奇怪的东西混进来了      b  }  `// 用螺丝刀解析机器const ast = recast.parse(code);// ast可以处理很巨大的代码文件// 但我们现在只需要代码块的第一个body，即add函数const add  = ast.program.body[0]console.log(add)</code></pre><p>输入node parse.js你可以查看到add函数的结构，与之前所述一致，通过AST对象文档可查到它的具体属性：</p><pre><code class="js">FunctionDeclaration{    type: &#39;FunctionDeclaration&#39;,    id: ...    params: ...    body: ...}</code></pre><p>你也可以继续使用console.log透视它的更内层，如：</p><pre><code class="js">console.log(add.params[0])console.log(add.body.body[0].argument.left)</code></pre><h2 id="recast-types-builders-制作模具"><a href="#recast-types-builders-制作模具" class="headerlink" title="recast.types.builders 制作模具"></a>recast.types.builders 制作模具</h2><p>一个机器，你只会拆开重装，不算本事。</p><p>拆开了，还能改装，才算上得了台面。</p><p><code>recast.types.builders</code>里面提供了不少“模具”，让你可以轻松地拼接成新的机器。</p><p>最简单的例子，我们想把之前的function add(a, b){…}声明，改成匿名函数式声明const add = function(a ,b){…}</p><p>如何改装？</p><p>第一步，我们创建一个<code>VariableDeclaration</code>变量声明对象，声明头为<code>const</code>， 内容为一个即将创建的<code>VariableDeclarator</code>对象。</p><p>第二步，创建一个<code>VariableDeclarator</code>，放置<code>add.id</code>在左边， 右边是将创建的<code>FunctionDeclaration</code>对象</p><p>第三步，我们创建一个<code>FunctionDeclaration</code>，如前所述的三个组件，<code>id params body</code>中，因为是匿名函数id设为空，<code>params</code>使用<code>add.params</code>，<code>body</code>使用<code>add.body</code>。</p><p>这样，就创建好了<code>const add = function(){}</code>的AST对象。</p><p>在之前的parse.js代码之后，加入以下代码</p><pre><code class="js">// 引入变量声明，变量符号，函数声明三种“模具”const {variableDeclaration, variableDeclarator, functionExpression} = recast.types.builders// 将准备好的组件置入模具，并组装回原来的ast对象。ast.program.body[0] = variableDeclaration(&quot;const&quot;, [  variableDeclarator(add.id, functionExpression(    null, // Anonymize the function expression.    add.params,    add.body  ))]);//将AST对象重新转回可以阅读的代码const output = recast.print(ast).code;console.log(output)</code></pre><p>可以看到，我们打印出了</p><pre><code class="js">const add = function(a, b) {  return a +    // 有什么奇怪的东西混进来了    b};</code></pre><p>最后一行</p><pre><code class="js">const output = recast.print(ast).code;</code></pre><p>其实是recast.parse的逆向过程，具体公式为</p><pre><code class="js">recast.print(recast.parse(source)).code === source</code></pre><p>打印出来还保留着“原装”的函数内容，连注释都没有变。</p><p>我们其实也可以打印出美化格式的代码段：</p><pre><code class="js">const output = recast.prettyPrint(ast, { tabWidth: 2 }).code</code></pre><p>输出为</p><pre><code class="js">const add = function(a, b) {  return a + b;};</code></pre><blockquote><p>现在，你是不是已经产生了“我可以通过AST树生成任何js代码”的幻觉？<br>我郑重告诉你，这不是幻觉。</p></blockquote><h2 id="实战进阶：命令行修改js文件"><a href="#实战进阶：命令行修改js文件" class="headerlink" title="实战进阶：命令行修改js文件"></a>实战进阶：命令行修改js文件</h2><p>除了<code>parse/print/builder</code>以外，Recast的三项主要功能：</p><ul><li>run: 通过命令行读取js文件，并转化成ast以供处理。</li><li>tnt： 通过assert()和check()，可以验证ast对象的类型。</li><li>visit: 遍历ast树，获取有效的AST对象并进行更改。</li></ul><p>我们通过一个系列小务来学习全部的recast工具库：</p><p>创建一个示例文件，假设是demo.js</p><p>demo.js</p><pre><code class="js">function add(a, b) {  return a + b}function sub(a, b) {  return a - b}function commonDivision(a, b) {  while (b !== 0) {    if (a &gt; b) {      a = sub(a, b)    } else {      b = sub(b, a)    }  }  return a}</code></pre><h3 id="recast-run-——-命令行文件读取"><a href="#recast-run-——-命令行文件读取" class="headerlink" title="recast.run —— 命令行文件读取"></a>recast.run —— 命令行文件读取</h3><p>新建一个名为read.js的文件，写入<br>read.js</p><pre><code class="js">const recast = require(&quot;recast&quot;);recast.run( function(ast, printSource){    printSource(ast)})</code></pre><p>命令行输入</p><pre><code class="cmd">node read demo.js</code></pre><p>我们查以看到js文件内容打印在了控制台上。</p><p>我们可以知道，<code>node read</code>可以读取<code>demo.js</code>文件，并将<code>demo.js</code>内容转化为<code>ast</code>对象。</p><p>同时它还提供了一个<code>printSource</code>函数，随时可以将ast的内容转换回源码，以方便调试。</p><h3 id="recast-visit-——-AST节点遍历"><a href="#recast-visit-——-AST节点遍历" class="headerlink" title="recast.visit —— AST节点遍历"></a>recast.visit —— AST节点遍历</h3><p>read.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast  = require(&#39;recast&#39;)recast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function({node}) {        console.log(node)        return false      }    });});</code></pre><p><code>recast.visit</code>将AST对象内的节点进行逐个遍历。</p><p>注意</p><ul><li><p>你想操作函数声明，就使用visitFunctionDelaration遍历，想操作赋值表达式，就使用visitExpressionStatement。 只要在 AST对象文档中定义的对象，在前面加visit，即可遍历。</p></li><li><p>通过node可以取到AST对象</p></li><li><p>每个遍历函数后必须加上return false，或者选择以下写法，否则报错</p></li></ul><pre><code class="js">#!/usr/bin/env nodeconst recast  = require(&#39;recast&#39;)recast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function(path) {        const node = path.node        printSource(node)        this.traverse(path)      }    })});</code></pre><p>调试时，如果你想输出AST对象，可以<code>console.log(node)</code></p><p>如果你想输出AST对象对应的源码，可以<code>printSource(node)</code></p><p>命令行输入<code>node read demo.js</code>进行测试。</p><blockquote><p>#!/usr/bin/env node 在所有使用recast.run()的文件顶部都需要加入这一行，它的意义我们最后再讨论。</p></blockquote><h3 id="TNT-——-判断AST对象类型"><a href="#TNT-——-判断AST对象类型" class="headerlink" title="TNT —— 判断AST对象类型"></a>TNT —— 判断AST对象类型</h3><p>TNT，即<code>recast.types.namedTypes</code>，就像它的名字一样火爆，它用来判断AST对象是否为指定的类型。</p><p><code>TNT.Node.assert()</code>，就像在机器里埋好的炸药，当机器不能完好运转时（类型不匹配），就炸毁机器(报错退出)</p><p><code>TNT.Node.check()</code>，则可以判断类型是否一致，并输出False和True</p><p>上述Node可以替换成任意AST对象，例如<code>TNT.ExpressionStatement.check(),TNT.FunctionDeclaration.assert()</code></p><p>read.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const TNT = recast.types.namedTypesrecast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function(path) {        const node = path.value        // 判断是否为ExpressionStatement，正确则输出一行字。        if(TNT.ExpressionStatement.check(node)){          console.log(&#39;这是一个ExpressionStatement&#39;)        }        this.traverse(path);      }    });});</code></pre><p>read.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const TNT = recast.types.namedTypesrecast.run(function(ast, printSource) {  recast.visit(ast, {      visitExpressionStatement: function(path) {        const node = path.node        // 判断是否为ExpressionStatement，正确不输出，错误则全局报错        TNT.ExpressionStatement.assert(node)        this.traverse(path);      }    });});</code></pre><p>命令行输入<code>node read demo.js</code>进行测试。</p><h2 id="实战：用AST修改源码，导出全部方法"><a href="#实战：用AST修改源码，导出全部方法" class="headerlink" title="实战：用AST修改源码，导出全部方法"></a>实战：用AST修改源码，导出全部方法</h2><p>exportific.js</p><p>现在，我们想让这个文件中的函数改写成能够全部导出的形式，例如</p><pre><code class="js">function add (a, b) {    return a + b}</code></pre><p>想改变为</p><pre><code class="js">exports.add = (a, b) =&gt; {  return a + b}</code></pre><p>除了使用fs.read读取文件、正则匹配替换文本、fs.write写入文件这种笨拙的方式外，我们可以用AST优雅地解决问题。</p><p>查询<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API#Node_objects" target="_blank" rel="noopener">AST对象文档</a></p><h3 id="首先，我们先用builders凭空实现一个键头函数"><a href="#首先，我们先用builders凭空实现一个键头函数" class="headerlink" title="首先，我们先用builders凭空实现一个键头函数"></a>首先，我们先用builders凭空实现一个键头函数</h3><p>exportific.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const {  identifier:id,  expressionStatement,  memberExpression,  assignmentExpression,  arrowFunctionExpression,  blockStatement} = recast.types.buildersrecast.run(function(ast, printSource) {  // 一个块级域 {}  console.log(&#39;\n\nstep1:&#39;)  printSource(blockStatement([]))  // 一个键头函数 ()=&gt;{}  console.log(&#39;\n\nstep2:&#39;)  printSource(arrowFunctionExpression([],blockStatement([])))  // add赋值为键头函数  add = ()=&gt;{}  console.log(&#39;\n\nstep3:&#39;)  printSource(assignmentExpression(&#39;=&#39;,id(&#39;add&#39;),arrowFunctionExpression([],blockStatement([]))))  // exports.add赋值为键头函数  exports.add = ()=&gt;{}  console.log(&#39;\n\nstep4:&#39;)  printSource(expressionStatement(assignmentExpression(&#39;=&#39;,memberExpression(id(&#39;exports&#39;),id(&#39;add&#39;)),    arrowFunctionExpression([],blockStatement([])))))});</code></pre><p>上面写了我们一步一步推断出<code>exports.add = ()=&gt;{}</code>的过程，从而得到具体的AST结构体。</p><p>使用<code>node exportific demo.js</code>运行可查看结果。</p><p>接下来，只需要在获得的最终的表达式中，把id(‘add’)替换成遍历得到的函数名，把参数替换成遍历得到的函数参数，把blockStatement([])替换为遍历得到的函数块级作用域，就成功地改写了所有函数！</p><p>另外，我们需要注意，在commonDivision函数内，引用了sub函数，应改写成exports.sub</p><p>exportific.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const {  identifier: id,  expressionStatement,  memberExpression,  assignmentExpression,  arrowFunctionExpression} = recast.types.buildersrecast.run(function (ast, printSource) {  // 用来保存遍历到的全部函数名  let funcIds = []  recast.types.visit(ast, {    // 遍历所有的函数定义    visitFunctionDeclaration(path) {      //获取遍历到的函数名、参数、块级域      const node = path.node      const funcName = node.id      const params = node.params      const body = node.body      // 保存函数名      funcIds.push(funcName.name)      // 这是上一步推导出来的ast结构体      const rep = expressionStatement(assignmentExpression(&#39;=&#39;, memberExpression(id(&#39;exports&#39;), funcName),        arrowFunctionExpression(params, body)))      // 将原来函数的ast结构体，替换成推导ast结构体      path.replace(rep)      // 停止遍历      return false    }  })  recast.types.visit(ast, {    // 遍历所有的函数调用    visitCallExpression(path){      const node = path.node;      // 如果函数调用出现在函数定义中，则修改ast结构      if (funcIds.includes(node.callee.name)) {        node.callee = memberExpression(id(&#39;exports&#39;), node.callee)      }      // 停止遍历      return false    }  })  // 打印修改后的ast源码  printSource(ast)})</code></pre><h3 id="一步到位，发一个最简单的exportific前端工具"><a href="#一步到位，发一个最简单的exportific前端工具" class="headerlink" title="一步到位，发一个最简单的exportific前端工具"></a>一步到位，发一个最简单的exportific前端工具</h3><p>上面讲了那么多，仍然只体现在理论阶段。</p><p>但通过简单的改写，就能通过recast制作成一个名为exportific的源码编辑工具。</p><p>以下代码添加作了两个小改动</p><ul><li>添加说明书–help，以及添加了–rewrite模式，可以直接覆盖文件或默认为导出*.export.js文件。</li><li>将之前代码最后的 printSource(ast)替换成 writeASTFile(ast,filename,rewriteMode)</li></ul><p>exportific.js</p><pre><code class="js">#!/usr/bin/env nodeconst recast = require(&quot;recast&quot;);const {  identifier: id,  expressionStatement,  memberExpression,  assignmentExpression,  arrowFunctionExpression} = recast.types.buildersconst fs = require(&#39;fs&#39;)const path = require(&#39;path&#39;)// 截取参数const options = process.argv.slice(2)//如果没有参数，或提供了-h 或--help选项，则打印帮助if(options.length===0 || options.includes(&#39;-h&#39;) || options.includes(&#39;--help&#39;)){  console.log(`    采用commonjs规则，将.js文件内所有函数修改为导出形式。    选项： -r  或 --rewrite 可直接覆盖原有文件    `)  process.exit(0)}// 只要有-r 或--rewrite参数，则rewriteMode为truelet rewriteMode = options.includes(&#39;-r&#39;) || options.includes(&#39;--rewrite&#39;)// 获取文件名const clearFileArg = options.filter((item)=&gt;{  return ![&#39;-r&#39;,&#39;--rewrite&#39;,&#39;-h&#39;,&#39;--help&#39;].includes(item)})// 只处理一个文件let filename = clearFileArg[0]const writeASTFile = function(ast, filename, rewriteMode){  const newCode = recast.print(ast).code  if(!rewriteMode){    // 非覆盖模式下，将新文件写入*.export.js下    filename = filename.split(&#39;.&#39;).slice(0,-1).concat([&#39;export&#39;,&#39;js&#39;]).join(&#39;.&#39;)  }  // 将新代码写入文件  fs.writeFileSync(path.join(process.cwd(),filename),newCode)}recast.run(function (ast, printSource) {  let funcIds = []  recast.types.visit(ast, {    visitFunctionDeclaration(path) {      //获取遍历到的函数名、参数、块级域      const node = path.node      const funcName = node.id      const params = node.params      const body = node.body      funcIds.push(funcName.name)      const rep = expressionStatement(assignmentExpression(&#39;=&#39;, memberExpression(id(&#39;exports&#39;), funcName),        arrowFunctionExpression(params, body)))      path.replace(rep)      return false    }  })  recast.types.visit(ast, {    visitCallExpression(path){      const node = path.node;      if (funcIds.includes(node.callee.name)) {        node.callee = memberExpression(id(&#39;exports&#39;), node.callee)      }      return false    }  })  writeASTFile(ast,filename,rewriteMode)})</code></pre><p>现在尝试一下</p><pre><code>node exportific demo.js</code></pre><p>已经可以在当前目录下找到源码变更后的demo.export.js文件了。</p><h3 id="npm发包"><a href="#npm发包" class="headerlink" title="npm发包"></a>npm发包</h3><p>编辑一下package.json文件</p><pre><code class="json">{  &quot;name&quot;: &quot;exportific&quot;,  &quot;version&quot;: &quot;0.0.1&quot;,  &quot;description&quot;: &quot;改写源码中的函数为可exports.XXX形式&quot;,  &quot;main&quot;: &quot;exportific.js&quot;,  &quot;bin&quot;: {    &quot;exportific&quot;: &quot;./exportific.js&quot;  },  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;wanthering&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: {    &quot;recast&quot;: &quot;^0.15.3&quot;  }}</code></pre><p>注意bin选项，它的意思是将全局命令<code>exportific</code>指向当前目录下的<code>exportific.js</code></p><p>这时，输入<code>npm link</code> 就在本地生成了一个<code>exportific</code>命令。</p><p>之后，只要哪个js文件想导出来使用，就<code>exportific XXX.js</code>一下。</p><p>这是在本地的玩法，想和大家一起分享这个前端小工具，只需要发布npm包就行了。</p><p>同时，一定要注意exportific.js文件头有</p><blockquote><p>#!/usr/bin/env node</p></blockquote><p>否则在使用时将报错。</p><h3 id="接下来，正式发布npm包！"><a href="#接下来，正式发布npm包！" class="headerlink" title="接下来，正式发布npm包！"></a>接下来，正式发布npm包！</h3><p>如果你已经有了npm 帐号，请使用<code>npm login</code>登录</p><p>如果你还没有npm帐号 <a href="https://www.npmjs.com/signup" target="_blank" rel="noopener">https://www.npmjs.com/signup</a> 非常简单就可以注册npm</p><p>然后，输入<br><code>npm publish</code></p><p>没有任何繁琐步骤，丝毫审核都没有，你就发布了一个实用的前端小工具exportific 。任何人都可以通过</p><p><code>npm i exportific -g</code></p><p>全局安装这一个插件。</p><blockquote><p>提示：==在试验教程时，请不要和我的包重名，修改一下发包名称。==</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们对javascript再熟悉不过，但透过AST的视角，最普通的js语句，却焕发出精心动魄的美感。你可以通过它批量构建任何javascript代码！</p><p>童年时，这个世界充满了新奇的玩具，再普通的东西在你眼中都如同至宝。如今，计算机语言就是你手中的大玩具，一段段AST对象的拆分组装，构建出我们所生活的网络世界。</p><p>所以不得不说软件工程师是一个幸福的工作，你心中住的仍然是那个午后的少年，永远有无数新奇等你发现，永远有无数梦想等你构建。</p><blockquote><p>作者：刘羽冲<br>链接：<a href="https://segmentfault.com/a/1190000016231512" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016231512</a><br>来源：SegmentFault 思否</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>关于AST的解析可以看看这个<a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">GitHub</a></p><p>一个可以直观导出AST的在线工具<a href="https://astexplorer.net/" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>知识点</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>高级</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端基础面试题--灰蓝宇墨</title>
    <link href="undefined2020/07/interview1/"/>
    <url>2020/07/interview1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>写在前面：这是个基础的面试题，而且他的叙述也并不是很详细，建议一边看一边实验一边百度，或许在看这个文章之前你应该看一下<a href="/2020/04/js1">《你不知道的Javascript》</a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型：undefined、null、boolean、number、string、symbol</p><p>引用数据类型：object、array、function（统称为object）</p><h3 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h3><p><code>typeof</code>对于基本数据类型来说，除了<code>null</code>都可以显示正确的类型，<code>typeof</code>对于对象来说，除了函数都会显示<code>object</code></p><blockquote><p>注意：<code>console.log(typeof NaN)   //number</code></p></blockquote><p>instanceof通过原型链来判断数据类型的</p><pre><code class="js">p1 = new Person()p1 instanceof Person // true</code></pre><p><code>Object.prototype.toString.call()</code>可以检测所有的数据类型，算是一个比较完美的方法了</p><pre><code class="js">var obj={}var arr=[]var num = 1console.log(Object.prototype.toString.call(obj))    //[object Object]console.log(Object.prototype.toString.call(arr))    //[object Array]console.log(Object.prototype.toString.call(num))    //[object Number]</code></pre><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code class="js">Object.assign()    //es6的方法</code></pre><p>Object.assign会合并对象生成一个新对象。如果对象的属性是普通类型改变之后新对象不会改变，如果是引用类型改变后新对象也会改变，所以Object.assign实际上还是浅拷贝。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p><code>JSON.parse(JSON.stringify(obj))</code></p><p>利用JSON.stringify(obj)将对象先转为json字符串，再JSON.parse(）转回为json对象可以实现深拷贝，这也是比较常用的一种方法</p><h4 id="用js实现一个深拷贝"><a href="#用js实现一个深拷贝" class="headerlink" title="用js实现一个深拷贝"></a>用js实现一个深拷贝</h4><p>其实深拷贝可以拆分成 2 步，浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象就进行递归操作，两个一结合就实现了深拷贝</p><pre><code class="js">function cloneDeep(source) {  if (!isObject(source)) return source; // 非对象返回自身  var target = Array.isArray(source) ? [] : {};  for (var key in source) {    if (source.hasOwnProperty(key)) {      if (isObject(source[key])) {        target[key] = cloneDeep(source[key]); // 注意这里      } else {        target[key] = source[key];      }    }  }  return target;}function isObject(obj) {  return typeof obj === &#39;object&#39; &amp;&amp; obj != null;}</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>在JS中，函数声明<code>function aa(){}</code>和变量声明<code>var</code>经常被隐式提升到当前作用域的顶部</p><blockquote><p>let 不会被提升，关于let的问题<a href="https://blog.csdn.net/jolab/article/details/82466362" target="_blank" rel="noopener">链接</a></p></blockquote><p>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</p><p>声明语句中的赋值部分并不会被提升，只有变量的名称被提升</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>因为函数的嵌套形成作用域的层级关系。当函数执行时，从当前作用域开始搜，没有找到的变量，会向上层作用域查找，直至全局函数，这就是作用域链。</p><p>在 JavaScript 中，作用域为 <code>function(){}</code>内的区域，称为函数作用域</p><p>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的原理就是作用域链，比函数F内部有一个函数G，函数G可以访问到函数F中的变量，那么函数G就是闭包</p><pre><code class="js">function F() {  let a = 1  window.G = function () {    console.log(a)  }}F()G() // 1</code></pre><h2 id="原型和继承"><a href="#原型和继承" class="headerlink" title="原型和继承"></a>原型和继承</h2><h3 id="js创建对象的几种方式"><a href="#js创建对象的几种方式" class="headerlink" title="js创建对象的几种方式"></a>js创建对象的几种方式</h3><p>对象字面量<code>var obj={};</code></p><p>new一个构造函数</p><pre><code class="js">function Pel(){}  p.name=&quot;hu&quot;;  p.age=&quot;25&quot;;  p.address=function(){}}var p=new Pel();</code></pre><p>new一个内置对象</p><pre><code class="js">var obj=new Object();</code></pre><p><code>Object.create()</code>创建对象</p><pre><code class="js">var test = Object.create({x:1});</code></pre><blockquote><p>关于以上几种方式创建的对象的区别，详见<a href="https://blog.csdn.net/sinat_27514587/article/details/102964631" target="_blank" rel="noopener">链接</a></p></blockquote><h3 id="JS-如何实现一个类"><a href="#JS-如何实现一个类" class="headerlink" title="JS 如何实现一个类"></a>JS 如何实现一个类</h3><p>构造函数法</p><p>缺点：用到了 this 和 prototype，编写复杂，可读性差</p><pre><code class="js">function P(name, age){  this.name = name;  this.age= age;}P.prototype.sal= function(){}var pel= new P(&quot;jj&quot;, 1);pel.sell()</code></pre><p>ES6 语法糖 class</p><pre><code class="js">class Point {  constructor(x, y) {    this.x = x;    this.y = y;  }  toString() {    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;  }}var point = new Point(2, 3);</code></pre><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>一句话解析什么是原型链</p><blockquote><p>遍历一个实列的属性时，先遍历实列对象上的属性，再遍历它的原型对象，一直遍历到Object</p></blockquote><p>任何一个类（函数）都有原型对象，原型对象至少有两个属性(constructor,proto)。<code>constructor</code>指向函数本身，<code>proto</code>指向父类原型对象</p><p>函数上有一个prototype属性，指向原型对象，通过它可以访问原型对象</p><p>函数的实列可以直接访问原型对象(因为实列上有proto指向构造函数的原型对象)</p><blockquote><p>彻底弄懂JS原型与继承，详见<a href="https://mp.weixin.qq.com/s?__biz=MzI5MjU0Mjk5MA==&mid=2247483768&idx=1&sn=4579b7bd22420d18009505a5a7454a9d&chksm=ec7e8e19db09070f8d529cb6a3f9bb425c20ac3bd4d936f4eb9e918facbe3d7e6eecdd719c4c&token=816776520&lang=zh_CN#rd" target="_blank" rel="noopener">链接</a></p></blockquote><h2 id="new和this"><a href="#new和this" class="headerlink" title="new和this"></a>new和this</h2><h3 id="使用new的时候发生了什么"><a href="#使用new的时候发生了什么" class="headerlink" title="使用new的时候发生了什么"></a>使用new的时候发生了什么</h3><p>首先是创建实例对象{}</p><p>this 变量引用该对象，同时还继承了构造函数的原型</p><p>其次属性和方法被加入到 this 引用的对象中</p><p>并且新创建的对象由 this 所引用，最后隐式的返回 this</p><h4 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h4><pre><code class="js">function objectFactory() {  var obj = new Object(),//从Object.prototype上克隆一个对象  Constructor = [].shift.call(arguments);//取得外部传入的构造器  var F=function(){};  F.prototype= Constructor.prototype;  obj=new F();//指向正确的原型  var ret = Constructor.apply(obj, arguments);//借用外部传入的构造器给obj设置属性  return typeof ret === &#39;object&#39; ? ret : obj;//确保构造器总是返回一个对象};</code></pre><blockquote><p>这里说明对象的构造函数如果有返回值而且是基本类型是会被忽略掉的，引用类型的话则作为实例被返回，详见<a href="https://blog.csdn.net/liwenfei123/article/details/80580883" target="_blank" rel="noopener">链接</a></p></blockquote><h3 id="this对象的理解"><a href="#this对象的理解" class="headerlink" title="this对象的理解"></a>this对象的理解</h3><p><code>this</code>总是指向函数的直接调用者</p><p>如果有 <code>new</code> 关键字，<code>this</code> 指向 <code>new</code> 出来的实例对象</p><p>在事件中，<code>this</code> 指向触发这个事件的对象</p><p>IE 下 <code>attachEvent</code> 中的 <code>this</code> 总是指向全局对象 <code>Window</code></p><p>箭头函数中，函数体内的this对象，就是定义时所在作用域的对象，而不是使用时所在的作用域的对象</p><pre><code class="js">function foo() {  console.log(this.a)}var a = 1foo()           //1       ​const obj = {  a: 2,  foo: foo}obj.foo()      //2​const c = new foo()   //undefined</code></pre><p>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是<code>window</code></p><p>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</p><p>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>new</code>出来的对象上，不会被任何方式改变 <code>this</code></p><p>箭头函数其实是没有<code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code>这类函数是无效的</p><h2 id="apply、call、bind"><a href="#apply、call、bind" class="headerlink" title="apply、call、bind"></a>apply、call、bind</h2><p><code>call</code>、<code>apply</code>和<code>bind</code>是Function对象自带的三个方法，都是为了改变函数体内部 <code>this</code> 的指向。</p><p><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者第一个参数都是 this 要指向的对象，也就是想指定的上下文；</p><p><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都可以利用后续参数传参；</p><p><code>bind</code> 是返回对应 函数，便于稍后调用；<code>apply</code> 、<code>call</code> 则是立即调用 </p><p>call 传入参数列表</p><p>apply 传入数组</p><p>bind() 方法会创建一个 新函数，当调用这个新函数时，新函数会以创建它时传入 bind() 方法的第一个参数 作为 this，传入 bind() 方法的 第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><pre><code class="js">var arr=[&#39;12&#39;,&#39;32&#39;,&#39;89&#39;,&#39;12&#39;,&#39;12&#39;,&#39;78&#39;,&#39;12&#39;,&#39;32&#39;];// 最简单数组去重法function unique1(array){    var n = []; //一个新的临时数组    for(var i = 0; i &lt; array.length; i++){ //遍历当前数组        if (n.indexOf(array[i]) == -1)            n.push(array[i]);    }    return n;}arr=unique1(arr);</code></pre><blockquote><p>这个太简单了，个人建议使用Set进行去重</p></blockquote><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code class="js">/**     * 按 sort 及  id 排序     * @param {Object} a     * @param {Object} b     */function   sortFun(a, b) {  return a.sort - b.sort == 0 ? a.id - b.id : a.sort - b.sort};arr.sort(sortFun)   //从小到大排序</code></pre><h3 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h3><pre><code class="js">function add(num1,num2){  var num = num1+num2;  if(num2+1&gt;100){    return num;  }else{    return add(num,num2+1)  }}var sum =add(1,2)</code></pre><h3 id="计算数组各项的重复次数"><a href="#计算数组各项的重复次数" class="headerlink" title="计算数组各项的重复次数"></a>计算数组各项的重复次数</h3><pre><code class="js">var arr=[&#39;胡将&#39;,&#39;胡将&#39;,&#39;hujiang&#39;,&#39;胡将&#39;,&#39;胡江&#39;,&#39;hujiang&#39;];var obj={};arr.sort();    //先排序for(var i=0;i&lt;arr.length;){    var con=0;    for(var j=i;j&lt;arr.length;j++){        if(arr[i]===arr[j]){            con++        }    }    obj[arr[i]]=con;     i=i+con;    //跳过重复的值}console.log(obj);  //{ hujiang: 2, &#39;胡将&#39;: 3, &#39;胡江&#39;: 1 }</code></pre><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务/微任务"></a>宏任务/微任务</h3><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><p>macro-task(宏任务)：当前调用栈中执行的任务称为宏任务。包括：script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</p><p>micro-task(微任务)： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。包括：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p><p>不同类型的任务会进入对应的Event Queue，宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</p><blockquote><p>这个东西没给例子，可能很难理解，我之前看的这个<a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener">链接</a></p></blockquote><h3 id="一句话解析下什么是event-loop"><a href="#一句话解析下什么是event-loop" class="headerlink" title="一句话解析下什么是event loop"></a>一句话解析下什么是event loop</h3><p>主线程运行的时候会生成堆（heap）和栈（stack）</p><p>js 从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中</p><p>当程序调用外部的 API 时（比如 ajax、setTimeout 等），会将此类异步任务挂起，继续执行执行栈中的任务。等异步任务返回结果后，再按照顺序排列到事件队列中</p><p>主线程先将执行栈中的同步任务清空，然后检查事件队列中是否有任务，如果有，就将第一个事件对应的回调推到执行栈中执行，若在执行过程中遇到异步任务，则继续将这个异步任务排列到事件队列中</p><p>主线程每次将执行栈清空后，就去事件队列中检查是否有任务，如果有，就每次取出一个推到执行栈中执行，这个循环往复的过程被称为“Event Loop 事件循环”</p><h2 id="浏览器页面渲染过程"><a href="#浏览器页面渲染过程" class="headerlink" title="浏览器页面渲染过程"></a>浏览器页面渲染过程</h2><p>浏览器渲染页面的一般过程：</p><ol><li><p>浏览器解析html源码，然后创建一个 DOM树。并行请求 css/image/js在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM树的根节点就是 documentElement，对应的是html标签。</p></li><li><p>浏览器解析CSS代码，计算出最终的样式数据。构建CSSOM树。对CSS代码中非法的语法它会直接忽略掉。解析CSS的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html中的style。</p></li><li><p>DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和DOM树有点像，但是是有区别的。</p><p>DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的css属性。</p></li><li><p>一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p></li></ol><p>以上四个步骤并不是一次性顺序完成的。如果DOM或者CSSOM被修改，以上过程会被重复执行。实际上，CSS和JavaScript往往会多次修改DOM或者CSSOM。</p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>原作者给的详情<a href="https://mp.weixin.qq.com/s?__biz=MzI5MjU0Mjk5MA==&mid=2247483826&idx=2&sn=e38f5e5b928a6aa5c15371505b4e8d71&chksm=ec7e8ed3db0907c545393ea90ee8bfd7dc944ff013957228b200d66929767251b1982340d036&token=816776520&lang=zh_CN#rd" target="_blank" rel="noopener">链接</a></p><p>我之前看到的另外一篇比较好的文章<a href="https://imweb.io/topic/5795dcb6fb312541492eda8c" target="_blank" rel="noopener">链接</a></p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>盒模型的组成，由里向外content,padding,border,margin.</p><p><strong>在IE盒子模型中，width表示content+padding+border这三个部分的宽度</strong></p><p><strong>在标准的盒子模型中，width指content部分的宽度</strong></p><p><code>box-sizing</code>的使用</p><pre><code class="css">box-sizing: content-box; //是W3C盒子模型box-sizing: border-box; //是IE盒子模型</code></pre><p><code>box-sizing</code>的默认属性是<code>content-box</code></p><h2 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h2><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><p>行内元素: <code>text-align: center</code></p><p>块级元素:</p><pre><code class="css">// 方法1 margin: 0 auto;// 方法2position:absolute;left:50%;transform:translateX(-50%);// 方法3display:flex;justify-content: center;</code></pre><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p>设置line-height 等于height</p><pre><code class="css">// 方法一position：absolute;top:50%;transform:translateY(-50%);// 方法二display:flex;align-items: center;// 方法三display:table;display:table-cell;vertical-align: middle;</code></pre><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>一边百度一边看，回想起来不少知识，但是这个还是相对基础的部分，之后再找点难一些的，当然，基础不稳地动山摇，还是要好好复习基础的</p><p>祝各位找到合适自己的公司！奥里给！</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>题库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Curriculum Vitae</title>
    <link href="undefined2020/07/cv/"/>
    <url>2020/07/cv/</url>
    
    <content type="html"><![CDATA[<h1 id="赵英博"><a href="#赵英博" class="headerlink" title="赵英博"></a>赵英博</h1><h2 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h2><p>电话：15143211127<br>邮箱：<a href="mailto:zhaoyingbo@live.cn">zhaoyingbo@live.cn</a><br>地址：长春<br>个人网站：<a href="https://lacus.site">https://lacus.site</a><br>微信：15143211127<br>求职意向：web前端开发</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="Toast题库（2020-06-18-至今）"><a href="#Toast题库（2020-06-18-至今）" class="headerlink" title="Toast题库（2020.06.18-至今）"></a>Toast题库（2020.06.18-至今）</h3><ul><li><p>项目描述：使用Vue开发，实现背题，题目检索，背题进度保存，用户反馈等功能</p></li><li><p>项目职责：</p><ol><li><p>负责页面UI布局，不使用第三方UI库，自行封装组件，实现主题切换，使用rem对各种机型进行适配</p></li><li><p>使用DFA算法实现题目检索</p></li><li><p>使用LocalStorage存储用户背题进度</p></li><li><p>使用PWA加速开屏速度以及实现本地化</p></li><li><p>使用Docker，CDN等技术进行部署</p></li></ol></li><li><p>项目业绩：从设计到部署，独立完成整个项目第一版并上线，共用时三天，运行过程中无bug，抢在考试前一周发布，获得大量用户好评</p></li><li><p>项目地址：<a href="https://tiku.lacus.site/" target="_blank" rel="noopener">https://tiku.lacus.site/</a></p></li></ul><h3 id="Cherry课表成绩查询（2020-02-09-至今）"><a href="#Cherry课表成绩查询（2020-02-09-至今）" class="headerlink" title="Cherry课表成绩查询（2020.02.09-至今）"></a>Cherry课表成绩查询（2020.02.09-至今）</h3><ul><li><p>项目描述：使用Python爬取教务系统课表以及成绩信息，并使用前端进行展示</p></li><li><p>项目职责：</p><ol><li><p>整体的项目规划，分工协调</p></li><li><p>负责页面UI布局，少量使用ElementUI</p></li><li><p>处理后端发来的课表以及成绩信息，保存在LocalStorage中，处理数据实现自定义课表功能并防止与源课表冲突</p></li><li><p>使用Python+Flask进行后端开发，对模块编写单元测试</p></li><li><p>使用swagger进行后端文档编写</p></li></ol></li><li><p>项目业绩：带领三人小组一周内完成第一版并上线，后期还添加了小游戏等功能，目前日均PV3.5k、UV1.5k</p></li><li><p>项目地址：<a href="https://cherry.lacus.site/" target="_blank" rel="noopener">https://cherry.lacus.site/</a></p></li></ul><h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><h3 id="长春理工大学"><a href="#长春理工大学" class="headerlink" title="长春理工大学"></a>长春理工大学</h3><p>长春 | 软件工程 | 本科 | 计算机科学技术</p><p>2017.09 - 2021.06</p><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><p>熟悉JavaScript，了解TypeScript，掌握ES6以上常用语法</p><p>熟练使用Vue.js框架开发项目</p><p>熟悉Node.js，使用过Serverless开发项目</p><p>熟悉小程序开发，曾独立开发过两个项目，其中一个累计用户11.1k</p><p>熟悉Python，曾使用Flask框架开发过3个项目的后端</p><p>掌握MongoDB以及MySQl的使用与操作</p><p>熟练使用git、svn版本管理器</p><p>了解Sass、Stylus 等 CSS预处理器</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>自学能力强，能快速接受使用新知识</p><p>良好的分析解决问题能力，和自我管理能力</p><p>具有面向对象设计思想，具备独立分析和解决问题的能力</p><p>有较好的团队协作和沟通能力，有强烈的责任心</p><h2 id="PDF"><a href="#PDF" class="headerlink" title="PDF"></a>PDF</h2><p>中文简历：<a href="http://assets.lacus.site/cv/%E8%B5%B5%E8%8B%B1%E5%8D%9A_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91_15143211127.pdf" target="_blank" rel="noopener">链接</a></p><p>英文简历：<a href="http://assets.lacus.site/cv/%E8%B5%B5%E8%8B%B1%E5%8D%9A_webFrontend_15143211127.pdf" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>文件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>简历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--收尾</title>
    <link href="undefined2020/07/js-api-others/"/>
    <url>2020/07/js-api-others/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><p>将字符串转化为JSON</p><pre><code class="js">const json = &#39;{&quot;result&quot;:true, &quot;count&quot;:42}&#39;;const obj = JSON.parse(json);console.log(obj.count);// expected output: 42console.log(obj.result);// expected output: true</code></pre><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p>将JSON转化为字符串</p><pre><code class="js">console.log(JSON.stringify({ x: 5, y: 6 }));// expected output: &quot;{&quot;x&quot;:5,&quot;y&quot;:6}&quot;console.log(JSON.stringify([new Number(3), new String(&#39;false&#39;), new Boolean(false)]));// expected output: &quot;[3,&quot;false&quot;,false]&quot;console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol(&#39;&#39;)] }));// expected output: &quot;{&quot;x&quot;:[10,null,null,null]}&quot;console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));// expected output: &quot;&quot;2006-01-02T15:04:05.000Z&quot;&quot;</code></pre><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>处理时间的函数，平时就用个时间戳<code>new Date().getTime()</code>剩下得几乎用不到，<a href="https://devdocs.io/javascript/global_objects/date" target="_blank" rel="noopener">文档链接</a></p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>数学用函数，只整理常用的，其余看文档，<a href="https://devdocs.io/javascript/global_objects/math" target="_blank" rel="noopener">文档链接</a></p><h3 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs"></a>Math.abs</h3><p>取绝对值</p><pre><code class="js">function difference(a, b) {  return Math.abs(a - b);}console.log(difference(3, 5));// expected output: 2console.log(difference(5, 3));// expected output: 2console.log(difference(1.23456, 7.89012));// expected output: 6.6555599999999995</code></pre><h3 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil"></a>Math.ceil</h3><p>返回大于等于给定量的最小整数</p><pre><code class="js">console.log(Math.ceil(.95));// expected output: 1console.log(Math.ceil(4));// expected output: 4console.log(Math.ceil(7.004));// expected output: 8console.log(Math.ceil(-7.004));// expected output: -7</code></pre><h3 id="Math-floor"><a href="#Math-floor" class="headerlink" title="Math.floor"></a>Math.floor</h3><p>返回小于给定量的最大整数</p><pre><code class="js">console.log(Math.floor(5.95));// expected output: 5console.log(Math.floor(5.05));// expected output: 5console.log(Math.floor(5));// expected output: 5console.log(Math.floor(-5.05));// expected output: -6</code></pre><h3 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h3><p>返回给定值最大的一个</p><pre><code class="js">console.log(Math.max(1, 3, 2));// expected output: 3console.log(Math.max(-1, -3, -2));// expected output: -1const array1 = [1, 3, 2];console.log(Math.max(...array1));// expected output: 3</code></pre><h3 id="Math-min"><a href="#Math-min" class="headerlink" title="Math.min"></a>Math.min</h3><p>返回给定值最小的那个</p><pre><code class="js">console.log(Math.min(2, 3, 1));// expected output: 1console.log(Math.min(-2, -3, -1));// expected output: -3const array1 = [2, 3, 1];console.log(Math.min(...array1));// expected output: 1</code></pre><h3 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow"></a>Math.pow</h3><p>返回给定的量指定次数的幂</p><pre><code class="js">console.log(Math.pow(7, 3));// expected output: 343console.log(Math.pow(4, 0.5));// expected output: 2console.log(Math.pow(7, -2));// expected output: 0.02040816326530612//                  (1/49)console.log(Math.pow(-7, 0.5));// expected output: NaN</code></pre><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random"></a>Math.random</h3><p>返回一个<code>[0,1)</code>之间随机的数</p><pre><code class="js">function getRandomInt(max) {  return Math.floor(Math.random() * Math.floor(max));}console.log(getRandomInt(3));// expected output: 0, 1 or 2console.log(getRandomInt(1));// expected output: 0console.log(Math.random());// expected output: a number between 0 and 1</code></pre><h3 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round"></a>Math.round</h3><p>返回给定数的舍入后的整数</p><pre><code class="js">console.log(Math.round(0.9));// expected output: 1console.log(Math.round(5.95), Math.round(5.5), Math.round(5.05));// expected output: 6 6 5console.log(Math.round(-5.05), Math.round(-5.5), Math.round(-5.95));// expected output: -5 -5 -6</code></pre><h3 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign"></a>Math.sign</h3><p>返回给定数的符号，正1负-1零0</p><pre><code class="js">console.log(Math.sign(3));// expected output: 1console.log(Math.sign(-3));// expected output: -1console.log(Math.sign(0));// expected output: 0console.log(Math.sign(&#39;-3&#39;));// expected output: -1</code></pre><h3 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt"></a>Math.sqrt</h3><p>返回给定数的平方根</p><pre><code class="js">function calcHypotenuse(a, b) {  return (Math.sqrt((a * a) + (b * b)));}console.log(calcHypotenuse(3, 4));// expected output: 5console.log(calcHypotenuse(5, 12));// expected output: 13console.log(calcHypotenuse(0, 0));// expected output: 0</code></pre><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>数字类型，<a href="https://devdocs.io/javascript/global_objects/number" target="_blank" rel="noopener">文档链接</a></p><h3 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger"></a>Number.isInteger</h3><p>判定给定值是否是整数</p><pre><code class="js">function fits(x, y) {  if (Number.isInteger(y / x)) {    return &#39;Fits!&#39;;  }  return &#39;Does NOT fit!&#39;;}console.log(fits(5, 10));// expected output: &quot;Fits!&quot;console.log(fits(5, 11));// expected output: &quot;Does NOT fit!&quot;</code></pre><h3 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite"></a>Number.isFinite</h3><p>判定给定值是否是有限数</p><pre><code class="js">console.log(Number.isFinite(1 / 0));// expected output: falseconsole.log(Number.isFinite(10 / 5));// expected output: trueconsole.log(Number.isFinite(0 / 0));// expected output: false</code></pre><h3 id="number-toPrecision"><a href="#number-toPrecision" class="headerlink" title="number.toPrecision"></a>number.toPrecision</h3><p>方法返回表示Number对象到指定的精度的字符串</p><pre><code class="js">function precise(x) {  return Number.parseFloat(x).toPrecision(4);}console.log(precise(123.456));// expected output: &quot;123.5&quot;console.log(precise(0.004));// expected output: &quot;0.004000&quot;console.log(precise(&#39;1.23e+5&#39;));// expected output: &quot;1.230e+5&quot;</code></pre><h3 id="Number-MAX-VALUE"><a href="#Number-MAX-VALUE" class="headerlink" title="Number.MAX_VALUE"></a>Number.MAX_VALUE</h3><p>js中最大正整数</p><h3 id="Number-MAX-SAFE-INTEGER"><a href="#Number-MAX-SAFE-INTEGER" class="headerlink" title="Number.MAX_SAFE_INTEGER"></a>Number.MAX_SAFE_INTEGER</h3><p>js最大安全整数</p><h3 id="Number-MIN-SAFE-INTEGER"><a href="#Number-MIN-SAFE-INTEGER" class="headerlink" title="Number.MIN_SAFE_INTEGER"></a>Number.MIN_SAFE_INTEGER</h3><p>js最小安全整数</p><h3 id="Number-MIN-VALUE"><a href="#Number-MIN-VALUE" class="headerlink" title="Number.MIN_VALUE"></a>Number.MIN_VALUE</h3><p>js最小正整数值</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>是ES6新增的，相较于对象就是属性名可以为任意值</p><h3 id="map-iterator"><a href="#map-iterator" class="headerlink" title="map.@@iterator"></a>map.@@iterator</h3><p>很明显，map是可以迭代的</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1[Symbol.iterator]();for (let item of iterator1) {  console.log(item);}// expected output: Array [&quot;0&quot;, &quot;foo&quot;]// expected output: Array [1, &quot;bar&quot;]</code></pre><h3 id="map-clear"><a href="#map-clear" class="headerlink" title="map.clear"></a>map.clear</h3><p>清空map</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;baz&#39;);map1.set(1, &#39;foo&#39;);console.log(map1.size);// expected output: 2map1.clear();console.log(map1.size);// expected output: 0</code></pre><h3 id="map-delete"><a href="#map-delete" class="headerlink" title="map.delete"></a>map.delete</h3><p>移出map中的某个元素</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.delete(&#39;bar&#39;));// expected result: true// (true indicates successful removal)console.log(map1.has(&#39;bar&#39;));// expected result: false</code></pre><h3 id="map-entries"><a href="#map-entries" class="headerlink" title="map.entries"></a>map.entries</h3><p>返回一个可迭代的对象，每次返回键值对的数组</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1.entries();console.log(iterator1.next().value);// expected output: [&quot;0&quot;, &quot;foo&quot;]console.log(iterator1.next().value);// expected output: [1, &quot;bar&quot;]</code></pre><h3 id="map-forEach"><a href="#map-forEach" class="headerlink" title="map.forEach"></a>map.forEach</h3><p>对每个键值对都执行一次某个操作</p><pre><code class="js">function logMapElements(value, key, map) {  console.log(`m[${key}] = ${value}`);}new Map([[&#39;foo&#39;, 3], [&#39;bar&#39;, {}], [&#39;baz&#39;, undefined]])  .forEach(logMapElements);// expected output: &quot;m[foo] = 3&quot;// expected output: &quot;m[bar] = [object Object]&quot;// expected output: &quot;m[baz] = undefined&quot;</code></pre><h3 id="map-get"><a href="#map-get" class="headerlink" title="map.get"></a>map.get</h3><p>获取map的某个键对应的值，没有返回undefined</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.get(&#39;bar&#39;));// expected output: &quot;foo&quot;console.log(map1.get(&#39;baz&#39;));// expected output: undefined</code></pre><h3 id="map-has"><a href="#map-has" class="headerlink" title="map.has"></a>map.has</h3><p>查询某个键是否存在</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.has(&#39;bar&#39;));// expected output: trueconsole.log(map1.has(&#39;baz&#39;));// expected output: false</code></pre><h3 id="map-keys"><a href="#map-keys" class="headerlink" title="map.keys"></a>map.keys</h3><p>返回一个可迭代的对象，值是map的键</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1.keys();console.log(iterator1.next().value);// expected output: &quot;0&quot;console.log(iterator1.next().value);// expected output: 1</code></pre><h3 id="map-set"><a href="#map-set" class="headerlink" title="map.set"></a>map.set</h3><p>设置一个键值对到map里边</p><pre><code class="js">const map1 = new Map();map1.set(&#39;bar&#39;, &#39;foo&#39;);console.log(map1.get(&#39;bar&#39;));// expected output: &quot;foo&quot;console.log(map1.get(&#39;baz&#39;));// expected output: undefined</code></pre><h3 id="map-size"><a href="#map-size" class="headerlink" title="map.size"></a>map.size</h3><p>返回map的大小，也就是多少个元素</p><pre><code class="js">const map1 = new Map();map1.set(&#39;a&#39;, &#39;alpha&#39;);map1.set(&#39;b&#39;, &#39;beta&#39;);map1.set(&#39;g&#39;, &#39;gamma&#39;);console.log(map1.size);// expected output: 3</code></pre><h3 id="map-values"><a href="#map-values" class="headerlink" title="map.values"></a>map.values</h3><p>返回一个可迭代对象，值是map的值</p><pre><code class="js">const map1 = new Map();map1.set(&#39;0&#39;, &#39;foo&#39;);map1.set(1, &#39;bar&#39;);const iterator1 = map1.values();console.log(iterator1.next().value);// expected output: &quot;foo&quot;console.log(iterator1.next().value);// expected output: &quot;bar&quot;</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>和Map的api是一样的，不过不允许存在重复的值，所以可以用来进行数组去重，<a href="https://devdocs.io/javascript/global_objects/set" target="_blank" rel="noopener">文档链接</a></p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--Object</title>
    <link href="undefined2020/07/js-api-object/"/>
    <url>2020/07/js-api-object/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>将一个或者多个对象的可枚举属性拷贝到源对象上，会改变源对象，如果<code>key</code>相同后边会覆盖前边的</p><pre><code class="js">const target = { a: 1, b: 2 };const source = { b: 4, c: 5 };const returnedTarget = Object.assign(target, source);console.log(target);// expected output: Object { a: 1, b: 4, c: 5 }console.log(returnedTarget);// expected output: Object { a: 1, b: 4, c: 5 }</code></pre><h3 id="object-constructor"><a href="#object-constructor" class="headerlink" title="object.constructor"></a>object.constructor</h3><p>返回构造函数本身</p><pre><code class="js">var o = {};o.constructor === Object; // truevar o = new Object;o.constructor === Object; // truevar a = [];a.constructor === Array; // truevar a = new Array;a.constructor === Array; // truevar n = new Number(3);n.constructor === Number; // true</code></pre><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h3><p>创建一个新对象，传入的参数就是新对象的原型</p><pre><code class="js">const person = {  isHuman: false,  printIntroduction: function() {    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);  }};const me = Object.create(person);me.name = &#39;Matthew&#39;; // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;me.isHuman = true; // inherited properties can be overwrittenme.printIntroduction();// expected output: &quot;My name is Matthew. Am I human? true&quot;</code></pre><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties"></a>Object.defineProperties</h3><p>方法直接在对象上定义了新的或修改现有的属性，并返回该对象</p><pre><code class="js">const object1 = {};Object.defineProperties(object1, {  property1: {    value: 42,    writable: true  },  property2: {}});console.log(object1.property1);// expected output: 42</code></pre><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>方法直接在对象上定义了新的或修改现有的属性，并返回该对象</p><pre><code class="js">const object1 = {};Object.defineProperty(object1, &#39;property1&#39;, {  value: 42,  writable: false});object1.property1 = 77;// throws an error in strict modeconsole.log(object1.property1);// expected output: 42</code></pre><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h3><p>可以获取对象的一个可迭代属性，value是一个数组<code>[key,val]</code>，但是是没有顺序的，如果需要顺序可以使用<code>Object.entries(obj).sort((a, b) =&gt; a[0] - b[0]);</code></p><pre><code class="js">const object1 = {  a: &#39;somestring&#39;,  b: 42};for (const [key, value] of Object.entries(object1)) {  console.log(`${key}: ${value}`);}// expected output:// &quot;a: somestring&quot;// &quot;b: 42&quot;// order is not guaranteed</code></pre><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h3><p>冻结一个对象，不能添加删除或者修改，当然对象里边的对象的内容仍可被修改</p><pre><code class="js">const obj = {  prop: 42};Object.freeze(obj);obj.prop = 33;// Throws an error in strict modeconsole.log(obj.prop);// expected output: 42</code></pre><h3 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h3><p>用于将键值对数组转化为对象，本质上是调用的数组的迭代器</p><pre><code class="js">const entries = new Map([  [&#39;foo&#39;, &#39;bar&#39;],  [&#39;baz&#39;, 42]]);const obj = Object.fromEntries(entries);console.log(obj);// expected output: Object { foo: &quot;bar&quot;, baz: 42 }</code></pre><h3 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h3><p>获取对象中某一个属性的信息，是否可写，<code>getter,setter</code>之类的</p><pre><code class="js">const object1 = {  property1: 42};const descriptor1 = Object.getOwnPropertyDescriptor(object1, &#39;property1&#39;);console.log(descriptor1.configurable);// expected output: trueconsole.log(descriptor1.value);// expected output: 42</code></pre><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>获取对象中所有属性的信息，就是上一个的集合</p><pre><code class="js">const object1 = {  property1: 42};const descriptors1 = Object.getOwnPropertyDescriptors(object1);console.log(descriptors1.property1.writable);// expected output: trueconsole.log(descriptors1.property1.value);// expected output: 42</code></pre><h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames"></a>Object.getOwnPropertyNames</h3><p>获取全部属性名，包含不可枚举属性</p><pre><code class="js">const object1 = {  a: 1,  b: 2,  c: 3};console.log(Object.getOwnPropertyNames(object1));// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]var my_obj = Object.create({}, {  getFoo: {    value: function() { return this.foo; },    enumerable: false  }});my_obj.foo = 1;console.log(Object.getOwnPropertyNames(my_obj).sort()); // logs [&quot;foo&quot;, &quot;getFoo&quot;]</code></pre><h3 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols"></a>Object.getOwnPropertySymbols</h3><p>获取对象中全部符号属性</p><pre><code class="js">const object1 = {};const a = Symbol(&#39;a&#39;);const b = Symbol.for(&#39;b&#39;);object1[a] = &#39;localSymbol&#39;;object1[b] = &#39;globalSymbol&#39;;const objectSymbols = Object.getOwnPropertySymbols(object1);console.log(objectSymbols);// expected output: Array [Symbol(a), Symbol(b)]</code></pre><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf"></a>Object.getPrototypeOf</h3><p>获取对象的原型对象</p><pre><code class="js">const prototype1 = {};const object1 = Object.create(prototype1);console.log(Object.getPrototypeOf(object1) === prototype1);// expected output: true</code></pre><h3 id="object-hasOwnProperty"><a href="#object-hasOwnProperty" class="headerlink" title="object.hasOwnProperty"></a>object.hasOwnProperty</h3><p>判断一个对象是否有该属性，而不是继承来的</p><pre><code class="js">const object1 = {};object1.property1 = 42;console.log(object1.hasOwnProperty(&#39;property1&#39;));// expected output: trueconsole.log(object1.hasOwnProperty(&#39;toString&#39;));// expected output: falseconsole.log(object1.hasOwnProperty(&#39;hasOwnProperty&#39;));// expected output: false</code></pre><blockquote><p>这个函数能被直接覆写，遇到这种情况使用<code>Object.hasOwnProperty.call()</code></p></blockquote><h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h3><p>用于判定两个值是否相同，不限于对象</p><pre><code class="js">Object.is(&#39;foo&#39;, &#39;foo&#39;);     // trueObject.is(window, window);   // trueObject.is(&#39;foo&#39;, &#39;bar&#39;);     // falseObject.is([], []);           // falsevar test = { a: 1 };Object.is(test, test);       // trueObject.is(null, null);       // true// Special CasesObject.is(0, -0);            // falseObject.is(-0, -0);           // trueObject.is(NaN, 0/0);         // true</code></pre><h3 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible"></a>Object.isExtensible</h3><p>用来判断一个对象是否是可拓展的</p><pre><code class="js">const object1 = {};console.log(Object.isExtensible(object1));// expected output: trueObject.preventExtensions(object1);console.log(Object.isExtensible(object1));// expected output: false</code></pre><h3 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen"></a>Object.isFrozen</h3><p>用于确认对象是否被冻结</p><pre><code class="js">const object1 = {  property1: 42};console.log(Object.isFrozen(object1));// expected output: falseObject.freeze(object1);console.log(Object.isFrozen(object1));// expected output: true</code></pre><h3 id="object-isPrototypeOf"><a href="#object-isPrototypeOf" class="headerlink" title="object.isPrototypeOf"></a>object.isPrototypeOf</h3><p>用于判定对象是否在另一个对象的原型链中</p><pre><code class="js">function Foo() {}function Bar() {}function Baz() {}Bar.prototype = Object.create(Foo.prototype);Baz.prototype = Object.create(Bar.prototype);var baz = new Baz();console.log(Baz.prototype.isPrototypeOf(baz)); // trueconsole.log(Bar.prototype.isPrototypeOf(baz)); // trueconsole.log(Foo.prototype.isPrototypeOf(baz)); // trueconsole.log(Object.prototype.isPrototypeOf(baz)); // true</code></pre><h3 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed"></a>Object.isSealed</h3><p>用来判断对象是否被<strong>密封</strong>，如果对象设置为不可拓展或者设置<code>configurable: false</code>会返回<code>true</code></p><pre><code class="js">// Objects aren&#39;t sealed by default.var empty = {};Object.isSealed(empty); // === false// If you make an empty object non-extensible,// it is vacuously sealed.Object.preventExtensions(empty);Object.isSealed(empty); // === true// The same is not true of a non-empty object,// unless its properties are all non-configurable.var hasProp = { fee: &#39;fie foe fum&#39; };Object.preventExtensions(hasProp);Object.isSealed(hasProp); // === false// But make them all non-configurable// and the object becomes sealed.Object.defineProperty(hasProp, &#39;fee&#39;, {  configurable: false});Object.isSealed(hasProp); // === true// The easiest way to seal an object, of course,// is Object.seal.var sealed = {};Object.seal(sealed);Object.isSealed(sealed); // === true// A sealed object is, by definition, non-extensible.Object.isExtensible(sealed); // === false// A sealed object might be frozen,// but it doesn&#39;t have to be.Object.isFrozen(sealed); // === true // (all properties also non-writable)var s2 = Object.seal({ p: 3 });Object.isFrozen(s2); // === false // (&#39;p&#39; is still writable)var s3 = Object.seal({ get p() { return 0; } });Object.isFrozen(s3); // === true// (only configurability matters for accessor properties)</code></pre><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys"></a>Object.keys</h3><p>获取对象的键，只有可枚举属性</p><pre><code class="js">// simple arrayvar arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];console.log(Object.keys(arr)); // console: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]// array like objectvar obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; };console.log(Object.keys(obj)); // console: [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]// array like object with random key orderingvar anObj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; };console.log(Object.keys(anObj)); // console: [&#39;2&#39;, &#39;7&#39;, &#39;100&#39;]// getFoo is a property which isn&#39;t enumerablevar myObj = Object.create({}, {  getFoo: {    value: function () { return this.foo; }  } });myObj.foo = 1;console.log(Object.keys(myObj)); // console: [&#39;foo&#39;]</code></pre><h3 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions"></a>Object.preventExtensions</h3><p>禁止对象进行拓展</p><pre><code class="js">// Object.preventExtensions returns the object// being made non-extensible.var obj = {};var obj2 = Object.preventExtensions(obj);obj === obj2; // true// Objects are extensible by default.var empty = {};Object.isExtensible(empty); // === true// ...but that can be changed.Object.preventExtensions(empty);Object.isExtensible(empty); // === false// Object.defineProperty throws when adding// a new property to a non-extensible object.var nonExtensible = { removable: true };Object.preventExtensions(nonExtensible);Object.defineProperty(nonExtensible, &#39;new&#39;, {  value: 8675309}); // throws a TypeError// In strict mode, attempting to add new properties// to a non-extensible object throws a TypeError.function fail() {  &#39;use strict&#39;;  // throws a TypeError  nonExtensible.newProperty = &#39;FAIL&#39;;}fail();</code></pre><h3 id="object-propertyIsEnumerable"><a href="#object-propertyIsEnumerable" class="headerlink" title="object.propertyIsEnumerable"></a>object.propertyIsEnumerable</h3><p>用于判定指定的属性是否可枚举</p><pre><code class="js">const object1 = {};const array1 = [];object1.property1 = 42;array1[0] = 42;console.log(object1.propertyIsEnumerable(&#39;property1&#39;));// expected output: trueconsole.log(array1.propertyIsEnumerable(0));// expected output: trueconsole.log(array1.propertyIsEnumerable(&#39;length&#39;));// expected output: false</code></pre><h3 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal"></a>Object.seal</h3><p>密封一个对象，密封之前的对象允许修改值，密封之后不允许删除属性，新增的属性不允许修改值</p><pre><code class="js">var obj = {  prop: function() {},  foo: &#39;bar&#39;};// New properties may be added, existing properties// may be changed or removed.obj.foo = &#39;baz&#39;;obj.lumpy = &#39;woof&#39;;delete obj.prop;var o = Object.seal(obj);o === obj; // trueObject.isSealed(obj); // === true// Changing property values on a sealed object// still works.obj.foo = &#39;quux&#39;;// But you can&#39;t convert data properties to accessors,// or vice versa.Object.defineProperty(obj, &#39;foo&#39;, {  get: function() { return &#39;g&#39;; }}); // throws a TypeError// Now any changes, other than to property values,// will fail.obj.quaxxor = &#39;the friendly duck&#39;;// silently doesn&#39;t add the propertydelete obj.foo;// silently doesn&#39;t delete the property// ...and in strict mode such attempts// will throw TypeErrors.function fail() {  &#39;use strict&#39;;  delete obj.foo; // throws a TypeError  obj.sparky = &#39;arf&#39;; // throws a TypeError}fail();// Attempted additions through// Object.defineProperty will also throw.Object.defineProperty(obj, &#39;ohai&#39;, {  value: 17}); // throws a TypeErrorObject.defineProperty(obj, &#39;foo&#39;, {  value: &#39;eit&#39;}); // changes existing property value</code></pre><h3 id="object-toString"><a href="#object-toString" class="headerlink" title="object.toString"></a>object.toString</h3><p>将对象字符串化，正常返回<code>[Object Object]</code>，可以使用<code>Symbol.toStringTag 与 Symbol.hasInstance</code>改变第二个tag，详见你不知道的js下</p><pre><code class="js">function Dog(name) {  this.name = name;}const dog1 = new Dog(&#39;Gabby&#39;);Dog.prototype.toString = function dogToString() {  return `${this.name}`;};console.log(dog1.toString());// expected output: &quot;Gabby&quot;</code></pre><h3 id="object-valueOf"><a href="#object-valueOf" class="headerlink" title="object.valueOf"></a>object.valueOf</h3><p>方法返回指定对象的原始值</p><pre><code class="js">function MyNumberType(n) {  this.number = n;}MyNumberType.prototype.valueOf = function() {  return this.number;};const object1 = new MyNumberType(4);console.log(object1 + 3);// expected output: 7</code></pre><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values"></a>Object.values</h3><p>返回对象的可枚举的属性值的数组用于<code>for in</code>循环</p><pre><code class="js">const object1 = {  a: &#39;somestring&#39;,  b: 42,  c: false};console.log(Object.values(object1));// expected output: Array [&quot;somestring&quot;, 42, false]</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--String</title>
    <link href="undefined2020/06/js-api-string/"/>
    <url>2020/06/js-api-string/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="string-iterator"><a href="#string-iterator" class="headerlink" title="string.@@iterator"></a>string.@@iterator</h3><p>string类型是可迭代的</p><pre><code class="js">let str = &#39;test string&#39;let ite = str[Symbol.iterator]()console.log(ite.next().value) // t</code></pre><h3 id="string-charAt"><a href="#string-charAt" class="headerlink" title="string.charAt"></a>string.charAt</h3><p>获取字符串某一位的内容，无参数默认第一位，下标从0开始</p><pre><code class="js">let str = &#39;text string&#39;console.log(str.charAt()) // tconsole.log(str.charAt(6)) // s </code></pre><h3 id="string-concat"><a href="#string-concat" class="headerlink" title="string.concat"></a>string.concat</h3><p>用于拼接一个或者多个字符串,返回一个新的字符串不会改变源字符串</p><pre><code class="js">let str = &#39;test string&#39;let con_str = &#39; is cool!&#39;console.log(str.concat(con_str)) // test string is cool!</code></pre><h3 id="string-endsWith"><a href="#string-endsWith" class="headerlink" title="string.endsWith"></a>string.endsWith</h3><p>查看该字符串是否以传入的字符串结尾，可以传入裁剪的字符串长度</p><pre><code class="js">var str = &#39;To be, or not to be, that is the question.&#39;;console.log(str.endsWith(&#39;question.&#39;)); // trueconsole.log(str.endsWith(&#39;to be&#39;));     // falseconsole.log(str.endsWith(&#39;to be&#39;, 19)); // true</code></pre><h3 id="string-includes"><a href="#string-includes" class="headerlink" title="string.includes"></a>string.includes</h3><p>查看传入字符串能不能在该字符串中找到，返回<code>boolean</code></p><pre><code class="js">const sentence = &#39;The quick brown fox jumps over the lazy dog.&#39;;const word = &#39;fox&#39;;console.log(`The word &quot;${word}&quot; ${sentence.includes(word) ? &#39;is&#39; : &#39;is not&#39;} in the sentence`);// expected output: &quot;The word &quot;fox&quot; is in the sentence&quot;</code></pre><h3 id="string-indexOf"><a href="#string-indexOf" class="headerlink" title="string.indexOf"></a>string.indexOf</h3><p>查找传入的字符串第一次出现在该字符串的位置，如果没找到返回<code>-1</code>，第二个参数是开始检索的位置</p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#39;;const searchTerm = &#39;dog&#39;;const indexOfFirst = paragraph.indexOf(searchTerm);console.log(`The index of the first &quot;${searchTerm}&quot; from the beginning is ${indexOfFirst}`);// expected output: &quot;The index of the first &quot;dog&quot; from the beginning is 40&quot;console.log(`The index of the 2nd &quot;${searchTerm}&quot; is ${paragraph.indexOf(searchTerm, (indexOfFirst + 1))}`);// expected output: &quot;The index of the 2nd &quot;dog&quot; is 52&quot;</code></pre><h3 id="string-lastIndexOf"><a href="#string-lastIndexOf" class="headerlink" title="string.lastIndexOf"></a>string.lastIndexOf</h3><p>查找传入的字符串最后一次出现在该字符串的位置，如果没找到就返回<code>-1</code>，第二个参数是开始检索的位置</p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#39;;const searchTerm = &#39;dog&#39;;console.log(`The index of the first &quot;${searchTerm}&quot; from the end is ${paragraph.lastIndexOf(searchTerm)}`);// expected output: &quot;The index of the first &quot;dog&quot; from the end is 52&quot;</code></pre><h3 id="string-length"><a href="#string-length" class="headerlink" title="string.length"></a>string.length</h3><p>获取字符串的长度</p><pre><code class="js">const str = &#39;Life, the universe and everything. Answer:&#39;;console.log(`${str} ${str.length}`);// expected output: &quot;Life, the universe and everything. Answer: 42&quot; </code></pre><h3 id="string-match"><a href="#string-match" class="headerlink" title="string.match"></a>string.match</h3><p>针对正则表达式的匹配</p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. It barked.&#39;;const regex = /[A-Z]/g;const found = paragraph.match(regex);console.log(found);// expected output: Array [&quot;T&quot;, &quot;I&quot;]</code></pre><h3 id="string-normalize"><a href="#string-normalize" class="headerlink" title="string.normalize"></a>string.normalize</h3><p>将字符码转化成字符串</p><pre><code class="js">const name1 = &#39;\u0041\u006d\u00e9\u006c\u0069\u0065&#39;;const name2 = &#39;\u0041\u006d\u0065\u0301\u006c\u0069\u0065&#39;;console.log(`${name1}, ${name2}`);// expected output: &quot;Amélie, Amélie&quot;console.log(name1 === name2);// expected output: falseconsole.log(name1.length === name2.length);// expected output: falseconst name1NFC = name1.normalize(&#39;NFC&#39;);const name2NFC = name2.normalize(&#39;NFC&#39;);console.log(`${name1NFC}, ${name2NFC}`);// expected output: &quot;Amélie, Amélie&quot;console.log(name1NFC === name2NFC);// expected output: trueconsole.log(name1NFC.length === name2NFC.length);// expected output: true</code></pre><h3 id="string-padEnd"><a href="#string-padEnd" class="headerlink" title="string.padEnd"></a>string.padEnd</h3><p>在字符串的末尾添加重复的字符串，如果没有参数，填充空格</p><pre><code class="js">const str1 = &#39;Breaded Mushrooms&#39;;console.log(str1.padEnd(25, &#39;.&#39;));// expected output: &quot;Breaded Mushrooms........&quot;const str2 = &#39;200&#39;;console.log(str2.padEnd(5));// expected output: &quot;200  &quot;</code></pre><h3 id="string-padStart"><a href="#string-padStart" class="headerlink" title="string.padStart"></a>string.padStart</h3><p>在字符串的开头添加重复的字符串，如果没有参数，填充空格</p><pre><code class="js">const str1 = &#39;5&#39;;console.log(str1.padStart(2, &#39;0&#39;));// expected output: &quot;05&quot;const fullNumber = &#39;2034399002125581&#39;;const last4Digits = fullNumber.slice(-4);const maskedNumber = last4Digits.padStart(fullNumber.length, &#39;*&#39;);console.log(maskedNumber);// expected output: &quot;************5581&quot;</code></pre><h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw"></a>String.raw</h3><p>直接保存该字符串到内存中，忽略转义字符</p><pre><code class="js">// Create a variable that uses a Windows// path without escaping the backslashes:const filePath = String.raw`C:\Development\profile\aboutme.html`;console.log(`The file was uploaded from: ${filePath}`);// expected output: &quot;The file was uploaded from: C:\Development\profile\aboutme.html&quot;</code></pre><h3 id="string-repeat"><a href="#string-repeat" class="headerlink" title="string.repeat"></a>string.repeat</h3><p>生成指定重复次数的字符串，输入负数会报错，输入小数会被规范成整数，类似<code>Math.floor()</code></p><pre><code class="js">const chorus = &#39;Because I\&#39;m happy. &#39;;console.log(`Chorus lyrics for &quot;Happy&quot;: ${chorus.repeat(27)}`);// expected output: &quot;Chorus lyrics for &quot;Happy&quot;: Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. Because I&#39;m happy. &quot;</code></pre><h3 id="string-replace"><a href="#string-replace" class="headerlink" title="string.replace"></a>string.replace</h3><p>替换字符串中的内容，如果匹配的内容是字符串就只替换第一个匹配到的内容，它的用法很多，建议直接看文档<a href="https://devdocs.io/javascript/global_objects/string/replace" target="_blank" rel="noopener">链接</a></p><pre><code class="js">const p = &#39;The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?&#39;;const regex = /dog/gi;console.log(p.replace(regex, &#39;ferret&#39;));// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?&quot;console.log(p.replace(&#39;dog&#39;, &#39;monkey&#39;));// expected output: &quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;</code></pre><h3 id="String-search"><a href="#String-search" class="headerlink" title="String.search"></a>String.search</h3><p>匹配正则表达式，返回找到的第一个元素的位置，如果没有找到就返回<code>-1</code></p><pre><code class="js">const paragraph = &#39;The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?&#39;;// any character that is not a word character or whitespaceconst regex = /[^\w\s]/g;console.log(paragraph.search(regex));// expected output: 43console.log(paragraph[paragraph.search(regex)]);// expected output: &quot;.&quot;</code></pre><h3 id="string-slice"><a href="#string-slice" class="headerlink" title="string.slice"></a>string.slice</h3><p>提取字符串的一部分出来，不改变原先的字符串，如果起始位置超过了源字符串的长度，返回<code>&quot;&quot;</code></p><pre><code class="js">const str = &#39;The quick brown fox jumps over the lazy dog.&#39;;console.log(str.slice(31));// expected output: &quot;the lazy dog.&quot;console.log(str.slice(4, 19));// expected output: &quot;quick brown fox&quot;console.log(str.slice(-4));// expected output: &quot;dog.&quot;console.log(str.slice(-9, -5));// expected output: &quot;lazy&quot;</code></pre><h3 id="string-split"><a href="#string-split" class="headerlink" title="string.split"></a>string.split</h3><p>将字符串根据分隔符分割进数组</p><pre><code class="js">const str = &#39;The quick brown fox jumps over the lazy dog.&#39;;const words = str.split(&#39; &#39;);console.log(words[3]);// expected output: &quot;fox&quot;const chars = str.split(&#39;&#39;);console.log(chars[8]);// expected output: &quot;k&quot;</code></pre><h3 id="string-startsWith"><a href="#string-startsWith" class="headerlink" title="string.startsWith"></a>string.startsWith</h3><p>判断该字符串是否以传入的字符串开头，传入的第二个参数是开始匹配的位置</p><pre><code class="js">const str1 = &#39;Saturday night plans&#39;;console.log(str1.startsWith(&#39;Sat&#39;));// expected output: trueconsole.log(str1.startsWith(&#39;Sat&#39;, 3));// expected output: false</code></pre><h3 id="string-substring"><a href="#string-substring" class="headerlink" title="string.substring"></a>string.substring</h3><p>很像<code>string.slice</code>，获取字符串的一部分字串</p><pre><code class="js">const str = &#39;Mozilla&#39;;console.log(str.substring(1, 3));// expected output: &quot;oz&quot;console.log(str.substring(2));// expected output: &quot;zilla&quot;</code></pre><h3 id="string-toLocaleLowerCase"><a href="#string-toLocaleLowerCase" class="headerlink" title="string.toLocaleLowerCase"></a>string.toLocaleLowerCase</h3><p>将字符串本地化并转化为小写</p><pre><code class="js">const dotted = &#39;İstanbul&#39;;console.log(`EN-US: ${dotted.toLocaleLowerCase(&#39;en-US&#39;)}`);// expected output: &quot;i̇stanbul&quot;console.log(`TR: ${dotted.toLocaleLowerCase(&#39;tr&#39;)}`);// expected output: &quot;istanbul&quot;</code></pre><h3 id="string-toLocaleUpperCase"><a href="#string-toLocaleUpperCase" class="headerlink" title="string.toLocaleUpperCase"></a>string.toLocaleUpperCase</h3><p>将字符串本地化并转化为大写</p><pre><code class="js">const city = &#39;istanbul&#39;;console.log(city.toLocaleUpperCase(&#39;en-US&#39;));// expected output: &quot;ISTANBUL&quot;console.log(city.toLocaleUpperCase(&#39;TR&#39;));// expected output: &quot;İSTANBUL&quot;</code></pre><h3 id="string-toLowerCase"><a href="#string-toLowerCase" class="headerlink" title="string.toLowerCase"></a>string.toLowerCase</h3><p>将字符串转化为小写</p><pre><code class="js">const sentence = &#39;The quick brown fox jumps over the lazy dog.&#39;;console.log(sentence.toLowerCase());// expected output: &quot;the quick brown fox jumps over the lazy dog.&quot;</code></pre><h3 id="string-toString"><a href="#string-toString" class="headerlink" title="string.toString"></a>string.toString</h3><p>将字符串对象转化为字符串</p><pre><code class="js">const stringObj = new String(&#39;foo&#39;);console.log(stringObj);// expected output: String { &quot;foo&quot; }console.log(stringObj.toString());// expected output: &quot;foo&quot;</code></pre><h3 id="string-toUpperCase"><a href="#string-toUpperCase" class="headerlink" title="string.toUpperCase"></a>string.toUpperCase</h3><p>将字符串转化为大写</p><pre><code class="js">const sentence = &#39;The quick brown fox jumps over the lazy dog.&#39;;console.log(sentence.toUpperCase());// expected output: &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.&quot;</code></pre><h3 id="string-trim"><a href="#string-trim" class="headerlink" title="string.trim"></a>string.trim</h3><p>去除开头和结尾的所有空白，包括但不限于空格、回车</p><pre><code class="js">const greeting = &#39;   Hello world!   &#39;;console.log(greeting);// expected output: &quot;   Hello world!   &quot;;console.log(greeting.trim());// expected output: &quot;Hello world!&quot;;</code></pre><h3 id="string-trimEnd"><a href="#string-trimEnd" class="headerlink" title="string.trimEnd"></a>string.trimEnd</h3><p>去除结尾的所有空白，包括但不限于空格、回车，<code>trimRight</code>是该方法的别称</p><pre><code class="js">const greeting = &#39;   Hello world!   &#39;;console.log(greeting);// expected output: &quot;   Hello world!   &quot;;console.log(greeting.trimEnd());// expected output: &quot;   Hello world!&quot;;</code></pre><h3 id="string-trimStart"><a href="#string-trimStart" class="headerlink" title="string.trimStart"></a>string.trimStart</h3><p>去除开头的所有空白，包括但不限于空格、回车，<code>trimLeft</code>是该方法的别称</p><pre><code class="js">const greeting = &#39;   Hello world!   &#39;;console.log(greeting);// expected output: &quot;   Hello world!   &quot;;console.log(greeting.trimStart());// expected output: &quot;Hello world!   &quot;;</code></pre><h3 id="string-valueOf"><a href="#string-valueOf" class="headerlink" title="string.valueOf"></a>string.valueOf</h3><p>返回字符串对象的原始值</p><pre><code class="js">const stringObj = new String(&#39;foo&#39;);console.log(stringObj);// expected output: String { &quot;foo&quot; }console.log(stringObj.valueOf());// expected output: &quot;foo&quot;</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环赛日程安排</title>
    <link href="undefined2020/06/round-robin/"/>
    <url>2020/06/round-robin/</url>
    
    <content type="html"><![CDATA[<h1 id="循环赛日程安排-–-170521328-赵英博"><a href="#循环赛日程安排-–-170521328-赵英博" class="headerlink" title="循环赛日程安排 – 170521328 赵英博"></a>循环赛日程安排 – 170521328 赵英博</h1><h2 id="问题背景（自定）"><a href="#问题背景（自定）" class="headerlink" title="问题背景（自定）"></a>问题背景（自定）</h2><p>设有<code>n=2^k</code>个选手要进行循环赛，设计一个满足以下要求的比赛日程表：</p><ul><li>每个选手必须与其他<code>n-1</code>个选手各比赛一次</li><li>每个选手一天只能比赛一次</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>每个选手必须与其他选手比赛一次，那么就设计一个<code>n×(n-1)</code>的二维表，其中，<code>(i, j)</code>表示和第<code>i</code>个选手在第<code>j</code>天比赛的选手。</p><p>我们可以对这个二维表进行分割，分割成两个部分，譬如<code>n＝2^k</code>个选手的日程表就可以分成两个<code>n/2＝2^(k-1)</code>的日程表</p><p>在进行递归分割</p><p>分割直到只剩下两个选手</p><blockquote><p>比赛日程表在这个时候就很简单了，让这两个人直接进行比赛就好了</p></blockquote><p>假设有八个人比赛</p><p>整个求解过程是自底向上的迭代过程，其中表格<code>c</code>左上角和左下角分别为选手1到选手8前三天的比赛日程</p><p>将左上角复制到右下角，将左下角复制到右上角，就安排了选手1到选手8后四天的比赛日程</p><ul><li>表格a</li></ul><table><thead><tr><th>1</th><th>2</th></tr></thead><tbody><tr><td>2</td><td>1</td></tr></tbody></table><ul><li>表格b</li></ul><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>4</td><td>3</td></tr><tr><td>3</td><td>4</td><td>1</td><td>2</td></tr><tr><td>4</td><td>3</td><td>2</td><td>1</td></tr></tbody></table><ul><li>表格c</li></ul><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>2</td><td>1</td><td>4</td><td>3</td><td>6</td><td>5</td><td>8</td><td>7</td></tr><tr><td>3</td><td>4</td><td>1</td><td>2</td><td>7</td><td>8</td><td>5</td><td>6</td></tr><tr><td>4</td><td>3</td><td>2</td><td>1</td><td>8</td><td>7</td><td>6</td><td>5</td></tr><tr><td>5</td><td>6</td><td>7</td><td>8</td><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>6</td><td>5</td><td>8</td><td>7</td><td>2</td><td>1</td><td>4</td><td>3</td></tr><tr><td>7</td><td>8</td><td>5</td><td>6</td><td>3</td><td>4</td><td>1</td><td>2</td></tr><tr><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td></tr></tbody></table><p>将求解<code>2^k</code>个选手比赛日程规划分解为<code>2^1</code>，<code>2^2</code>，<code>2^k</code>个选手的比赛日程问题，通过迭代的方法将问题解决</p><h2 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a>流程描述</h2><p>每次迭代中，将问题划分为了四部分</p><h3 id="左上角"><a href="#左上角" class="headerlink" title="左上角"></a>左上角</h3><p>是<code>2^(k-1)</code>个选手在前半程的比赛日程</p><h3 id="左下角"><a href="#左下角" class="headerlink" title="左下角"></a>左下角</h3><p>是另外<code>2^(k-1)</code>个选手在前半程的比赛日程</p><h3 id="右上角"><a href="#右上角" class="headerlink" title="右上角"></a>右上角</h3><p>左下角复制得来，是<code>2^(k-1)</code>个选手在后半程的比赛日程</p><h3 id="右下角"><a href="#右下角" class="headerlink" title="右下角"></a>右下角</h3><p>左上角复制得来，是另外<code>2^(k-1)</code>个选手在后半程的比赛日程</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用语言Javascript</p><pre><code class="js">// 根据人员数创建合适大小的空数组function createArray(k) {  let arr = new Array(k).map(item =&gt; return new Array(k))  return arr}// 主函数需要传入选手参数数kfunction gameTable(k) {  // n=2^k(k≥1)个选手参加比赛  let table = createArray(k)  let n = 2;  //求解2个选手比赛日程，得到左上角元素  table[0][0]=1; table[0][1]=2;     table[1][0]=2; table[1][1]=1;  // 如果k 就是1，那么直接返回  if(k == 1) return table  // 其余情况进行迭代运算  for(let time = 1; time &lt; k; time++) {    //迭代处理，依次处理2^2, …, 2^k个选手比赛日程    temp=n; n=n*2;       //填左下角元素    for (i=temp+1; i&lt;=n; i++ )          for (j=1; j&lt;=temp; j++)                table[i][j]=table[i-temp][j]+temp;    //左下角元素和左上角元素的对应关系    //填右上角元素    for (i=1; i&lt;=temp; i++)           for (j=temp+1; j&lt;=n; j++)                table[i][j]=table[i+temp][(j+temp)% n];    //填右下角元素    for (i=temp+1; i&lt;=n; i++)          for (j=temp+1; j&lt;=n; j++)                table[i][j]=table[i-temp][j-temp];  }  // 返回整个时间表  return table}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>循环赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS基础类型API整理--Array</title>
    <link href="undefined2020/06/js-api-array/"/>
    <url>2020/06/js-api-array/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="array-concat"><a href="#array-concat" class="headerlink" title="array.concat"></a>array.concat</h3><p>用于合并两个或更多个数组，此方法不改变现有的数组，而是返回一个新的数组。</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const array2 = [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;];const array3 = array1.concat(array2);console.log(array3);// expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</code></pre><h3 id="array-copyWithin"><a href="#array-copyWithin" class="headerlink" title="array.copyWithin"></a>array.copyWithin</h3><p>用于将该数组的一部分覆写到另一部分上，用法：<code>arr.copyWithin(target, start, end)</code></p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;];// copy to index 0 the element at index 3console.log(array1.copyWithin(0, 3, 4));// expected output: Array [&quot;d&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]// copy to index 1 all elements from index 3 to the endconsole.log(array1.copyWithin(1, 3));// expected output: Array [&quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;d&quot;, &quot;e&quot;]</code></pre><h3 id="array-entries"><a href="#array-entries" class="headerlink" title="array.entries"></a>array.entries</h3><p>用于获取数组的Iterator，但是比正常的多了当前的index</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const iterator1 = array1.entries();console.log(iterator1.next().value);// expected output: Array [0, &quot;a&quot;]console.log(iterator1.next().value);// expected output: Array [1, &quot;b&quot;]let iterator2 = array1[Symbol.iterator]();console.log(iterator2.next().value);// expected output: String &quot;a&quot;</code></pre><h3 id="array-every"><a href="#array-every" class="headerlink" title="array.every"></a>array.every</h3><p>传入一个方法，会遍历该数组到方法里，方法返回<code>true</code>或者<code>false</code>，只要有一个是<code>false</code>就返回<code>false</code>，用于检测该数组的内容是不是都符合某条件</p><pre><code class="js">const isBelowThreshold = (currentValue) =&gt; currentValue &lt; 40;const array1 = [1, 30, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true</code></pre><h3 id="array-fill"><a href="#array-fill" class="headerlink" title="array.fill"></a>array.fill</h3><p>用于填充数组的指定段，用法：<code>arr.fill(value[, start[, end]])</code></p><pre><code class="js">const array1 = [1, 2, 3, 4];// fill with 0 from position 2 until position 4console.log(array1.fill(0, 2, 4));// expected output: [1, 2, 0, 0]// fill with 5 from position 1console.log(array1.fill(5, 1));// expected output: [1, 5, 5, 5]console.log(array1.fill(6));// expected output: [6, 6, 6, 6]</code></pre><h3 id="array-filter"><a href="#array-filter" class="headerlink" title="array.filter"></a>array.filter</h3><p>用于过滤数组内容，传入一个方法，遍历数组到该方法里，方法返回<code>true</code>则将该元素放进新数组，然后返回新数组</p><pre><code class="js">const words = [&#39;spray&#39;, &#39;limit&#39;, &#39;elite&#39;, &#39;exuberant&#39;, &#39;destruction&#39;, &#39;present&#39;];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;]</code></pre><h3 id="array-find"><a href="#array-find" class="headerlink" title="array.find"></a>array.find</h3><p>找到数组中第一个满足条件的元素并返回，如果没有满足的元素就返回<code>undefined</code></p><pre><code class="js">const array1 = [5, 12, 8, 130, 44];const found = array1.find(element =&gt; element &gt; 10);console.log(found);// expected output: 12</code></pre><h3 id="array-findIndex"><a href="#array-findIndex" class="headerlink" title="array.findIndex"></a>array.findIndex</h3><p>找到数组中第一个满足条件的元素的下标并返回，如果没有满足的元素就返回<code>-1</code></p><pre><code class="js">const array1 = [5, 12, 8, 130, 44];const isLargeNumber = (element) =&gt; element &gt; 13;console.log(array1.findIndex(isLargeNumber));// expected output: 3</code></pre><h3 id="array-forEach"><a href="#array-forEach" class="headerlink" title="array.forEach"></a>array.forEach</h3><p>遍历数组，如果有第二个参数就绑定到第一个方法的this</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];array1.forEach(element =&gt; console.log(element));// expected output: &quot;a&quot;// expected output: &quot;b&quot;// expected output: &quot;c&quot;</code></pre><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p>生成一个新数组，还可以传入一个遍历的函数，对每个元素进行遍历操作，用法：<code>Array.from(arrayLike[, mapFn[, thisArg]])</code></p><p>可转化Set和Map还有arguments为真实的数组</p><pre><code class="js">console.log(Array.from(&#39;foo&#39;));// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], x =&gt; x + x));// expected output: Array [2, 4, 6]Array.from({length: 5}, (v, i) =&gt; i);// [0, 1, 2, 3, 4]</code></pre><h3 id="array-includes"><a href="#array-includes" class="headerlink" title="array.includes"></a>array.includes</h3><p>查询数组是否包含某元素</p><pre><code class="js">const array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: trueconst pets = [&#39;cat&#39;, &#39;dog&#39;, &#39;bat&#39;];console.log(pets.includes(&#39;cat&#39;));// expected output: trueconsole.log(pets.includes(&#39;at&#39;));// expected output: false</code></pre><h3 id="array-indexOf"><a href="#array-indexOf" class="headerlink" title="array.indexOf"></a>array.indexOf</h3><p>用于查询数组中第一个该元素的位置，没有该元素就返回<code>-1</code>，用法：<code>arr.indexOf(searchElement[, fromIndex])</code>，<code>fromIndex</code>可省，指定开始搜索的位置</p><pre><code class="js">const beasts = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;bison&#39;];console.log(beasts.indexOf(&#39;bison&#39;));// expected output: 1// start from index 2console.log(beasts.indexOf(&#39;bison&#39;, 2));// expected output: 4console.log(beasts.indexOf(&#39;giraffe&#39;));// expected output: -1</code></pre><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h3><p>用于判定传入的参数是否是数组，返回<code>boolean</code></p><pre><code class="js">Array.isArray([1, 2, 3]);  // trueArray.isArray({foo: 123}); // falseArray.isArray(&#39;foobar&#39;);   // falseArray.isArray(undefined);  // false</code></pre><h3 id="array-join"><a href="#array-join" class="headerlink" title="array.join"></a>array.join</h3><p>用于将数组的内容拼成字符串，传入的参数就是分割符</p><pre><code class="js">const elements = [&#39;Fire&#39;, &#39;Air&#39;, &#39;Water&#39;];console.log(elements.join());// expected output: &quot;Fire,Air,Water&quot;console.log(elements.join(&#39;&#39;));// expected output: &quot;FireAirWater&quot;console.log(elements.join(&#39;-&#39;));// expected output: &quot;Fire-Air-Water&quot;</code></pre><h3 id="array-lastIndexOf"><a href="#array-lastIndexOf" class="headerlink" title="array.lastIndexOf"></a>array.lastIndexOf</h3><p>返回给定的内容在数组中最后一次出现的位置，如果没有返回<code>-1</code>，用法：<code>arr.lastIndexOf(searchElement[, fromIndex])</code>，<code>fromIndex</code>可省，指定开始搜索的位置</p><pre><code class="js">const animals = [&#39;Dodo&#39;, &#39;Tiger&#39;, &#39;Penguin&#39;, &#39;Dodo&#39;];console.log(animals.lastIndexOf(&#39;Dodo&#39;));// expected output: 3console.log(animals.lastIndexOf(&#39;Tiger&#39;));// expected output: 1</code></pre><h3 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h3><p>获取数组的长度，是一个32位整数</p><pre><code class="js">const clothing = [&#39;shoes&#39;, &#39;shirts&#39;, &#39;socks&#39;, &#39;sweaters&#39;];console.log(clothing.length);// expected output: 4</code></pre><h3 id="array-map"><a href="#array-map" class="headerlink" title="array.map"></a>array.map</h3><p>根据遍历函数的返回值返回一个新的数组</p><pre><code class="js">const array1 = [1, 4, 9, 16];// pass a function to mapconst map1 = array1.map(x =&gt; x * 2);console.log(map1);// expected output: Array [2, 8, 18, 32]</code></pre><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h3><p>根据参数创建一个新数组，与直接new的差别在于对整数的处理，传入数字表示创建一个包含该数字的数组而不是创建一个长度为该数字的空数组</p><pre><code class="js">Array.of(7);       // [7] Array.of(1, 2, 3); // [1, 2, 3]Array(7);          // [ , , , , , , ]Array(1, 2, 3);    // [1, 2, 3]</code></pre><h3 id="array-pop"><a href="#array-pop" class="headerlink" title="array.pop"></a>array.pop</h3><p>弹出数组的最后一个元素，返回该元素，同时会改变原数组</p><pre><code class="js">const plants = [&#39;broccoli&#39;, &#39;cauliflower&#39;, &#39;cabbage&#39;, &#39;kale&#39;, &#39;tomato&#39;];console.log(plants.pop());// expected output: &quot;tomato&quot;console.log(plants);// expected output: Array [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]</code></pre><h3 id="array-push"><a href="#array-push" class="headerlink" title="array.push"></a>array.push</h3><p>向数组末尾添加一个元素，返回添加后的数组长度</p><pre><code class="js">const animals = [&#39;pigs&#39;, &#39;goats&#39;, &#39;sheep&#39;];const count = animals.push(&#39;cows&#39;);console.log(count);// expected output: 4console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]animals.push(&#39;chickens&#39;, &#39;cats&#39;, &#39;dogs&#39;);console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;, &quot;cats&quot;, &quot;dogs&quot;]</code></pre><blockquote><p>可以用这个模拟cancat，但是没什么用就是了</p></blockquote><pre><code class="js">var vegetables = [&#39;parsnip&#39;, &#39;potato&#39;];var moreVegs = [&#39;celery&#39;, &#39;beetroot&#39;];// Merge the second array into the first one// Equivalent to vegetables.push(&#39;celery&#39;, &#39;beetroot&#39;);Array.prototype.push.apply(vegetables, moreVegs);console.log(vegetables); // [&#39;parsnip&#39;, &#39;potato&#39;, &#39;celery&#39;, &#39;beetroot&#39;]</code></pre><h3 id="array-reduce"><a href="#array-reduce" class="headerlink" title="array.reduce"></a>array.reduce</h3><p>执行传入的方法最终返回一个值，传入的方法有四个参数，依次是：累加器(acc)，当前遍历的值(cur)，当前遍历的下标(idx)，整个数组(src)，第二个参数是一个初始的默认值，可以不加</p><pre><code class="js">const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15</code></pre><h3 id="array-reduceRight"><a href="#array-reduceRight" class="headerlink" title="array.reduceRight"></a>array.reduceRight</h3><p>和上边一样，不过是从右边开始遍历</p><pre><code class="js">const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight(  (accumulator, currentValue) =&gt; accumulator.concat(currentValue));console.log(array1);// expected output: Array [4, 5, 2, 3, 0, 1]</code></pre><h3 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array.reverse"></a>array.reverse</h3><p>反转整个数组`</p><pre><code class="js">const array1 = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;];console.log(&#39;array1:&#39;, array1);// expected output: &quot;array1:&quot; Array [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]const reversed = array1.reverse();console.log(&#39;reversed:&#39;, reversed);// expected output: &quot;reversed:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]// Careful: reverse is destructive -- it changes the original array.console.log(&#39;array1:&#39;, array1);// expected output: &quot;array1:&quot; Array [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]</code></pre><blockquote><p>注意：这个方法会改变原数组</p></blockquote><h3 id="array-shift"><a href="#array-shift" class="headerlink" title="array.shift"></a>array.shift</h3><p>弹出数组的第一个元素，会改变原数组的长度</p><pre><code class="js">const array1 = [1, 2, 3];const firstElement = array1.shift();console.log(array1);// expected output: Array [2, 3]console.log(firstElement);// expected output: 1</code></pre><h3 id="array-slice"><a href="#array-slice" class="headerlink" title="array.slice"></a>array.slice</h3><p>获得数组某一段的<strong>浅拷贝</strong>，用法：<code>arr.slice([begin[, end]])</code></p><pre><code class="js">const animals = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;elephant&#39;];console.log(animals.slice(2));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice(1, 5));// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]</code></pre><h3 id="array-some"><a href="#array-some" class="headerlink" title="array.some"></a>array.some</h3><p>和<code>array.every</code>相反，传入一个方法，会遍历该数组到方法里，方法返回<code>true</code>或者<code>false</code>，只要有一个是<code>true</code>就返回<code>true</code>，用于检测该数组是不是有符合某条件的元素</p><pre><code class="js">const array = [1, 2, 3, 4, 5];// checks whether an element is evenconst even = (element) =&gt; element % 2 === 0;console.log(array.some(even));// expected output: true</code></pre><h3 id="array-sort"><a href="#array-sort" class="headerlink" title="array.sort"></a>array.sort</h3><p>用于进行数组排序，可以传入自定义排序函数，默认情况下是转成<code>UTF-16</code>比较首字符进行排序的，会改变原数组</p><pre><code class="js">const months = [&#39;March&#39;, &#39;Jan&#39;, &#39;Feb&#39;, &#39;Dec&#39;];months.sort();console.log(months);// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]const array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// expected output: Array [1, 100000, 21, 30, 4]var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) {  return a - b;  // 如果大于0将a后移，如果小于0将b后移});console.log(numbers);// [1, 2, 3, 4, 5]</code></pre><h3 id="array-splice"><a href="#array-splice" class="headerlink" title="array.splice"></a>array.splice</h3><p>用于替换数组中某一部分</p><pre><code class="js">const months = [&#39;Jan&#39;, &#39;March&#39;, &#39;April&#39;, &#39;June&#39;];months.splice(1, 0, &#39;Feb&#39;);// inserts at index 1console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]months.splice(4, 1, &#39;May&#39;);// replaces 1 element at index 4console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;]</code></pre><h3 id="array-toString"><a href="#array-toString" class="headerlink" title="array.toString"></a>array.toString</h3><p>将数组转化成字符串</p><pre><code class="js">const array1 = [1, 2, &#39;a&#39;, &#39;1a&#39;];console.log(array1.toString());// expected output: &quot;1,2,a,1a&quot;</code></pre><h3 id="array-unshift"><a href="#array-unshift" class="headerlink" title="array.unshift"></a>array.unshift</h3><p>将一个或者多个元素添加到数组的开头，并返回改变后的数组长度</p><pre><code class="js">const array1 = [1, 2, 3];console.log(array1.unshift(4, 5));// expected output: 5console.log(array1);// expected output: Array [4, 5, 1, 2, 3]</code></pre><h3 id="array-keys"><a href="#array-keys" class="headerlink" title="array.keys"></a>array.keys</h3><p>返回一个数组下标的迭代器</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const iterator = array1.keys();for (const key of iterator) {  console.log(key);}// expected output: 0// expected output: 1// expected output: 2</code></pre><blockquote><p>对于空元素Array.keys和Object.keys不太一样</p></blockquote><pre><code class="js">var arr = [&#39;a&#39;, , &#39;c&#39;];var sparseKeys = Object.keys(arr);var denseKeys = [...arr.keys()];console.log(sparseKeys); // [&#39;0&#39;, &#39;2&#39;]console.log(denseKeys);  // [0, 1, 2]</code></pre><h3 id="array-values"><a href="#array-values" class="headerlink" title="array.values"></a>array.values</h3><p>返回一个数组内容的迭代器</p><pre><code class="js">const array1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];const iterator = array1.values();for (const value of iterator) {  console.log(value);}// expected output: &quot;a&quot;// expected output: &quot;b&quot;// expected output: &quot;c&quot;var a = [&#39;w&#39;, &#39;y&#39;, &#39;k&#39;, &#39;o&#39;, &#39;p&#39;]; var iterator = a.values();console.log(iterator.next().value); // w console.log(iterator.next().value); // y console.log(iterator.next().value); // k console.log(iterator.next().value); // o console.log(iterator.next().value); // p</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript（下）学习笔记</title>
    <link href="undefined2020/06/js2/"/>
    <url>2020/06/js2/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><p>用法<code>var input = prompt(text,defaultText)</code></p><blockquote><p>text     可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）。<br>defaultText     可选。默认的输入文本。</p></blockquote><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>如果两边任意一边出现 <code>true</code> 或者 <code>false</code> 使用 <strong>===</strong></p><p>如果两边任意一边可能是特定值<code>0,&quot;&quot;, []</code> 使用 <strong>===</strong></p><p>剩下的所有情况,使用 <strong>==</strong></p><p>对于引用类型来说,比较仅仅是比较其引用是否是同一个,另外在和字符串比较时,数组会自动转成字符串</p><pre><code class="js">var a = [1,2,3]var b = [1,2,3]var c = &quot;1,2,3&quot;console.log(a == b) // falseconsole.log(a == c) // trueconsole.log(b == c) // true</code></pre><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><pre><code class="js">switch(a) {  case 2:  case 10:    // 2 或者 10 执行    break;  default:    // 条件都不满足默认执行}</code></pre><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>let 尽量将变量声明放在代码块开始,避免在(Temproal Dead Zone, TDZ)<strong>临时死亡区</strong>使用而报错</p><blockquote><p>尽量使用for…let,在每次循环中都会声明一个新的变量,生成了一个闭包。避免for里边的函数在调用的时候引用不到正确的变量。</p></blockquote><p>const声明,相对于保护其中的内容更注重其语意所带来的规范性</p><p>如果把方法定义在{}内,那么在块外执行会报ReferenceError</p><h3 id="spread-rest解构重构"><a href="#spread-rest解构重构" class="headerlink" title="spread/rest解构重构"></a>spread/rest解构重构</h3><p>spread/rest<code>...</code>放在数组前用于展开数组,放在变量前就是收集变量到一个数组里,例如 <code>function a(...arg){} a(a,b,c) -&gt; arg = [a,b,c]</code></p><p>解构 <code>var [a, b, c] = foo()</code> 如果foo返回的是一个长度为三的数组其内容将会被依次赋值给abc</p><p>对象属性复制模式<code>var {a, b, c} = foo()</code>这里省略的其实是<code>a:, b:, c:</code>,对象的属性名要和函数返回的属性名相同,然后将值一一赋值给属性值<code>var {a: x, b: y, c: z} = foo()</code>最后使用的是<code>xyz</code>而不是<code>abc</code></p><blockquote><p>对于这个形式,如果省略声明符就需要用小括号括起来<code>({a, b, c} = foo())</code></p></blockquote><p>使用<strong>对象属性名的计算属性</strong><code>var which = &#39;w&#39;; o1 = {which: &#39;w&#39;}; =&gt; {which: &#39;w&#39;}   o2 = {[which]: &#39;w&#39;}; =&gt; {w: &#39;w&#39;}</code>使用中括号即可使用变量里边的内容作为属性名</p><p>简单的交换两个元素<code>[a, b] = [b, a]</code></p><p>允许出现多次列出同一个源属性<code>{a: {x: X, x: Y}, a} = {a: {x: 1}} =&gt; X == Y == 1, a = {x :1}</code></p><blockquote><p>不必都写在一行里,解构的目的不是为了打字更少,而是为了可读性更强</p></blockquote><p>赋值的时候用不到的东西可以抛弃<code>[,a,b] = [1, 2, 3] =&gt; a = 2, b = 3</code></p><p>赋值的时候多余的东西会赋值undefined<code>[a, b] = [1] =&gt; a = 1, b = undefined</code></p><p>赋值的时候可以使用spread/rest<code>...</code>进行收集操作<code>[...a,b] = [1, 2, 3] =&gt; a = [1, 2], b = 3</code></p><p>赋值的时候可以使用默认值<code>{a, b: WW = 20} = {a: 10}  =&gt; a = 10, WW = 20</code></p><p>赋值的时候可以嵌套结构</p><p>在形参中使用这个就接近了命名参数,得到了任意位置的可选参数功能</p><p>设置默认参数<code>{x = 10} = {}</code>,</p><blockquote><p>比较一下<code>{y} = {y: 10}</code>与<code>{x = 10} = {}</code><br>对于x这种新式的用法来说，如果第一个参数省略或者是undefined，就会应用{}空对象默认值，然后，在第一个参数位置传入的任何值——或者是默认{}或者是你传入的任何值，都是用<code>{x = 10}</code>进行解构，这会检查是否存在x属性，如果没有或者是undefined，就会自动赋值为10，所以x不论传入什么，只要没指定x就是10，y则在未传入或者传入undefined嗯嗯时候才会赋值为10</p></blockquote><h3 id="对象字面量拓展"><a href="#对象字面量拓展" class="headerlink" title="对象字面量拓展"></a>对象字面量拓展</h3><p>简洁属性<code>{x}</code></p><p>简洁方法<code>{x(){}}</code></p><blockquote><p>这个操作会生成一个匿名的函数,如果需要递归请不要使用</p></blockquote><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><p>使用<code>...${foo(`${name}s`)}</code></p><h4 id="标签模板字面量"><a href="#标签模板字面量" class="headerlink" title="标签模板字面量"></a>标签模板字面量</h4><pre><code class="js">  function foo(strings, ...args) {    console.log(strings)    console.log(args)  }  var desc = &quot;awesome&quot;  foo`Every thing is ${desc}!`  // [&quot;Every this is &quot;, &quot;!&quot;]  // [&quot;awesome&quot;]</code></pre><p>配合String.reduce遍历字符串可以达成本地化之类的功能</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>合理使用，函数越短越适合用，函数长了反而会使函数边界模糊</p><p>主要的功能是为了this的规范化而不是减少代码量</p><p>尽可能减少非必要情况下的箭头函数使用</p><h3 id="for-…-of-循环"><a href="#for-…-of-循环" class="headerlink" title="for … of 循环"></a>for … of 循环</h3><p><code>for ... in</code> 遍历的时候遍历的是 index（从0开始） <code>for ... of</code>遍历的是值</p><p>适用所有带迭代器的变量</p><p>自带迭代器的有Arrays,Strings,Generators,Collections/TypedArrays</p><p><code>...</code>可以是赋值表达式也可以是声明</p><blockquote><p>Object 不可迭代所以用不了，非要用自己写个<code>[Symbol.iterator]</code>挂prototype上或者自己extend一个</p></blockquote><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><h4 id="定点标识"><a href="#定点标识" class="headerlink" title="定点标识"></a>定点标识</h4><p><code>re = /d/ re.lastIndex</code></p><p>定点定位<code>/f../y</code>会从lastIndex开始搜索,不会更新lastIndex</p><p>g模式使用exec 会更新lastIndex</p><p>^ 总是指向输入起始处的锚点,不受lastIndex的影响</p><p>y 加上 ^ 加上lastIndex &gt; 0 是一个不兼容的组合,总是会导致失败</p><h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h4><p><code>re = /foo/ig re.flags =&gt; gi</code>查看应用的哪些标识</p><p>顺序总是<code>gimuy</code></p><h3 id="数字字面量扩展"><a href="#数字字面量扩展" class="headerlink" title="数字字面量扩展"></a>数字字面量扩展</h3><p><code>doc = 12</code></p><p><code>oct = 0o52</code></p><p><code>hex = 0x2a</code></p><p><code>bin = 0b101010</code></p><p><code>a = 42 a.toString(10 || 8 || 6 || 2)</code>可以进行转换</p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><code>var snowman = &#39;\u2603&#39;</code> \u转义</p><p><code>var gclef = &#39;\uD834\uDD1E&#39;</code> 替代对</p><p><code>var gclef = &#39;\u{1D11E}&#39;</code> 码点转义</p><h4 id="精确判断字符串长度"><a href="#精确判断字符串长度" class="headerlink" title="精确判断字符串长度"></a>精确判断字符串长度</h4><p><code>[...str].length</code></p><p><code>Array.from(str).length</code></p><h3 id="符号Symbol"><a href="#符号Symbol" class="headerlink" title="符号Symbol"></a>符号Symbol</h3><p>使用例子<code>var sym = Symbol(&#39;something&#39;)</code></p><blockquote><p>不应该使用new</p></blockquote><p>使用<code>typeof</code>识别</p><p>获取全局符号（如果全局不存在则新建一个放在全局）<code>Symbol.for(&quot;exec.name&quot;)</code></p><p>通过符号获取字符串<code>Symbol.keyFor(sym)</code></p><p>设置为对象的属性之后不可枚举,但是可以通过<code>Object.getOwnPropertySymbols(sym)</code>获取</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>可以用来满足消费者生产者模型</p><p>必须拥有一个next()</p><p>可选return()用于消费者向生产者发送所有消费过程完成的信号,生产者应进行销毁程序</p><p>可选throw()用于向生产者发送错误信号,终止生产</p><p>for of 可以消费迭代器,使用break退出会触发return</p><p>通过spread/rest运算符可以消耗迭代器<code>it = arr[Symbol.iterator]() var [x, y] = it; var [z, ...w] = it;</code> it最终会被消耗光</p><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><code>function *foo() {yield 1;} it = foo() it.next() // value 1</code> next里边的参数会替换掉 yield后边的东西</p><p>就是用迭代器来控制生成器</p><p>可以用throw()配合try catch实现错误的双向或 内外双向传递</p><p>每次被调用的时候都会是一个新的生成器</p><p>加* </p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><code>import</code> 和 <code>export</code> 必须在使用它们的最顶层作用域</p><h4 id="命名导出"><a href="#命名导出" class="headerlink" title="命名导出"></a>命名导出</h4><pre><code class="js">// 方式一export var bar = [1,3,4]; export function foo() {}// 方式二var bar = []; function foo() {}; export {bar, foo}</code></pre><h4 id="导出的是在模块内的最后的值"><a href="#导出的是在模块内的最后的值" class="headerlink" title="导出的是在模块内的最后的值"></a>导出的是在模块内的最后的值</h4><pre><code class="js">var a = 1export { a }a = 2// -&gt; 最后导出的是2而不是1</code></pre><h4 id="导出可以指定名称"><a href="#导出可以指定名称" class="headerlink" title="导出可以指定名称"></a>导出可以指定名称</h4><pre><code class="js">var a = 1export { a as b }// -&gt; 只有b可以被导入,a被隐藏</code></pre><blockquote><p>导入不是赋值操作,而是类似指针一样的绑定<br>es6倾向于一个文件一个export,可以使import变得简单</p></blockquote><h4 id="默认导出的两种形式"><a href="#默认导出的两种形式" class="headerlink" title="默认导出的两种形式"></a>默认导出的两种形式</h4><pre><code class="js">export default function foo() {} // -&gt; 导出的是表达式的绑定function foo() {} export default foo // -&gt; 同上,即`export default`接受的是一个表达式function foo() {} export { foo as default } // -&gt; 导出的是标识符的绑定,也就是导出foo在文件中最后的值</code></pre><blockquote><p>一个模块只能有一个default</p></blockquote><pre><code class="js">// 方式一export default function foo() {}export function bar() {}// 方式二function foo() {}function bar() {}export { foo as default, bar }</code></pre><h4 id="可以导出别的模块的导出-gt-感觉可以用来集成模块-也没啥用"><a href="#可以导出别的模块的导出-gt-感觉可以用来集成模块-也没啥用" class="headerlink" title="可以导出别的模块的导出 -&gt; 感觉可以用来集成模块,,也没啥用"></a>可以导出别的模块的导出 -&gt; 感觉可以用来集成模块,,也没啥用</h4><pre><code class="js">export { foo, bar } from &#39;baz&#39;export { foo as FOO, bar as BAR } from &#39;baz&#39;export * from &#39;baz&#39;</code></pre><p>导入模块如果有default<code>import foo from &quot;baz&quot;</code>引入那个default</p><p>对导入进行重命名<code>import { foo as Foo } from &quot;baz&quot; -&gt; Foo()</code></p><p>对复合导入<code>import FOOFN, { bar, baz } from &quot;baz&quot;</code></p><p>命名空间导入<code>import * as foo from &quot;foo&quot; -&gt; foo.bar()</code>当前只能全部导入</p><p>如果有默认导出,就是<code>foo.default()</code></p><p>默认+命名空间<code>import foofn, * as hello from &quot;world&quot;</code> <code>foofn -&gt; hello.default</code> 尽量不要用这种迷惑操作</p><p>所有导入的绑定都是只读的,所有的赋值操作都会报错</p><p>所有导入都会被提升,全局访问</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>使用<code>class</code>声明类,类名大写</p><pre><code class="js">class Foo {  constructor(a, b) {    this.x = a;    this.y = b;  }  gimmeXY() {    return this.x * this.y  }}</code></pre><p>不能使用call所以只能通过new实例化</p><p>类不能被提升,所以实例化之前必须声明</p><p>声明一个class并没有创建一个同名的全局对象属性</p><p>class本身并不是一个实体,而是一个包裹着其他像函数和属性这样的具体实体并把它们组合到一起的元概念</p><p>class也可以是一个表达式</p><pre><code class="js">var x = class Y {} // -&gt; 对于把类定义(严格说是构造器本身)作为函数参数传递,或者把它赋值给一个对象属性的时候特别管用</code></pre><p>把类理解为一个宏,用于自动产生一个prototype对象</p><p>类对extends以及super提供语法糖</p><pre><code class="js">class Bar extends Foo {  constructor(a, b, c) {    super(a, b)    this.z = c  }  gimmeXYZ() {    return super.gimmeXY() * this.z  }}</code></pre><p>如果子类不定义构造函数就会</p><pre><code class="js">constructor(...args) {  super(...args)}</code></pre><blockquote><p>子类不在构造器中使用<code>super</code>是无法使用<code>this</code>的</p></blockquote><p>可以拓展原生类</p><pre><code class="js">class MyCoolArray extends Array {  first() {return this[0]}  last() {return this[this.length -1 ]}}a = new MyCoolArray(1, 2, 3)a.first()</code></pre><p><code>new.target</code>在构造器中访问new直接调用的构造器</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>决议的结果只可能是完成或者拒绝,附带一个可选的单个值,如果拒绝,那么最终的值称为原因</p><p>只能被完成或者拒绝一次,之后完成或者拒绝的操作都会被忽略</p><p>创建一个Promise</p><pre><code class="js">var p = new Promise(function(resolve, reject) {  // 成功  resolve(arg)  // 采用另一个Promise的决议值  resolve(promise)  // 拒绝  reject(why)})// 调用// then接受两个函数第一个是完成,第二个是拒绝时执行p().then(  function fulfilled(res) {},  funcrion rejected(err){},)</code></pre><p>不论是<code>.then</code>还是<code>.catch</code>都会返回一个Promise,可以用<code>.then</code>进行处理</p><p>只要是函数里边包含<code>then</code>方法都会被认为是一个<code>thenable</code>所以不要盲目信任自称是Promise的东西</p><h4 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h4><p><code>Promise.resolve</code></p><pre><code class="js">var p1 = Promise.resolve(42)var p2 = new Promise(function pr(resolve){resolve(42)})// p1 和 p2 的最终行为方式是相同的</code></pre><p>这个接口提供了一个规范化Promise的方法,可以将刚刚不可信任的thenable放进去规范化</p><h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a><code>Promise.reject</code></h5><p>和上边的一样创建一个立即被拒绝的promise,但是如果他的参数是Promise,它不会理会传进来得Promise的决议值</p><h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([])"></a><code>Promise.all([])</code></h5><p>接受一个或者多个值的数组,比如立即值、Promise、thenable,它返回一个promise,如果里边的所有值都是完成则决议结果是完成,其中某一个被拒绝这个Promise就立即被拒绝</p><blockquote><p>是等待所有都完成或者第一个拒绝</p></blockquote><h5 id="Promise-rase"><a href="#Promise-rase" class="headerlink" title="Promise.rase([])"></a><code>Promise.rase([])</code></h5><p>等待第一个完成或者拒绝</p><blockquote><p>也就是说返回第一个完成的决议值</p></blockquote><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="TypedArray"><a href="#TypedArray" class="headerlink" title="TypedArray"></a>TypedArray</h4><pre><code class="js">// 创建一个buffer,长度为32字节,一共256位var buf = new ArrayBuffer(32)console.log(buf.byteLength) // 32// 将这256位映射成一个16位无符号整型的类型数组var arr = new Uint16Array(buf)console.log(arr.length) // 16</code></pre><h4 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h4><p>是指多字节数字中的低字节位于这个数字字节表示中的右侧还是左侧</p><p>举个例子,设想一个十进制数字3085,我们需要用16位来表示它。如果只是用一个十六位数字容器,那么不论大小端配置如何都是0000110000001101B,或者0c0dH</p><p>但是如果用两个八位数组表示数字3085,那么大小端就会明显影响他在内存中的存储表示：</p><ul><li>0000110000001101/0c0d（大端）</li><li>0000110100001100/0d0c（小端）</li></ul><p>快速监测JavaScript大小端的方法</p><pre><code class="js">var littleEndian = (function() {  var buffer = new ArrayBuffer(2);  new DataView( buffer ).setInt16(0, 256, true)  return new Int16Array(buffer)[0] === 256;})();</code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>当前的js的对象的键只支持字符串</p><pre><code class="js">var m = {}var x = { id : 1 }var y = { id : 2 }m[x] = &quot;foo&quot;m[y] = &quot;bar&quot;m[x] // &quot;bar&quot;m[y] // &quot;bar&quot;</code></pre><p>因为x,y两个对象字符串化都是”[object object]”, 所以m中只有一个键</p><h5 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h5><pre><code class="js">var m = new Map();var x = { id : 1 }var y = { id : 2 }m.set(x, &quot;foo&quot;)m.set(y, &quot;bar&quot;)m.get(x)m.get(y)m.delete(x)m.clear()m.size</code></pre><p>只是不能使用<code>[]</code>的方式来进行访问了,但是可以用set、get完美替换,删除的话不能用<code>delete</code>操作符,要用<code>delete()</code>方法,完全清空map用<code>clear()</code>方法,访问映射的大小用<code>size</code>属性</p><p><code>new</code>的时候可以传入一个二维数组<code>[[key, value]]</code></p><h5 id="Map值"><a href="#Map值" class="headerlink" title="Map值"></a>Map值</h5><p>使用<code>value()</code></p><pre><code class="js">var m = new Map()var x = {id: 1},    y = {id: 2}m.set(x, &quot;foo&quot;)m.set(y, &quot;bar&quot;)var vals = [...m.values()]vals // [&quot;foo&quot;,&quot;bar&quot;]Array.from( m.values())// 使用entries迭代vals = [...m.entries()]vals[0][0] === x; // truevals[0][1];       // &quot;foo&quot;vals[1][0] === y; // falsevals[1][1];       // &quot;bar&quot;</code></pre><h5 id="Map键"><a href="#Map键" class="headerlink" title="Map键"></a>Map键</h5><p>使用<code>keys()</code></p><pre><code class="js">var keys = [...m.keys()]keys[0] === x;    // truekeys[1] === y;    // true</code></pre><p>查看是否有给定的键</p><pre><code class="js">m.has(x);         // truem.has(z);         // false</code></pre><p>map的本质是允许你把某些额外的信息关联到一个对象上,而无需把这个信息放入对象本身</p><h5 id="weakmap"><a href="#weakmap" class="headerlink" title="weakmap"></a>weakmap</h5><p>作为键的对象被回收后会被自动删除,多用于dom中</p><blockquote><p>没有size,没有clear()</p></blockquote><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>是一个值得集合,其中得值唯一（重复会被忽略）</p><p>用add()代替set(),没有get()</p><pre><code class="js">var s = new Set()var x = {id: 1}var y = {id: 2}s.add(x) s.add(y) s.add(x)s.size // 2s.delete(y)s.size // 1s.clear() // 0s.size // 0</code></pre><p>初始化可以放进去一个构造器</p><pre><code class="js">var x = {id: 1}var y = {id: 2}var s = new Set([x, y])s.has(x) // true</code></pre><h3 id="新增API"><a href="#新增API" class="headerlink" title="新增API"></a>新增API</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><h5 id="静态函数Array-of"><a href="#静态函数Array-of" class="headerlink" title="静态函数Array.of()"></a>静态函数Array.of()</h5><p>正常使用<code>new Array(4)</code>会生成一个长度为4得空数组,但是使用<code>of</code>就能生成长度为1值为4的数组</p><h5 id="静态函数Array-from"><a href="#静态函数Array-from" class="headerlink" title="静态函数Array.from()"></a>静态函数Array.from()</h5><p><code>Array.from({length:4})</code> 生成4个undefined可以避免空槽位</p><p>映射<code>Array.from(arr, function(val, idx){return}, this)</code>对每一个值进行进行映射处理,类似.map(),如果有第三个参数,则会被绑定为第二个函数的this</p><h5 id="原型方法copyWithin"><a href="#原型方法copyWithin" class="headerlink" title="原型方法copyWithin()"></a>原型方法copyWithin()</h5><p>从一个数组中复制一部分到同一个数组的另一个位置,覆盖这个位置所有原来的值,如果有任何一个参数是负值,就被当作是相对于数组结束的相对值</p><pre><code class="js">[1,2,3,4,5].copyWithin(3,0); // [1,2,3,1,2][1,2,3,4,5].copyWithin(3,0,1); // [1,2,3,1,5][1,2,3,4,5].copyWithin(0,-2); // [4,5,3,4,5][1,2,3,4,5].copyWithin(0,-2,-1); // [4,2,3,4,5]</code></pre><blockquote><p>用的时候输出一下结果,避免不是想要的结果</p></blockquote><h5 id="原型方法fill"><a href="#原型方法fill" class="headerlink" title="原型方法fill()"></a>原型方法fill()</h5><p>填充数组,第一个参数是要填充的内容,然后是填充的开始和结束</p><pre><code class="js">[null, null, null, null].fill(42, 1, 3) // [null, 42, 42, null]</code></pre><h5 id="原型方法find"><a href="#原型方法find" class="headerlink" title="原型方法find()"></a>原型方法find()</h5><p>indexOf是用的===导致’2’不能与2匹配</p><p>es5中的变通方法是用some方法对每个元素调用一个函数回调,直到某次返回为true为止,因为可以定义回调函数,所以拥有了对匹配方式的完全控制,但是最后只能得到匹配的true或者false提示,无法的到真正的匹配值本身</p><p>find()与some()基本一致,除了一旦返回值是真值,会返回实际的数组值,如果没找到会返回undefined</p><pre><code class="js">var a = [1,2,3,4,5]var b = a.find(function matcher(v){  return v == &#39;2&#39;})console.log(b) // 2</code></pre><h5 id="原型方法findIndex"><a href="#原型方法findIndex" class="headerlink" title="原型方法findIndex()"></a>原型方法findIndex()</h5><p>和find()一样对每个元素调用一个函数回调,但是如果返回是true则会返回index,如果没找到返回-1</p><blockquote><p>不要使用findIndex(..) != -1(这是indexOf的惯用法)从搜索中得到布尔值,因为some()已经yield出你想要的true/false。也不要用a[a.findIndex(..)]来得到匹配值,因为这是find()所作的事。最后如果需要严格匹配的索引值,那么使用indexOf()；如果需要自定义匹配的索引值,那么使用findIndex()</p></blockquote><p>接受回调的数组方法接收一个可选的第二个参数,如果设定这个参数就绑定到第一个参数回调的this,否则this就是undefined</p><p>原型方法entries()、values()、keys()</p><blockquote><p>同SET,MAP差不多</p></blockquote><pre><code class="js">var a = [1, 2, 3][...a.values()] // [1,2,3][...a.keys()]   // [0,1,2][...a.entries()] // [[0,1],[1,2],[2,3]][...a[Symbol.iterator]()] // [1,2,3]</code></pre><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h5 id="静态函数Object-is"><a href="#静态函数Object-is" class="headerlink" title="静态函数Object.is()"></a>静态函数Object.is()</h5><p>执行比===更严格的值比较,应该继续使用===进行严格相等比较,不可当作这个运算符的替代,如果需要严格识别NaN或者-0,则应该选择Object.is()</p><pre><code class="js">var x = NaN, y = 0, z = -0x === x  // falsey === z  // trueObject.is(x,x) // trueObject.is(y,z) // false</code></pre><h5 id="静态函数Object-getOwnPropertySymbols"><a href="#静态函数Object-getOwnPropertySymbols" class="headerlink" title="静态函数Object.getOwnPropertySymbols()"></a>静态函数Object.getOwnPropertySymbols()</h5><p>Symbol可能会成为对象最经常使用的特殊(元)属性。所以引入了这个工具直接从对象上回去所有的符号属性</p><pre><code class="js">var o = {  foo: 42,  [Symbol(&quot;bar&quot;)]: &quot;hello world&quot;,  baz: true}Object.getOwnPropertySymbols(o); // [Symbol(bar)]</code></pre><h5 id="静态函数Object-setPrototypeOf"><a href="#静态函数Object-setPrototypeOf" class="headerlink" title="静态函数Object.setPrototypeOf()"></a>静态函数Object.setPrototypeOf()</h5><p>用于设置对象的[[Prototype]]用于行为委托</p><pre><code class="js">var o1 = {foo() {}}var o2 = {baz() {}}Object.setPrototypeOf(o2, o1)o2.foo()// 或者var o2 = Object.setPrototypeOf({baz(){}},o1)o2.foo()</code></pre><h5 id="静态函数Object-assign"><a href="#静态函数Object-assign" class="headerlink" title="静态函数Object.assign()"></a>静态函数Object.assign()</h5><p>第一个参数是target,剩下的所有参数的传入的源,按照传入的顺序依次处理,对于每个源来讲,他的可枚举属性和自己拥有的简直,包括符号都会通过简单的=赋值被复制,会返回目标对象,经过实测,后边的会覆盖前边的值,如果不想这样就使用符号,只读属性可被复制：复制后是个普通属性，不可枚举属性不可复制，不可枚举符号不可被复制</p><p>而且除了setPrototypeOf可以链接[[prototype]]还可以使用</p><pre><code class="js">var o1 = {foo(){}}var o2 = Object.assign(Object.create(o1),{// o2 的定义})o2.foo()</code></pre><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><h5 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h5><p>Number.EPSILON任意两个值之间的最小差</p><p>Number.MAX_SAFE_INTEGER可以用数字值无歧义“安全表达”的最大整数：2^53 - 1</p><p>Number.MIN_SAFE_INTEGER可以用数字值无歧义“安全表达” 的最小整数：-(2^53-1) 或 (-2)^53 + 1</p><h5 id="静态函数Number-isNaN"><a href="#静态函数Number-isNaN" class="headerlink" title="静态函数Number.isNaN()"></a>静态函数Number.isNaN()</h5><p>是对于全局函数isNaN()的修正，可以按期望工作</p><h5 id="静态函数Number-isFinite"><a href="#静态函数Number-isFinite" class="headerlink" title="静态函数Number.isFinite()"></a>静态函数Number.isFinite()</h5><p>判断数字是不是非无限的，能排除掉NaN和Infinity</p><p>全局的isFinite()会强制进行类型转换，而这个不会</p><h5 id="整型相关静态函数"><a href="#整型相关静态函数" class="headerlink" title="整型相关静态函数"></a>整型相关静态函数</h5><p>正常情况下是检查小数部分是否非0 x===Math.floor(x)</p><p>ES6新增Number.isInteger(),可以更有效的判断这个性质，同时排除了NaN 和 Infinity 返回false，对于4,4.0,4.00都会返回true</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h5 id="原型函数repeat"><a href="#原型函数repeat" class="headerlink" title="原型函数repeat()"></a>原型函数repeat()</h5><p>在python和ruby这样的语言中，可以这样重复字符串<code>&quot;foo&quot; * 3 // &#39;foofoofoo&#39;</code></p><p>ES6中<code>&quot;foo&quot;.repeat(3) // &#39;foofoofoo&#39;</code></p><h5 id="字符串检查函数"><a href="#字符串检查函数" class="headerlink" title="字符串检查函数"></a>字符串检查函数</h5><p><code>str.startsWith(&quot;some&quot;) // true</code></p><p><code>str.endsWith(&quot;some&quot;) // true</code></p><p><code>str.includes(&quot;some&quot;) // true</code></p><p>不会接受正则表达式用于搜索，而且如果搜索空字符串一般会在开始或者结尾找到</p><h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><h4 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h4><pre><code class="js">(function(){...}); // name:(function*(){...}); // name:window.foo = function(){...}; // name:class Awesome{  constructor(){...} // name: Awesome  funny(){...} // name: funny}var c = class Awesome {..}; // name: Awesomevar o = {  foo(){...}, // name: foo  *bar(){...}, // name: bar  baz: () =&gt; {...}, // name: baz  bam: function() {...}, // name: bam  get qux() {...}, // name: get qux  set fuz() {...}, // name: set fuz  [&quot;b&quot;+&quot;lz&quot;]: function() {...}, // name: blz  [Symbol(&quot;buz&quot;)]: function() {...} // name: [buz]};var x = o.foo.bind(o); // bound foo(function(){..}).bind(0); // boundexport default function() {...} // name: defaultvar y = new Function(); // name: anonymousvar GeneratorFunction = function*(){}.__proto__.constructor;var z = new GeneratorFunction() // name: anonymous</code></pre><blockquote><p>默认情况下name属性不可写，但是可以通过Object.defineProperty(..)手动修改</p></blockquote><h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><p><code>new.target</code>可以指向调用new的目标构造器，也就是说如果在构造器里想区分直接调用还是子类调用使用如下代码</p><pre><code class="js">class Parent {  constructor() {    if (new.target === Parent) console.log(&#39;from parent&#39;)    else console.log(&#39;from child&#39;)  }}class Child extends Parent {}var a = new Parent(); // from parentvar b = new Child(); // from child</code></pre><h4 id="公开符号"><a href="#公开符号" class="headerlink" title="公开符号"></a>公开符号</h4><h5 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h5><p>表示任意对象上的一个专门位置（属性），语言机制自动在这个位置上寻找一个方法，这个方法构造一个迭代器来消耗这个对象的值。很多对象定义有这个符号的默认值</p><pre><code class="js">var arr = [4,5,6,7,8,9];for(let v of arr) {  console.log(v) // 4 5 6 7 8 9}// 定义一个只在奇数位置产生索引值的迭代器arr[Symbol.iterator] = function *() {  var idx = 1;  do {    yield this[idx];  } while((idx += 2) &lt; this.length);};for (let v of arr) {  console.log(v) // 5 7 9}</code></pre><h5 id="Symbol-toStringTag-与-Symbol-hasInstance"><a href="#Symbol-toStringTag-与-Symbol-hasInstance" class="headerlink" title="Symbol.toStringTag 与 Symbol.hasInstance"></a>Symbol.toStringTag 与 Symbol.hasInstance</h5><pre><code class="js">function Foo(greeting) {  this.greeting = greeting;}Foo.prototype[Symbol.toSringTag] = &quot;Foo&quot;;Object.defineProperty(Foo, Symbol.hasInstance, {  value: function(inst) {    return inst.greeting == &#39;hello&#39;  }})var a = new Foo(&quot;hello&quot;)var b = new Foo(&quot;world&quot;)b[Symbol.toStringTag] = &#39;cool&#39;a.toString() // [Object Foo]b.toString() // [Object cool]a instanceof Foo; // trueb instanceof Foo; // false</code></pre><blockquote><p>原型（或者是实例本身）的@@toStringTag符号指定了在[Object ___]字符串化时使用的字符串值</p></blockquote><blockquote><p>@@hasInstance 符号是在构造器函数上的一个方法，接收实例对象值，通过返回true 或者 false 来指示这个值是否可以被认为是一个实例<br>要在一个函数上设置@@hasInstance必须使用Object.defineProperty，因为默认的那个是不可写的</p></blockquote><h5 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h5><p>这个符号控制要生成新实例的时候，类的内置方法使用哪一个构造器</p><pre><code class="js">class Cool {  // 把@@species推迟到子类  static get [Symbol.species]() {return this;} // 这个就是默认的行为  again(){    return new this.constructor[Symbol.species]();  }}class Fun extends Cool {}class Awesome extends Cool {  // 强制指定@@species为父构造器  static get [Symbol.species]() {    return Cool;  }}var a = new Fun(),b = new Awesome(),c = a.again(),d = b.again();c instanceof Fun; // trued instanceof Awesome; // falsed instanceof Cool; // true</code></pre><h5 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h5><p>如果一个对象或者数组要使用== 或者+那么就必须被强制转化成一个原生类型</p><pre><code class="js">var arr = [1,2,3,4,5]arr + 10 // 1,2,3,4,510arr[Symbol.toPrimitive] = function (hint) {  if(hint == &#39;default&#39; || hint == &#39;number&#39;) {    return this.reduce(function(acc, curr){      return acc + curr;    }, 0)  } }arr + 10 // 25</code></pre><blockquote><p>Symbol.toPrimitive方法根据调用ToPrimitive的运算期望的类型，会提供一个提示<code>hint</code>指定”string”、”number”或者”default”（这应该被解释成”number”）。在前面的代码中，加法运算没有提示（传入”default”）。而乘法运算提示为”number”，String(arr)提示为”string”。</p></blockquote><h5 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h5><p>可以被定义为任何对象（比如数组或者其他可迭代对象）的布尔属性，用来指示如果把它传给一个数组的<code>concat()</code>是否应该将其<strong>展开</strong></p><pre><code class="js">var a = [1,2,3],b = [4,5,6];b[Symbol.isConcatSpreadable] = false;[].contact(a,b); // [1,2,3,[4,5,6]]</code></pre><h5 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h5><p>可以被定义为任意对象的对象属性，用来指示使用with语句时那些属性可以或不可以暴露为词法变量</p><pre><code class="js">var o = {a:1, b:2, c:3},a = 10, b = 20, c = 30;o[Symbol.unscopables] = {  a: false, // 能暴露为词法变量，因为是unscopables  b: true,  c: false}with (o) {  console.log(a,b,c)  // 1 20 3}</code></pre><blockquote><p>strict 模式下不允许使用with属性，应该尽量避免使用with，所以这个没有什么用</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的JavaScript（上）学习笔记</title>
    <link href="undefined2020/04/js1/"/>
    <url>2020/04/js1/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="LHS-和-RHS"><a href="#LHS-和-RHS" class="headerlink" title="LHS 和 RHS"></a>LHS 和 RHS</h3><p>L 和 R 代表左右</p><blockquote><p>LHS 赋值操作的目标是谁<br>RHS 谁是赋值操作的源头</p></blockquote><p>变量出现在赋值操作的左边对其进行<code>LHS</code>查询，即试图找到该容器并可对其进行赋值操作，<strong>与其原先是否有内容无关</strong></p><p>变量出现在赋值操作的右边对其进行<code>RHS</code>查询，即试图找到该容器中的<strong>内容</strong></p><h3 id="ReferenceError同作用域判别失败有关"><a href="#ReferenceError同作用域判别失败有关" class="headerlink" title="ReferenceError同作用域判别失败有关"></a>ReferenceError同作用域判别失败有关</h3><p>严格模式下进行LHS查询失败就会出现，<strong>非严格模式</strong>下会自动创建一个变量</p><p>RHS查询失败一定会报这个错误</p><p>TypeError代表作用域判别成功了但是对<strong>结果的操作</strong>是非法的或者不合理的</p><p>LHS查询是从底层一层一层<strong>向上</strong>找的，所以下一级的变量会对上级的变量形成“遮蔽”现象</p><p><code>eval(&lt;str&gt;)</code>中间的str可以当成一开始就写在那个位置的代码使用，可以对上一级的变量进行“遮蔽”</p><p><code>with(obj){ a = 1 } =&gt; obj.a = 1</code> with会创建一个作用域，并把obj的所有属性和方法放进去，进行的是正常的LHS查询，但是这就导致了当obj中没有被赋值的属性的时候就会在全局作用域中创建一个变量导致变量泄露到全局作用域即<code>obj.a =&gt; undefined</code>,<code>window.a =&gt; 2</code></p><blockquote><p>eval和with都会导致引擎对代码的优化失败从而降低运行效率</p></blockquote><h3 id="IIFE-Immediately-Invoked-Function-Expression-：立即执行函数"><a href="#IIFE-Immediately-Invoked-Function-Expression-：立即执行函数" class="headerlink" title="IIFE(Immediately Invoked Function Expression)：立即执行函数"></a>IIFE(Immediately Invoked Function Expression)：立即执行函数</h3><p>可以把window当成参数直接传进去，形参是global</p><p>将一个参数命名为undefined但是不传参数就能保证undefined是真的undefined，防止被覆盖，例如<code>undefined = true</code>这种代码</p><p>尽量减少使用匿名函数，直接加上个名字就好，这样在出错的时候更容易找到位置</p><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><ul><li><strong>with</strong></li><li><strong>try/catch</strong> (ES3就有了)<ul><li>catch里边就是一个作用域，看上去像是一个函数作用域（类似）</li></ul></li><li><strong>let</strong>创建的变量并不会被提升，所以在声明之前使用都会报ReferenceError错误<ul><li>为代码提供一个显式的作用域并使用let可以让引擎在合适的时间回收垃圾</li></ul></li><li><strong>const</strong> 可以创建块作用域变量</li></ul><blockquote><p>词法作用域关注函数在何处声明，动态作用域关注函数从何处调用</p></blockquote><h3 id="Traceur"><a href="#Traceur" class="headerlink" title="Traceur"></a>Traceur</h3><p>使用google的Traceur可以将es6转换为es5，将let转换为try/catch</p><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>提升的时候函数优先也就是说</p><pre><code class="js">foo() //1var foo // 重复声明而被忽略function foo(){ // 由于优先而被提升到最顶，然后就执行了foo  console.log(1)}foo = function() {  console.log(2)}</code></pre><p><code>var a = 2; =&gt; var a; a = 2;</code>引擎将其拆成两个声明，一个是在编译阶段的任务，一个是在执行阶段的任务</p><p>声明本身会被提升，但是包括函数表达式的赋值在内的赋值操作都不会被提升</p><p>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>为创建内部作用域而调用了一个包装函数</p><p>包装函数的返回值至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包</p><h2 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>箭头函数会使this继承上一级的this</p><p>使用bind将外边的this传进入也更加靠谱</p><p>this既不指向函数自身，也不指向函数的作用域</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><ul><li>独立函数调用，此时this指向全局作用域，但是如果使用严格模式则会绑定undefined</li><li>虽然this绑定规则完全取决于调用位置，但是只有函数运行在非strict mode下时，默认绑定才能绑定到全局对象；在严格模式下调用函数则不会影响默认绑定</li></ul><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><ul><li>调用位置是否有上下文对象，或者说时被某个对象拥有或者包含</li><li><code>function foo(){} var obj = {foo:foo} obj.foo()</code>此时this指向obj</li><li><code>function foo(){} var obj1 = {foo:foo} var obj2 = {obj1:obj1} obj2.obj1.foo()</code>此时this指向obj1，即对象属性引用链中只有上一层或者说最后一层调用位置中起作用</li><li><code>function foo(){} var obj = {foo:foo} var bar = obj.foo bar()</code>此时bar的this指向全局对象（隐式丢失），虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定</li></ul><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><ul><li>call和apply以及bind的详细介绍<a href="https://blog.csdn.net/wyyandyou_6/article/details/81488103" target="_blank" rel="noopener">链接</a></li><li><code>arr.forEach(fn(currentValue, index, arr),thisValue)</code>在thisValue显式绑定this</li></ul><h4 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h4><ul><li>包括内置对象函数在内的所有函数都可以使用new来调用，这种函数调用被称为构造函数调用</li><li>使用new来调用函数，或者发生构造函数调用时，会自动执行下面的操作<ul><li>创建（或者说构造）一个全新的对象</li><li>这个新对象会执行Prototype连接</li><li>这个新对象会绑定到函数调用的this（<strong>new绑定</strong>）</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象</li></ul></li></ul><blockquote><p>优先级 new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定，在bind函数中会判断是不是new调用，new优先</p></blockquote><blockquote><p>如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用的时候或被忽略，实际应用的是默认绑定规则<br>接上，但是假如函数中确实使用到了this就会污染全局作用域，所以使用<code>Object.create(null)</code>,来创建一个空对象，比{}还少一个prototype，用这个代替null当作this的绑定对象</p></blockquote><p>柯里化<a href="https://www.jianshu.com/p/2975c25e4d71" target="_blank" rel="noopener">链接</a></p><p>软绑定<a href="https://segmentfault.com/q/1010000006223479" target="_blank" rel="noopener">链接</a></p><h4 id="箭头函数下的this"><a href="#箭头函数下的this" class="headerlink" title="箭头函数下的this"></a>箭头函数下的this</h4><ul><li>箭头函数不适用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this</li><li>箭头函数绑定的this无法被改变，即使是new也不行</li><li>this指向调用时上级的this</li><li>以后要尽量减少that=this的写法，多用bind以及箭头函数</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li>可以通过声明形式(可以添加多个键值对)和构造模式(必须逐个添加属性)定义</li></ul><h3 id="六种主要类型（语言类型）"><a href="#六种主要类型（语言类型）" class="headerlink" title="六种主要类型（语言类型）"></a>六种主要类型（语言类型）</h3><p><code>string number boolean null undefined object</code>,除了<strong>object</strong>都不是对象类型</p><blockquote><p>由于对象底层表示为二进制，前三位为0被判定为object，但是null二进制全为零，<strong>所以执行typeof会返回object</strong></p></blockquote><h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><p><code>String Number Boolean Object Function Array Date RegExp Error</code></p><ul><li><p>一般情况下，引擎会把字面量转化为对应的对象，但是<code>null</code>和<code>undefined</code>只有<strong>文字形式</strong>，<code>Date</code>只有<strong>构造形式</strong></p></li><li><p>对于 <code>Object Function Array RegExp</code> 来说不论是文字形式还是构造形式都是对象，不是字面量</p></li><li><p><code>.a</code>属性访问 <code>[&#39;a&#39;]</code> 键访问,键访问可以接受任意UTF-8/Unicode字符串作为属性名，例如’Super-Fun!’</p></li><li><p>es6中在字面量定义对象属性时，加上<code>[变量]</code>就可以做到可计算属性名</p></li></ul><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><ul><li><code>JSON.parse(JSON.stringify(obj))</code>的方式复制不了function</li><li><code>Object.assign({}, obj1,...)</code>的方式可以浅复制，包括function</li></ul><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><ul><li>查看<code>Object.getOwnPropertyDiscriptor(obj, &lt;key&gt;)</code></li><li>设置<pre><code class="js">Object.defineProperty(obj,&#39;a&#39;,{  value: 2, //值  writable: true, // 可写，设置false时类似设置setter为空，此时修改值会报typeError（严格模式），非严格模式会静默失败  configurable: true, // 可配置，单向操作，设置为false之后就改不回来了并且不可删除(delete，非严格模式会静默失败)，但是仍可以设置writable为false，不管是不是严格模式修改不可配置的属性描述符都会出错  enumerable: true // 可枚举，如果不想让其出现在for...in 循环中就设置为false})</code></pre></li><li>不变性<ul><li>对象常量：结合<code>configurable: false,writable: false,</code>就可以创建一个真正的常量属性（不可修改，重定义或删除）</li><li>禁止拓展：<code>Object.preventExtensions(obj)</code>禁止对象添加新的属性并且保留已有属性</li><li>密封：<code>Object.seal(obj)</code>相当于禁止拓展加<code>configurable: false</code>即不能添加新的属性也不能重新配置或删除任何现有属性</li><li>冻结：<code>Object.freeze()</code>相当于先密封再<code>writable: false</code>，但是仍不能冻结这个对象引用的对象<ul><li>深度冻结，先冻结该对象，然后遍历其子对象然后冻结</li></ul></li></ul></li><li><code>[[get]]</code>先在obj中查找属性名相同的属性，没有就去查询原型链</li><li><code>[[put]]</code>先看有没有setter（优先使用），然后看是不是writable</li><li>get 和 set<ul><li><pre><code class="js">var obj = {  // 给a定义一个getter  get a() {    return this._a_  },  set a(val) {    this._a_ = val * 2  }}Object.defineProperty(  obj,  &#39;b&#39;,  {    get: function() {return this._a_ * 2},    //确保b会出现在对象的属性列表中    enumerable: true  })obj.a = 2obj.a // 4obj.b // 4</code></pre></li><li>以上操作都会在obj中创建一个不包含值的属性，对于这个属性的访问会自动调用一个隐藏函数，返回值即是被当作属性访问的返回值</li><li>在定义新属性时，get和set不能同value或者writable一起出现否则报TypeError</li></ul></li><li>存在性<ul><li><code>a in obj</code>in操作符或检查对象及其原型链<ul><li>in操作符只检查的是属性名，而不是值，所以 <code>4 in [4,1,2] -&gt; false</code></li></ul></li><li><code>obj.hasOwnProperty(&#39;a&#39;)</code>只检查对象，不检查原型链<ul><li>对于没有原型链的对象如<code>Object.create(null)</code>可<code>Object.prototype.hasOwnProerty.call(obj)</code>显式绑定</li></ul></li><li><code>Object.keys(obj)</code>查看对象中所有键，只显示可枚举属性，并且不会查找原型链，返回数组</li><li><code>Object.getOwnPropertyNames(obj)</code>返回数组，包含所有属性，不论是否可枚举，不会查找原型链</li><li><code>obj.propertyIsEnumerable(&#39;a&#39;)</code>返回Boolean，查看该元素是否可枚举</li></ul></li></ul><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>forEach：忽略回调函数的返回值</li><li>every：会一直运行到回调函数返回false</li><li>some：会一直运到到回调函数返回true</li><li>数组可以直接for of循环出所有的值</li><li>for of实际上是调用的迭代器对象</li><li>数组<pre><code class="js">var arr = []var it = arr[Symbol.iterator]()it.next() // {value: 1, done: false}//...it.next() // {done: true}</code></pre>注意:最后会出现这个<code>{done: true}</code></li></ul><h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><ul><li>对象并没有@@iterator所以无法完成for of 遍历，但是可以自己写一个<pre><code class="js">// 会生成无限个随机数var randoms = {  [Symbol.iterator]: function() {    return :function() {      return {value: Math.random()}    }  }}// -----------------------------------var obj = {  a: 2,  b: 3}Object.defineProperty(obj, Symbol.iterator,{  enumerable: false,  writable: false,  configurable: true,  value: function(){    var o = this;    var idx = 0;    var ks = Object.keys(o)    return {      next: function(){        return {          value: o[ks[idx++]],          done: (idx &gt; ks.length)        }      }    }  }})// 手动遍历var it = obj[Symbol.iterator]()it.next() //{ value: 2, done:false}it.next() //{ value: 3, done:false}it.next() //{ done:true}// 使用for offor(var v of obj) {  console.log(v)}// 2// 3</code></pre></li></ul><h2 id="混合对象“类”"><a href="#混合对象“类”" class="headerlink" title="混合对象“类”"></a>混合对象“类”</h2><ul><li>设计模式：实例化，继承，(相对)多态</li><li>多态并不能表示子类和父类有关联，子类得到的只是父类的一个副本，类的继承实际上就是复制</li><li>super关键字用于访问和调用一个对象的父对象上的函数。<code>super.prop</code>和<code>super[expr]</code>表达式在类和对象字面量任何方法定义中都是有效的。</li><li>js本身并不支持多重继承</li><li>类意味着复制，js并不会自动创建对象的副本</li><li>混入模式可以模拟类的复制行为，但是会产生丑陋并且脆弱的语法。</li><li>而且对象（函数）只能复制引用，无法复制被引用的对象或者函数本身，所以在js中模拟类是得不偿失的，虽然可以解决当前的问题，但是可能会留下更多的隐患</li></ul><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li><code>Object.create(...)</code>创建一个对象并将其<code>prototype</code>关联到指定对象</li><li>所有对象的<code>prototype</code>最终都指向了内置的<code>Object.prototype</code>其中包含类如<code>.toString();.valueOf()</code>之类的方法</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>如果foo不直接存在于obj上而是存在于原型链上层时会出现的三种情况</p><ul><li>如果上层的foo是普通的数据访问属性，并且没有被标记为只读，那就会在对象上直接创建foo属性，它是遮蔽属性</li><li>如果上层的foo是只读属性的话，严格模式下会抛出一个错误，正常模式下静默失败，可以理解为obj继承了foo但是foo是只读属性，所以不可更改（实际上js并没有继承这一概念，只是为了理解、<ul><li>而且仅限于 = 赋值中，使用<code>Object.defineProperty()</code>并不会受到任何影响</li><li>如果上层的foo存在且是一个setter，就会调用这个setter，foo不会重新定义也不会直接添加到obj中</li></ul></li></ul><h4 id="模仿类"><a href="#模仿类" class="headerlink" title="模仿类"></a>模仿类</h4><ul><li>利用所有函数都会拥有一个名为<code>prototype</code>的共有且不可枚举的属性，并且会指向另一个对象</li><li>通过<code>new foo()</code>最后我们得到了两个对象，并且他们互相关联，实际上new并没有直接创建关联，这个关联只是一个意外的副作用</li><li>new 会劫持所有的函数并用构造对象的形式来调用它，而且无论如何都会构造一个对象，换句话说在js中对于“构造函数”最准确的解释是：所有带new的函数调用</li><li>函数被创建的时候会默认在其<code>prototype</code>中声明一个不可枚举的<code>construct</code>属性，指向它自己，使用<code>new</code>创建一个对象的时候由于其<code>prototype</code>会链接到函数的<code>prototype</code>上，所以<code>obj.construct</code>会委托到<code>prototype</code>上也就是指向了函数，但是如果那个函数重定义了整个<code>prototype</code>，再去查找<code>obj.construct</code>就会一层一层委托到<code>Object</code>的<code>construct</code>上，也就是指向<code>Object</code>，总结一下就是说construct并不能表示由“某函数”创建，尽量不要使用它以减少麻烦</li><li>实现类的继承,实际上是委托<ul><li>方法一<code>Bar.prototype = Object.create(Foo.prototype)</code></li><li>方法二<code>Object.setPrototypeOf(Bar.prototype, Foo.prototype)</code> ES6语法</li></ul></li><li><code>__proto__</code>存在于<code>Object.prototype</code>中，看起来像一个属性，但是更像是getter/setter</li><li>创建关联最好的方式不是创建一个类，而是使用<code>Object.create()</code></li><li>所有包含”继承”之类的词语都不适合形容js的操作，更应该使用”委托”，因为“继承”是复制操作（由上至下的），”委托”是链接操作（由下至上的）</li></ul><h4 id="行为委托"><a href="#行为委托" class="headerlink" title="行为委托"></a>行为委托</h4><ul><li><p>js中<code>[[prototype]]</code>这个机制的本质就是<strong>对象之间的关联关系</strong></p></li><li><p>在正常的模仿类的设计中，上代码！  </p><pre><code class="js">function Foo(who) {  this.me = who}Foo.prototype.indetify = function() {  return &quot;I am&quot; + this.me}function Bar(who) {  Foo.call(this, who)}   Bar.prototype = Object.create(Foo.prototype)Bar.prototype.speak = function() {  alert(&#39;Hello,&#39;+ this.indetify() + &#39;.&#39;)}var b1 = new Bar(&#39;b1&#39;)var b2 = new Bar(&#39;b2&#39;)b1.speak()b2.speak()</code></pre></li><li><p>在es6的语法糖中，上代码！</p><pre><code class="js">class Foo {  constructor(who) {    this.me = who  }  indetify(){    return &quot;I am&quot; + this.me  }}class Bar extends Foo {  constructor(who) {    super(who)  }  speak(){    alert(&#39;Hello,&#39;+ super.indetify() + &#39;.&#39;)  }}var b1 = new Bar(&#39;b1&#39;)var b2 = new Bar(&#39;b2&#39;)b1.speak()b2.speak()</code></pre></li><li><p>在关联风格代码中的实现，上代码！</p><pre><code class="js"> var Foo = {   init: function(who) {     this.me = who   },   indetify: function() {     return &quot;I am&quot; + this.me   } } var Bar = Object.create(Foo) Bar.speak = function() {   alert(&#39;Hello,&#39;+ this.indetify() + &#39;.&#39;) } var b1 = Object.create(Bar) b1.init(&#39;b1&#39;) var b2 = Object.create(Bar) b2.init(&#39;b2&#39;) b1.speak() b2.speak()</code></pre></li><li><p>同为关联风格代码，但是进行了语法上的优化（es6中的简洁方法声明）（Object.setPrototypeOf后置关联）这样看起来舒服不少  </p><pre><code class="js"> var Foo = {   init(who) {     this.me = who   },   indetify() {     return &quot;I am&quot; + this.me   } } var Bar = {   speak() {     alert(&#39;Hello,&#39;+ this.indetify() + &#39;.&#39;)   } } Object.setPrototypeOf(Bar, Foo) var b1 = Object.create(Bar) b1.init(&#39;b1&#39;) var b2 = Object.create(Bar) b2.init(&#39;b2&#39;) b1.speak() b2.speak()</code></pre></li></ul><ul><li>instanceof 如果 Bar”继承了“Foo 那么就是 <code>Bar.prototype instanceof Foo =&gt; true</code></li><li>如果<code>Bar = Object.create(Foo)</code>则<code>Foo.isPrototypeOf(Bar) =&gt; true</code>,<code>Object.getPrototypeOf(Bar) === Foo =&gt; ture</code> </li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（高级篇</title>
    <link href="undefined2020/04/ts3/"/>
    <url>2020/04/ts3/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript高级"><a href="#TypeScript高级" class="headerlink" title="TypeScript高级"></a>TypeScript高级</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名用来给一个类型起个新名字。</p><pre><code class="ts">type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name {    if (typeof n === &#39;string&#39;) {        return n;    } else {        return n();    }}</code></pre><p>上例中，我们使用 <code>type</code> 创建类型别名。</p><blockquote><p>类型别名常用于联合类型。</p></blockquote><h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个。</p><pre><code class="ts">type EventNames = &#39;click&#39; | &#39;scroll&#39; | &#39;mousemove&#39;;function handleEvent(ele: Element, event: EventNames) {    // do something}handleEvent(document.getElementById(&#39;hello&#39;), &#39;scroll&#39;);  // 没问题handleEvent(document.getElementById(&#39;world&#39;), &#39;dbclick&#39;); // 报错，event 不能为 &#39;dbclick&#39;// index.ts(7,47): error TS2345: Argument of type &#39;&quot;dbclick&quot;&#39; is not assignable to parameter of type &#39;EventNames&#39;.</code></pre><blockquote><p>注意，类型别名与字符串字面量类型都是使用 <code>type</code> 进行定义。</p></blockquote><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>定义一对值分别为 <code>string</code> 和 <code>number</code> 的元组</p><pre><code class="ts">let tom: [string, number] = [&#39;Tom&#39;, 25];let tom2: [string, number]tom2[0] = &#39;Tom&#39;  // 直接赋值会在node和浏览器中报错，但是ts不会报错tom2[1] = 1 // 可以对它赋值，也可以不赋值，不会报错tom2[1] = &#39;tox&#39; // 这个地方就会报错，因为指定了是numbertom2 = [&#39;Tom&#39;] // 会报错，因为整体赋值必须要符合定义tom2.push(&#39;d&#39;) // 新加入得元素只要符合tom2.push(1)let tom3: any = [] // 经测试正常还是用这个把</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p><pre><code class="ts">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};</code></pre><p>枚举成员会被赋值为从 0 开始递增的数字，同时也会对枚举值到枚举名进行反向映射：</p><pre><code class="ts">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 0); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // trueconsole.log(Days[0] === &quot;Sun&quot;); // trueconsole.log(Days[1] === &quot;Mon&quot;); // trueconsole.log(Days[2] === &quot;Tue&quot;); // trueconsole.log(Days[6] === &quot;Sat&quot;); // true// 会被编译为var Days;(function (Days) {    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;})(Days || (Days = {}));</code></pre><p><strong>手动赋值</strong></p><pre><code class="ts">enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};console.log(Days[&quot;Sun&quot;] === 7); // trueconsole.log(Days[&quot;Mon&quot;] === 1); // trueconsole.log(Days[&quot;Tue&quot;] === 2); // trueconsole.log(Days[&quot;Sat&quot;] === 6); // true</code></pre><blockquote><p>如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 是不会察觉到这一点的，小心被覆盖<br>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 1</p></blockquote><p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 tsc 无视类型检查 (编译出的 js 仍然是可用的)</p><pre><code class="ts">enum Days {Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;};</code></pre><p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p><pre><code class="ts">enum Color {Red, Green, Blue = &quot;blue&quot;.length};  // &quot;blue&quot;.length 就是一个计算所得项。</code></pre><p>上面的例子不会报错，但是<strong>如果紧接在计算所得项后面的是未手动赋值的项</strong>，那么它就会因为无法获得初始值而报错</p><p><strong>常数枚举</strong></p><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。</p><p><strong>外部枚举</strong></p><p>是使用 <code>declare enum</code> 定义的枚举类型</p><blockquote><p>同时使用 declare 和 const 也是可以的</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>TypeScript</strong> 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p><p><strong>TypeScript</strong> 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public、private</code> 和 <code>protected</code>。</p><p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化</p><p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承</p><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁</p><pre><code class="ts">class Animal {    // public name: string;    public constructor (public name) {        // this.name = name;    }}class Animal {    readonly name;    public constructor(name) {        this.name = name;    }}a.name = &#39;Tom&#39;; //会报错</code></pre><blockquote><p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面</p></blockquote><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p><code>abstract</code> 用于定义抽象类和其中的抽象方法</p><p>首先，抽象类是不允许被实例化的</p><p>其次，抽象类中的抽象方法必须被子类实现</p><pre><code class="ts">abstract class Animal {    public name;    public constructor(name) {        this.name = name;    }    public abstract sayHi();}class Cat extends Animal {    public sayHi() {        console.log(`Hello`);    }}let animal =  new Animal(&#39;dd&#39;) // 会报错，抽象类不能被实例化let cat = new Cat(&#39;dd&#39;)  // ok</code></pre><blockquote><p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类</p></blockquote><h3 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h3><p>给类加上 TypeScript 的类型很简单，与接口类似</p><pre><code class="ts">class Animal {    name: string;    constructor(name: string) {        this.name = name;    }    sayHi(): string {      return `My name is ${this.name}`;    }}let a: Animal = new Animal(&#39;Jack&#39;);console.log(a.sayHi()); // My name is Jack</code></pre><h2 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h2><p>接口（Interfaces）可以用于对「对象的形状（Shape）」进行描述。</p><p>这一章主要介绍接口的另一个用途，对类的一部分行为进行抽象。</p><h3 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h3><p>实现（<code>implements</code>）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它</p><p>一个类可以实现多个接口</p><pre><code class="ts">interface Alarm {    alert(): void;}interface Light {    lightOn(): void;    lightOff(): void;}class Door {}class SecurityDoor extends Door implements Alarm {    alert() {        console.log(&#39;SecurityDoor alert&#39;);    }}class Car implements Alarm, Light {    alert() {        console.log(&#39;Car alert&#39;);    }    lightOn() {        console.log(&#39;Car light on&#39;);    }    lightOff() {        console.log(&#39;Car light off&#39;);    }}</code></pre><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><pre><code class="ts">interface Alarm {    alert(): void;}interface LightableAlarm extends Alarm {    lightOn(): void;    lightOff(): void;}</code></pre><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><pre><code class="ts">class Point {    x: number;    y: number;    constructor(x: number, y: number) {        this.x = x;        this.y = y;    }}interface Point3d extends Point {    z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3};</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p><pre><code class="ts">function createArray(length: number, value: any): Array&lt;any&gt; {    let result = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray&lt;string&gt;(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><h3 id="多个类型参数"><a href="#多个类型参数" class="headerlink" title="多个类型参数"></a>多个类型参数</h3><pre><code class="ts">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] {    return [tuple[1], tuple[0]];}swap([7, &#39;seven&#39;]); // [&#39;seven&#39;, 7]</code></pre><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</p><pre><code class="ts">interface Lengthwise {    length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {    console.log(arg.length);    return arg;}</code></pre><p>上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。</p><p>此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了</p><p>多个类型参数之间也可以互相约束</p><pre><code class="ts">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T {    for (let id in source) {        target[id] = (&lt;T&gt;source)[id];    }    return target;}let x = { a: 1, b: 2, c: 3, d: 4 };copyFields(x, { b: 10, d: 20 });</code></pre><p>上例中，我们使用了两个类型参数，其中要求 T 继承 U，这样就保证了 U 上不会出现 T 中不存在的字段</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><pre><code class="ts">interface CreateArrayFunc&lt;T&gt; {    (length: number, value: T): Array&lt;T&gt;;}let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}createArray(3, &#39;x&#39;); // [&#39;x&#39;, &#39;x&#39;, &#39;x&#39;]</code></pre><h3 id="泛型参数的默认类型"><a href="#泛型参数的默认类型" class="headerlink" title="泛型参数的默认类型"></a>泛型参数的默认类型</h3><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p><pre><code class="ts">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; {    let result: T[] = [];    for (let i = 0; i &lt; length; i++) {        result[i] = value;    }    return result;}</code></pre><h2 id="声明的合并"><a href="#声明的合并" class="headerlink" title="声明的合并"></a>声明的合并</h2><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</p><h3 id="函数的合并"><a href="#函数的合并" class="headerlink" title="函数的合并"></a>函数的合并</h3><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string {    if (typeof x === &#39;number&#39;) {        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    } else if (typeof x === &#39;string&#39;) {        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);    }}</code></pre><h3 id="接口的合并"><a href="#接口的合并" class="headerlink" title="接口的合并"></a>接口的合并</h3><pre><code class="ts">interface Alarm {    price: number;}interface Alarm {    weight: number;}// 相当于interface Alarm {    price: number;    weight: number;}</code></pre><blockquote><p>合并的属性的类型必须是唯一的</p></blockquote><p>接口中方法的合并，与函数的合并一样</p><pre><code class="ts">interface Alarm {    price: number;    alert(s: string): string;}interface Alarm {    weight: number;    alert(s: string, n: number): string;}// 相当于interface Alarm {    price: number;    weight: number;    alert(s: string): string;    alert(s: string, n: number): string;}</code></pre><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p><a href="https://ts.xcatliu.com/advanced/further-reading" target="_blank" rel="noopener">索引链接</a></p>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>高级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（基础篇2</title>
    <link href="undefined2020/04/ts2/"/>
    <url>2020/04/ts2/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数声明定义</p><pre><code class="ts">function sum(x: number, y: number): number {  return x + y;}</code></pre><blockquote><p>输入多余的（或者少于要求的）参数，是不被允许的</p></blockquote></li><li><p>函数表达式定义</p><pre><code class="ts">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {  return x + y;};</code></pre><blockquote><p>注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。<br>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。<br>在 ES6 中，=&gt; 叫做箭头函数，应用十分广泛，可以参考 ES6 中的箭头函数。</p></blockquote></li><li><p>用接口定义函数的形状</p><pre><code class="ts">interface SearchFunc {  (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(source: string, subString: string) {  return source.search(subString) !== -1;}</code></pre><blockquote><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p></blockquote></li><li><p>可选参数<br>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数</p><pre><code class="ts">function buildName(firstName: string, lastName?: string) {  if (lastName) {      return firstName + &#39; &#39; + lastName;  } else {      return firstName;  }}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);</code></pre><blockquote><p>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必需参数了</p></blockquote></li><li><p>参数默认值<br>TypeScript 会将添加了默认值的参数识别为可选参数</p><pre><code class="ts">function buildName(firstName: string, lastName: string = &#39;Cat&#39;) {  return firstName + &#39; &#39; + lastName;}let tomcat = buildName(&#39;Tom&#39;, &#39;Cat&#39;);let tom = buildName(&#39;Tom&#39;);</code></pre><blockquote><p>此时就不受「可选参数必须接在必需参数后面」的限制了</p></blockquote></li><li><p>剩余参数<br>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）</p></li></ul><p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它</p><pre><code class="ts">function push(array: any[], ...items: any[]) {    items.forEach(function(item) {        array.push(item);    });}let a = [];push(a, 1, 2, 3);</code></pre><blockquote><p>rest 参数只能是最后一个参数</p></blockquote><ul><li>重载</li></ul><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。</p><p>利用联合类型，我们可以这么实现：</p><pre><code class="ts">function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string {    if (typeof x === &#39;number&#39;) {        return Number(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    } else if (typeof x === &#39;string&#39;) {        return x.split(&#39;&#39;).reverse().join(&#39;&#39;);    }}</code></pre><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p><blockquote><p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p></blockquote><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>使用 <code>值</code> as <code>类型</code> 的语法</p><pre><code class="ts">interface Cat {    name: string;    run(): void;}interface Fish {    name: string;    swim(): void;}function isFish(animal: Cat | Fish) {    if (typeof animal.swim === &#39;function&#39;) {  // 会报错，因为swim不是Cat和Fish的共有属性        return true;    }    return false;}function isFish(animal: Cat | Fish) {    if (typeof (animal as Fish).swim === &#39;function&#39;) { // 使用断言，避免错误        return true;    }    return false;}</code></pre><blockquote><p>类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误</p></blockquote><pre><code class="ts">window.foo = 1; // 直接赋值会提示你window上边没有foo属性(window as any).foo = 1; // 把window断言成一个any就可以随便赋值了</code></pre><ul><li>总结</li></ul><p>联合类型可以被断言为其中一个类型</p><p>父类可以被断言为子类</p><p>任何类型都可以被断言为 any</p><p>any 可以被断言为任何类型</p><p>要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可</p><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p><p>声明文件必需以 <code>.d.ts</code> 为后缀。</p><pre><code class="ts">// src/jQuery.d.tsdeclare var jQuery: (selector: string) =&gt; any;</code></pre><blockquote><p>假如仍然无法解析，那么可以检查下 <code>tsconfig.json</code> 中的 <code>files、include</code> 和 <code>exclude</code> 配置，确保其包含了 <code>jQuery.d.ts</code> 文件。</p></blockquote><h2 id="第三方声明文件"><a href="#第三方声明文件" class="headerlink" title="第三方声明文件"></a>第三方声明文件</h2><p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。</p><p>我们可以直接下载下来使用，但是更推荐的是使用 <code>@types</code> 统一管理第三方库的声明文件。</p><p><code>@types</code> 的使用方式很简单，直接用 <code>npm</code> 安装对应的声明模块即可，以 <code>jQuery</code> 举例</p><pre><code class="cmd">cnpm install @types/jquery --save-dev</code></pre><p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">这个页面</a>搜索你需要的声明文件。</p><h2 id="书写声明文件"><a href="#书写声明文件" class="headerlink" title="书写声明文件"></a>书写声明文件</h2><p>当一个第三方库没有提供声明文件时，我们就需要自己书写声明文件了。前面只介绍了最简单的声明文件内容，而真正书写一个声明文件并不是一件简单的事，以下会详细介绍如何书写声明文件。</p><ul><li>全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>npm包<a href="https://ts.xcatliu.com/basics/declaration-files#npm-bao" target="_blank" rel="noopener">教程链接</a></li><li>UMD库<a href="https://ts.xcatliu.com/basics/declaration-files#umd-ku" target="_blank" rel="noopener">教程链接</a></li><li>直接扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#zhi-jie-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>在 npm 包或 UMD 库中扩展全局变量<a href="https://ts.xcatliu.com/basics/declaration-files#zai-npm-bao-huo-umd-ku-zhong-kuo-zhan-quan-ju-bian-liang" target="_blank" rel="noopener">教程链接</a></li><li>模块插件<a href="https://ts.xcatliu.com/basics/declaration-files#mo-kuai-cha-jian" target="_blank" rel="noopener">教程链接</a></li><li>声明文件中的依赖<a href="https://ts.xcatliu.com/basics/declaration-files#sheng-ming-wen-jian-zhong-de-yi-lai" target="_blank" rel="noopener">教程链接</a></li><li>自动生成声明文件<a href="https://ts.xcatliu.com/basics/declaration-files#zi-dong-sheng-cheng-sheng-ming-wen-jian" target="_blank" rel="noopener">教程链接</a></li></ul><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>ECMAScript 标准提供的内置对象有：<code>Boolean、Error、Date、RegExp</code> 等。</p><pre><code class="ts">let b: Boolean = new Boolean(1);let e: Error = new Error(&#39;Error occurred&#39;);let d: Date = new Date();let r: RegExp = /[a-z]/;</code></pre><blockquote><p>更多的内置对象，可以查看 MDN 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener">文档</a>。</p></blockquote><h2 id="DOM-和-BOM-的内置对象"><a href="#DOM-和-BOM-的内置对象" class="headerlink" title="DOM 和 BOM 的内置对象"></a>DOM 和 BOM 的内置对象</h2><p>DOM 和 BOM 提供的内置对象有：<code>Document、HTMLElement、Event、NodeList</code> 等。</p><pre><code class="ts">let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll(&#39;div&#39;);document.addEventListener(&#39;click&#39;, function(e: MouseEvent) {  // Do something});</code></pre><h2 id="用-TypeScript-写-Node-js"><a href="#用-TypeScript-写-Node-js" class="headerlink" title="用 TypeScript 写 Node.js"></a>用 TypeScript 写 Node.js</h2><p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p><pre><code class="cmd">npm install @types/node --save-dev</code></pre>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript学习笔记（基础篇1</title>
    <link href="undefined2020/04/ts1/"/>
    <url>2020/04/ts1/</url>
    
    <content type="html"><![CDATA[<h1 id="TypeScript基础"><a href="#TypeScript基础" class="headerlink" title="TypeScript基础"></a>TypeScript基础</h1><p><a href="https://ts.xcatliu.com" target="_blank" rel="noopener">TypeScript入门教程</a></p><h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>这只是一个笔记，并不是教程，阮一峰大佬写的教程链接在上边</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>cnpm install -g typescript</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><pre><code>tsc hello.ts</code></pre><blockquote><p>我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。</p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>TypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以。</p><blockquote><p>TypeScript 只会进行静态检查，如果发现有错误，编译的时候就会报错。<br>如果要在报错的时候终止 js 文件的生成，可以在 tsconfig.json 中配置 noEmitOnError 即可。关于 tsconfig.json，请参阅<a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html" target="_blank" rel="noopener">官方手册</a></p></blockquote><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。</p><p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。</p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p><code>boolean</code></p><pre><code class="ts">let isDone: boolean = false;</code></pre><p>注意，使用构造函数 <strong>Boolean</strong> 创造的对象不是布尔值：</p><pre><code class="ts">let createdByNewBoolean: boolean = new Boolean(1); // 会报错的，是一个Boolean对象let createdByNewBoolean: boolean = Boolean(1); // 通过，是一个boolean</code></pre><blockquote><p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样，不再赘述。</p></blockquote><h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><p><code>number</code></p><pre><code class="ts">let decLiteral: number = 6;let hexLiteral: number = 0xf00d;// ES6 中的二进制表示法let binaryLiteral: number = 0b1010;// ES6 中的八进制表示法let octalLiteral: number = 0o744;let notANumber: number = NaN;let infinityNumber: number = Infinity;</code></pre><blockquote><p>编译完会自动转成十进制</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><code>string</code></p><pre><code class="ts">let myName: string = &#39;Tom&#39;;let myAge: number = 25;// 模板字符串let sentence: string = `Hello, my name is ${myName}.I&#39;ll be ${myAge + 1} years old next month.`;</code></pre><blockquote><p>编译完模板字符串会变成加号串联的形式，自动加<code>/n</code></p></blockquote><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p><code>void</code></p><p><strong>JavaScript</strong> 没有空值（Void）的概念，在 <strong>TypeScript</strong> 中，可以用 <code>void</code> 表示没有任何返回值的函数：</p><pre><code class="ts">function alertName(): void {    alert(&#39;My name is Tom&#39;);}</code></pre><blockquote><p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code></p></blockquote><h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p><code>null undefined</code></p><pre><code class="ts">let u: undefined = undefined;let n: null = null;</code></pre><blockquote><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给其他类型的变量，但是反过来 <code>void</code> 不能赋值给任何类型的变量</p></blockquote><h3 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h3><p><code>any</code><br>如果是一个普通类型，在赋值中改变类型是不被允许的。</p><p>但是如果是<code>any</code>类型，则允许被赋值为任意类型</p><pre><code class="ts">let myFavoriteNumber: any = &#39;seven&#39;;myFavoriteNumber = 7;</code></pre><blockquote><p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p></blockquote><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</p><pre><code class="ts">let something;something = &#39;seven&#39;;something = 7;something.setName(&#39;Tom&#39;);</code></pre><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果变量在定义的时候赋值，但是没指定类型，会自动进行推论</p><pre><code class="ts">let myFavoriteNumber = &#39;seven&#39;;// 等价于let myFavoriteNumber: string = &#39;seven&#39;;myFavoriteNumber = 7; // 会报错</code></pre><blockquote><p>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查：</p></blockquote><h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型使用 | 分隔每个类型。</p><pre><code class="ts">let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;; // okmyFavoriteNumber = 7; // okmyFavoriteNumber = true; // 会报错</code></pre><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p><pre><code class="ts">function getLength(something: string | number): number {    return something.length; // 会报错，.length不是string和number共有的属性    return something.toString(); // ok}</code></pre><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p><pre><code class="ts">let myFavoriteNumber: string | number;myFavoriteNumber = &#39;seven&#39;;console.log(myFavoriteNumber.length); // 5myFavoriteNumber = 7;console.log(myFavoriteNumber.length); // 会报错</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p><p>TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。</p><pre><code class="ts">interface IPerson {    name: string;    age: number;}let tom: IPerson = {    name: &#39;Tom&#39;,    age: 25};</code></pre><p>接口一般首字母大写，有的编程语言会建议接口的名称加上<code>I</code>前缀</p><p>定义的变量比接口多属性少属性都是不允许的，<strong>赋值的时候，变量的形状必须和接口的形状保持一致。</strong></p><ul><li>可选属性</li></ul><p><strong>可选属性的含义是该属性可以不存在</strong>，这时<strong>仍然不允许添加未定义的属性</strong></p><pre><code class="ts">interface Person {    name: string;    age?: number;}let tom: Person = {    name: &#39;Tom&#39;,    gender: &#39;male&#39; // 这句就会报错，因为出现了未加定义的属性};</code></pre><ul><li>任意属性</li></ul><p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是<strong>它的类型的子集</strong></p><pre><code class="ts">interface Person {    name: string;    age?: number;    [propName: string]: string;}let tom: Person = {    name: &#39;Tom&#39;,    age: 25, // 这句就会报错，因为不是string，即使上边定义age是number也不行    gender: &#39;male&#39;,};interface Person {    name: string;    age?: number;    [propName: string]: string | number; // 接口定义成这样使用联合类型age就不会报错了}</code></pre><ul><li>只读属性</li></ul><p>一些字段只能在创建的时候被赋值</p><pre><code class="ts">interface Person {    readonly id: number;    name: string;    age?: number;    [propName: string]: any;}let tom: Person = {    id: 89757,    name: &#39;Tom&#39;,    gender: &#39;male&#39;};tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.</code></pre><blockquote><p>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</p></blockquote><h3 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h3><ul><li><p>「类型 + 方括号」表示法</p><pre><code class="ts">let fibonacci: number[] = [1, 1, 2, 3, 5];</code></pre><blockquote><p>数组的项中<strong>不允许</strong>出现其他的类型<br>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制,如果约定是<code>number</code>类型,<strong>push</strong>一个<code>string</code>类型就会报错</p></blockquote></li><li><p>数组泛型</p><pre><code class="ts">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</code></pre></li><li><p>用接口表示数组<br><code>NumberArray</code> 表示：只要索引的类型是数字时，那么值的类型必须是数字。</p><pre><code class="ts">interface NumberArray {  [index: number]: number;}let fibonacci: NumberArray = [1, 1, 2, 3, 5];</code></pre></li><li><p>类数组<br>类数组（Array-like Object）不是数组类型，比如 arguments：</p><pre><code class="ts">function sum() {  let args: {      [index: number]: number;      length: number;      callee: Function;  } = arguments;}</code></pre></li><li><p>any 在数组中的应用<br>一个比较常见的做法是，用 any 表示数组中允许出现任意类型：</p><pre><code class="ts">let list: any[] = [&#39;xcatliu&#39;, 25, { website: &#39;http://xcatliu.com&#39; }];</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>ts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ts</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Koa学习笔记</title>
    <link href="undefined2020/04/js-koa/"/>
    <url>2020/04/js-koa/</url>
    
    <content type="html"><![CDATA[<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>cnpm install koa --save</code></pre><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello-world"></a>hello-world</h2><pre><code class="js">const Koa = require(&#39;koa&#39;);const app = new Koa();app.use(async ctx =&gt; {  ctx.body = &#39;Hello World&#39;;});app.listen(3000);</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>使用yield以及next,当一个中间件调用<code>next()</code>函数时，函数挂起并控件传递给定义的下一个中间件。在没有更多的中间件执行下游之后，堆栈将退出，并且每个中间件被恢复以执行其上游行为。</p><pre><code class="js">const Koa = require(&#39;koa&#39;);const app = new Koa();const one = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; one&#39;);  next();  console.log(&#39;&lt;&lt; one&#39;);}const two = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; two&#39;);  next();  console.log(&#39;&lt;&lt; two&#39;);}const three = (ctx, next) =&gt; {  console.log(&#39;&gt;&gt; three&#39;);  next();  console.log(&#39;&lt;&lt; three&#39;);}app.use(one);app.use(two);app.use(three);app.listen(3000);/*&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one&gt;&gt; one&gt;&gt; two&gt;&gt; three&lt;&lt; three&lt;&lt; two&lt;&lt; one*/</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>应用配置是 app 实例属性，目前支持的配置项如下</p><ul><li>app.env node运行环境，默认为 NODE_ENV or “development”</li><li>app.proxy 表示是否开启代理信任开关,默认为false，如果为 true，则解析 “Host” 的 header 域，对于获取request请求中的host，protocol，ip分别优先从Header字段中的<a href="https://cloud.tencent.com/developer/section/1190030" target="_blank" rel="noopener">X-Forwarded-Host</a>，X-Forwarded-Proto，X-Forwarded-For获取</li><li>app.subdomainOffset 表示子域名是从第几级开始的，这个参数决定了request.subdomains的返回结果，默认值为2，表示 .subdomains 所忽略的字符偏移量。<pre><code class="js">//比如有netease.youdata.163.com域名app.subdomainOffset = 2;console.log(ctx.request.subdomains);  //返回[&quot;youdata&quot;, &quot;netease&quot;]app.subdomainOffset = 3;console.log(ctx.request.subdomains);  //返回[&quot;netease&quot;]//koa获取subdomains的源码get subdomains() {    const offset = this.app.subdomainOffset;    const hostname = this.hostname;    if (net.isIP(hostname)) return [];    return hostname    .split(&#39;.&#39;)    .reverse()    .slice(offset);}</code></pre></li></ul><h2 id="app-listen-…"><a href="#app-listen-…" class="headerlink" title="app.listen(…)"></a>app.listen(…)</h2><p><code>app.listen(...)</code> 实际上是以下代码的语法糖</p><pre><code class="js">http.createServer(app.callback()).listen(3000);</code></pre><p>这意味着您可以同时支持 <strong>HTTP</strong> 和 <strong>HTTPS</strong>，或者在多个端口监听同一个应用</p><pre><code class="js">const http = require(&#39;http&#39;);const https = require(&#39;https&#39;);const Koa = require(&#39;koa&#39;);const app = new Koa();http.createServer(app.callback()).listen(3000);https.createServer(app.callback()).listen(3001);</code></pre><h2 id="app-callback"><a href="#app-callback" class="headerlink" title="app.callback()"></a>app.callback()</h2><p>返回一个适合 <code>http.createServer()</code> 方法的回调函数用来处理请求。 您也可以使用这个回调函数将您的app挂载在 Connect/Express 应用上。</p><pre><code class="js">//koa的callback函数实现源码function callback() {      const fn = compose(this.middleware);   //koa-compose包负责将多个中间件组装成一个中间件  if (!this.listeners(&#39;error&#39;).length) this.on(&#39;error&#39;, this.onerror);      const handleRequest = (req, res) =&gt; {          const ctx = this.createContext(req, res);  //这个函数负责生成中间件接收器ctx，绑定一些对象的关联关系      return this.handleRequest(ctx, fn);  //使用中间件函数fn处理路由请求    };        return handleRequest;  }  //handleRequest函数的源码实现也很简单，执行中间件函数，并做一些返回处理和异常处理  function handleRequest(ctx, fnMiddleware) {        const res = ctx.res;    res.statusCode = 404;        const onerror = err =&gt; ctx.onerror(err);        const handleResponse = () =&gt; respond(ctx);    onFinished(res, onerror);        return fnMiddleware(ctx).then(handleResponse).catch(onerror);  }</code></pre><h2 id="app-use-function"><a href="#app-use-function" class="headerlink" title="app.use(function)"></a>app.use(function)</h2><p>use函数主要作用是给app.middleware数组中添加中间件</p><h2 id="app-keys"><a href="#app-keys" class="headerlink" title="app.keys="></a>app.keys=</h2><p>该密钥会被传递给KeyGrip, 当然，您也可以自己生成 KeyGrip. 例如:</p><pre><code class="js">app.keys = [&#39;im a newer secret&#39;, &#39;i like turtle&#39;];app.keys = new KeyGrip([&#39;im a newer secret&#39;, &#39;i like turtle&#39;], &#39;sha256&#39;);</code></pre><p>在进行cookie签名时，只有设置 signed 为 true 的时候，才会使用密钥进行加密：</p><pre><code class="js">ctx.cookies.set(&#39;name&#39;, &#39;tobi&#39;, { signed: true });</code></pre><h2 id="app-context"><a href="#app-context" class="headerlink" title="app.context"></a>app.context</h2><p>app.context是从中创建ctx的原型。 可以通过编辑app.context向ctx添加其他属性。当需要将ctx添加到整个应用程序中使用的属性或方法时，这将会非常有用。这可能会更加有效（不需要中间件）和/或更简单（更少的require()），而不必担心更多的依赖于ctx，这可以被看作是一种反向模式。</p><p>例如，从ctx中添加对数据库的引用：</p><pre><code class="js">app.context.db = db();app.use(async ctx =&gt; {  console.log(ctx.db);});</code></pre><blockquote><p>ctx上的很多属性是被限制的，在app.context只能通过使用Object.defineProperty()来编辑这些属性（不推荐）。可以在 <a href="https://github.com/koajs/koa/issues/652上查阅" target="_blank" rel="noopener">https://github.com/koajs/koa/issues/652上查阅</a><br>已安装的APP沿用父级的ctx和配置。因此，安装的应用程序只是一组中间件。</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>默认情况下Koa会将所有错误信息输出到 stderr， 除非 app.silent 是 true.当err.status是404或者err.expose时，默认错误处理程序也不会输出错误。要执行自定义错误处理逻辑，如集中式日志记录，您可以添加一个”错误”事件侦听器：</p><pre><code class="js">app.on(&#39;error&#39;, err =&gt; {  log.error(&#39;server error&#39;, err)});</code></pre><p>如果错误发生在 请求/响应 环节，并且其不能够响应客户端时，Contenxt 实例也会被传递到 error 事件监听器的回调函数里。</p><pre><code class="js">app.on(&#39;error&#39;, (err, ctx) =&gt; {  log.error(&#39;server error&#39;, err, ctx)});</code></pre><p>当发生错误但仍能够响应客户端时（比如没有数据写到socket中），Koa会返回一个500错误(Internal Server Error)。 无论哪种情况，Koa都会生成一个应用级别的错误信息，以便实现日志记录等目的。</p><h1 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context(上下文)"></a>Context(上下文)</h1><p>在每个<code>requset</code>请求中被创建，在中间件中作为接收器(receiver)来引用</p><pre><code class="js">app.use(async ctx =&gt; {  ctx; // is the Context  ctx.request; // is a koa Request  ctx.response; // is a koa Response});</code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>Context 详细的方法和访问器。</p><h3 id="ctx-req"><a href="#ctx-req" class="headerlink" title="ctx.req"></a>ctx.req</h3><p><strong>Node</strong> 的 request 对象。</p><h3 id="ctx-res"><a href="#ctx-res" class="headerlink" title="ctx.res"></a>ctx.res</h3><p><strong>Node</strong> 的 response 对象</p><blockquote><p>Koa 不支持 直接调用底层 res 进行响应处理。请避免使用以下 node 属性：<br>res.statusCode<br>res.writeHead()<br>res.write()<br>res.end()</p></blockquote><h3 id="ctx-request"><a href="#ctx-request" class="headerlink" title="ctx.request"></a>ctx.request</h3><p><strong>Koa</strong> 的 Request 对象。</p><h3 id="ctx-response"><a href="#ctx-response" class="headerlink" title="ctx.response"></a>ctx.response</h3><p><strong>Koa</strong> 的 Response 对象。</p><h3 id="ctx-state"><a href="#ctx-state" class="headerlink" title="ctx.state"></a>ctx.state</h3><p>推荐的命名空间，用于通过中间件传递信息到前端视图<code>ctx.state.user = await User.find(id);</code></p><h3 id="ctx-app"><a href="#ctx-app" class="headerlink" title="ctx.app"></a>ctx.app</h3><p>应用实例引用。</p><h3 id="ctx-cookies-get-name-options"><a href="#ctx-cookies-get-name-options" class="headerlink" title="ctx.cookies.get(name, [options])"></a>ctx.cookies.get(name, [options])</h3><p>获得 <strong>cookie</strong> 中名为 <strong>name</strong> 的值，options 为可选参数;signed 如果为 true，表示请求时 cookie 需要进行签名。</p><blockquote><p>注意：Koa 使用了 Express 的 cookies 模块，options 参数只是简单地直接进行传递。</p></blockquote><h3 id="ctx-cookies-set-name-value-options"><a href="#ctx-cookies-set-name-value-options" class="headerlink" title="ctx.cookies.set(name, value, [options])"></a>ctx.cookies.set(name, value, [options])</h3><p>设置 cookie 中名为 name 的值，options 为可选参数：</p><ul><li>maxAge 一个数字，表示 Date.now()到期的毫秒数</li><li>signed 是否要做签名</li><li>expires cookie有效期</li><li>pathcookie 的路径，默认为 ‘/‘</li><li>domain cookie 的域</li><li>secure false 表示 cookie 通过 HTTP 协议发送，true 表示 cookie 通过 HTTPS 发送。</li><li>httpOnly true 表示 cookie 只能通过 HTTP 协议发送</li><li>overwrite 一个布尔值，表示是否覆盖以前设置的同名的Cookie（默认为false）。 如果为true，在设置此cookie时，将在同一请求中使用相同名称（不管路径或域）设置的所有Cookie将从Set-Cookie头部中过滤掉。</li></ul><h3 id="ctx-throw-status-msg-properties"><a href="#ctx-throw-status-msg-properties" class="headerlink" title="ctx.throw([status], [msg], [properties])"></a>ctx.throw([status], [msg], [properties])</h3><p>抛出包含 .status 属性的错误，默认为 500。该方法可以让 Koa 准确的响应处理状态。 Koa支持以下组合： </p><pre><code class="js">ctx.throw(400);ctx.throw(400, &#39;name required&#39;);ctx.throw(400, &#39;name required&#39;, { user: user });//该对象被合并到错误中，这对装饰机器友好错误非常有用，并且这些错误会被报给上层请求。</code></pre><p>this.throw(‘name required’, 400) 等价于：</p><pre><code class="js">const err = new Error(&#39;name required&#39;);err.status = 400;err.expose = true;throw err;</code></pre><blockquote><p>注意：这些用户级错误被标记为 err.expose，其意味着这些消息被准确描述为对客户端的响应，而并非使用在您不想泄露失败细节的场景中。</p></blockquote><h3 id="ctx-assert-value-status-msg-properties"><a href="#ctx-assert-value-status-msg-properties" class="headerlink" title="ctx.assert(value, [status], [msg], [properties])"></a>ctx.assert(value, [status], [msg], [properties])</h3><p>当!value时， Helper 方法抛出一个类似.throw()的错误。 类似node’s assert() 方法。 </p><pre><code class="js">ctx.assert(ctx.state.user, 401, &#39;User not found. Please login!&#39;);</code></pre><p>koa 使用 <a href="https://github.com/jshttp/http-assert" target="_blank" rel="noopener">http-assert</a> 来<a href="https://www.runoob.com/w3cnote/c-assert.html" target="_blank" rel="noopener">断言</a>。</p><h3 id="ctx-respond"><a href="#ctx-respond" class="headerlink" title="ctx.respond"></a>ctx.respond</h3><p>为了避免使用 Koa 的内置响应处理功能，您可以直接赋值 this.repond = false;。如果您不想让 Koa 来帮助您处理 reponse，而是直接操作原生 res 对象，那么请使用这种方法。</p><blockquote><p>注意： 这种方式是不被 Koa 支持的。其可能会破坏 Koa 中间件和 Koa 本身的一些功能。其只作为一种 hack 的方式，并只对那些想要在 Koa 方法和中间件中使用传统 fn(req, res) 方法的人来说会带来便利。</p></blockquote><h3 id="Request-aliases"><a href="#Request-aliases" class="headerlink" title="Request aliases"></a>Request aliases</h3><p>ctx会代理ctx.response和ctx.request上的一些属性和函数(这个代理逻辑是在ctx.response和ctx.request的原型上实现的)</p><pre><code class="js">//以下是koa源码（method表示代理方法，access表示代理属性可读可写，getter表示代理属性可读）：delegate(proto, &#39;response&#39;)  .method(&#39;attachment&#39;) //将Content-Disposition 设置为 “附件” 以指示客户端提示下载  .method(&#39;redirect&#39;) //返回重定向，如果没有code设置，默认设置code为302  /*    // 字符串 &quot;back&quot; 是一个特殊参数，其提供了 Referrer 支持。当没有Referrer时，使用 alt 或者 / 代替。    ctx.redirect(&#39;back&#39;);    ctx.redirect(&#39;back&#39;, &#39;/index.html&#39;);    ctx.redirect(&#39;/login&#39;);    ctx.redirect(&#39;http://google.com&#39;);  */  .method(&#39;remove&#39;)   //删除响应头的某个属性  .method(&#39;vary&#39;)  //设置Vary响应头  .method(&#39;set&#39;) //设置响应头，可以传递对象，数组，单个值的形式  .method(&#39;append&#39;) //给response.headers中的某个key值追加其它value  .method(&#39;flushHeaders&#39;)  //执行this.res.flushHeaders()  .access(&#39;status&#39;)  //http返回code码，优先选择用户的设置，如果用户没有主动设置，而设置了ctx.body的值， 如果设置值为null，则返回204，如果设置值不为null，那么返回200，否则默认情况下是404  .access(&#39;message&#39;)  //获取响应的状态消息. 默认情况下, response.message 与 response.status 关联  .access(&#39;body&#39;)   //response的返回结果  .access(&#39;length&#39;)  //response的headers的Content-Length，可以自己设置，默认根据body二进制大小设置  .access(&#39;type&#39;)   //设置响应的content-type  .access(&#39;lastModified&#39;)  //设置响应头Last-Modified  .access(&#39;etag&#39;)  //设置包含 &quot; 包裹的 ETag 响应头  .getter(&#39;headerSent&#39;)  //检查是否已经发送了一个响应头。 用于查看客户端是否可能会收到错误通知  .getter(&#39;writable&#39;);   //返回是否可以继续写入delegate(proto, &#39;request&#39;)  .method(&#39;acceptsLanguages&#39;)  .method(&#39;acceptsEncodings&#39;)  .method(&#39;acceptsCharsets&#39;)  .method(&#39;accepts&#39;)        //accepts函数用于判断客户端请求是否接受某种返回类型  .method(&#39;get&#39;)   //获取请求头中的某个属性值  .method(&#39;is&#39;)  //判断请求头希望返回什么类型  /*    检查请求所包含的 &quot;Content-Type&quot; 是否为给定的 type 值。 如果没有 request body，返回 undefined。 如果没有 content type，或者匹配失败，返回 false。 否则返回匹配的 content-type。    // With Content-Type: text/html; charset=utf-8    ctx.is(&#39;html&#39;); // =&gt; &#39;html&#39;    ctx.is(&#39;text/html&#39;); // =&gt; &#39;text/html&#39;    ctx.is(&#39;text/*&#39;, &#39;text/html&#39;); // =&gt; &#39;text/html&#39;    // When Content-Type is application/json    ctx.is(&#39;json&#39;, &#39;urlencoded&#39;); // =&gt; &#39;json&#39;    ctx.is(&#39;application/json&#39;); // =&gt; &#39;application/json&#39;    ctx.is(&#39;html&#39;, &#39;application/*&#39;); // =&gt; &#39;application/json&#39;    ctx.is(&#39;html&#39;); // =&gt; false    //比如说您希望保证只有图片发送给指定路由    if (ctx.is(&#39;image/*&#39;)) {      // process    } else {      ctx.throw(415, &#39;images only!&#39;);    }  */  .access(&#39;querystring&#39;) //获取原始查询字符串  .access(&#39;idempotent&#39;)  .access(&#39;socket&#39;) //返回请求套接字  .access(&#39;search&#39;) //搜索字符串  .access(&#39;method&#39;)  //请求方法  .access(&#39;query&#39;)  //获取请求的查询字符串对象  .access(&#39;path&#39;)  //获取请求路径名  .access(&#39;url&#39;)  //请求的url,该url可以被重写  .getter(&#39;origin&#39;)  //获取url的来源：包括 protocol 和 host（http://example.com）  .getter(&#39;href&#39;) //获取完整的请求URL，包括 protocol，host 和 url（http://example.com/foo/bar?q=1）  .getter(&#39;subdomains&#39;) //以数组形式返回子域名    /* 举例来说，如果域名是 &quot;tobi.ferrets.example.com&quot;:    如果没有设置 app.subdomainOffset，其 subdomains 为 [&quot;ferrets&quot;, &quot;tobi&quot;]。 如果设置 app.subdomainOffset 为3，其 subdomains 为 [&quot;tobi&quot;]  */  .getter(&#39;protocol&#39;) //返回请求协议  .getter(&#39;host&#39;) //获取当前主机的host(hostname:port)  .getter(&#39;hostname&#39;) //获取当前主机的host  .getter(&#39;URL&#39;) //获取 WHATWG 解析的 URL 对象  .getter(&#39;header&#39;) //返回请求头对象  .getter(&#39;headers&#39;)  //返回请求头对象  .getter(&#39;secure&#39;) //通过 ctx.protocol == &quot;https&quot; 来检查请求是否通过 TLS 发出  .getter(&#39;stale&#39;)   .getter(&#39;fresh&#39;) //检查请求缓存是否 &quot;fresh&quot;(内容没有发生变化)。该方法用于在 If-None-Match / ETag, If-Modified-Since 和 Last-Modified 中进行缓存协调。当在 response headers 中设置一个或多个上述参数后，该方法应该被使用。  .getter(&#39;ips&#39;)  //当 X-Forwarded-For 存在并且 app.proxy 被启用时，这些 ips 的数组被返回  .getter(&#39;ip&#39;); //请求远程地址//比如以下操作是等价的：ctx.body = {  code: 200,  result: {      nick: &quot;zhangdianpeng&quot;  }}ctx.response.body = {    code: 200,    result: {        nick: &quot;zhangdianpeng&quot;    }}console.log(&#39;ctx.method:&#39;, ctx.method);console.log(&#39;ctx.request.method:&#39;, ctx.request.method);/*作者：网易云社区链接：https://www.jianshu.com/p/20cf1c476d22来源：简书改进：RainSun*/</code></pre><h1 id="使用Make构建网站"><a href="#使用Make构建网站" class="headerlink" title="使用Make构建网站"></a>使用Make构建网站</h1><p><a href="http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html" target="_blank" rel="noopener">阮一峰教程</a></p>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>koa</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>Web后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b安装aria2</title>
    <link href="undefined2020/04/pi-aria2/"/>
    <url>2020/04/pi-aria2/</url>
    
    <content type="html"><![CDATA[<h1 id="aria2"><a href="#aria2" class="headerlink" title="aria2"></a>aria2</h1><h2 id="安装aria2"><a href="#安装aria2" class="headerlink" title="安装aria2"></a>安装<code>aria2</code></h2><pre><code>sudo apt-get install aria2</code></pre><h2 id="配置aria2的文件"><a href="#配置aria2的文件" class="headerlink" title="配置aria2的文件"></a>配置<code>aria2</code>的文件</h2><pre><code>mkdir ~/.aria2touch ~/.aria2/aria2.sessionmkdir /home/pi/data/aria2mkdir /home/pi/data/aria2/downloadnano ~/.aria2/aria2.conf</code></pre><p><code>conf</code>文件里边写</p><pre><code>dir=/home/pi/data/aria2/downloaddisable-ipv6=trueenable-rpc=truerpc-allow-origin-all=truerpc-listen-all=truecontinue=trueinput-file=/home/pi/.aria2/aria2.sessionsave-session=/home/pi/.aria2/aria2.session max-concurrent-downloads=5save-session-interval=60peer-id-prefix=-TR2770-user-agent=Transmission/2.77bt-seed-unverified=truebt-save-metadata=true</code></pre><p>测试运行看看有没有错误</p><pre><code>aria2c –conf-path=/home/pi/.aria2/aria2.conf</code></pre><p>把它做成系统服务</p><pre><code>sudo nano /etc/init.d/aria2c</code></pre><p>输入</p><pre><code>#!/bin/sh### BEGIN INIT INFO# Provides:          aria2# Required-Start:    $remote_fs $network# Required-Stop:     $remote_fs $network# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: Aria2 Downloader### END INIT INFOcase &quot;$1&quot; instart)echo -n &quot;Starting aria2c&quot;sudo -u pi aria2c --conf-path=/home/pi/.aria2/aria2.conf -D;;stop)echo -n &quot;Shutting down aria2c &quot;killall aria2c;;restart)killall aria2csudo -u pi aria2c --conf-path=/home/pi/.aria2/aria2.conf -D;;esacexit</code></pre><h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><pre><code>sudo chmod 755 /etc/init.d/aria2c</code></pre><h2 id="测试服务是否能启动"><a href="#测试服务是否能启动" class="headerlink" title="测试服务是否能启动"></a>测试服务是否能启动</h2><pre><code>sudo service aria2c start</code></pre><p>报错就再输入一句</p><pre><code>sudo update-rc.d aria2c defaults</code></pre><h2 id="添加aria2c服务自动运行"><a href="#添加aria2c服务自动运行" class="headerlink" title="添加aria2c服务自动运行"></a>添加aria2c服务自动运行</h2><pre><code>sudo update-rc.d aria2c defaults</code></pre><h2 id="进文件夹下载yaaw"><a href="#进文件夹下载yaaw" class="headerlink" title="进文件夹下载yaaw"></a>进文件夹下载yaaw</h2><pre><code>cd data/aria2git clone http://github.com/wzhy90/yaaw</code></pre><p>之后就在teaweb里边设置代理就ok</p>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>aria2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>aria2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记</title>
    <link href="undefined2020/04/docker/"/>
    <url>2020/04/docker/</url>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><p>查看全部网桥</p><pre><code>docker network ls</code></pre><p>查看某个网桥</p><pre><code>docker network inspect &lt;name&gt;</code></pre><p>创建一个名为<code>lacus</code>的网桥</p><pre><code>docker network create --driver bridge lacus</code></pre><p>允许指定网段 上一句指定参数在名之前</p><pre><code>--subnet 172.22.16.0/24 --gateway 172.22.16.1</code></pre><p>删除<code>lacus</code>网桥</p><pre><code>docker network rm lacus</code></pre><p>连接到<code>lacus</code>网桥</p><pre><code>--network=lacus</code></pre><hr><h2 id="容器间通信的三种方式"><a href="#容器间通信的三种方式" class="headerlink" title="容器间通信的三种方式"></a>容器间通信的三种方式</h2><p><strong>IP通信</strong></p><p>只要放在了一个网桥下就可以通过ip进行访问了</p><p><strong>Docker DNS Server</strong></p><p>docker内嵌了DNS Server，只要使用<code>--name=&lt;name&gt;</code>指定容器名并且绑定在一个网桥中就可以使用名字<code>ping -c 3 name</code>连通</p><blockquote><p>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。</p></blockquote><p><strong>joined 容器</strong></p><p>通过<code>--network=container:&lt;name&gt;</code>指定<code>jointed</code>容器</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p><strong>运行portainer</strong></p><pre><code>docker run -d -p 127.0.0.1:5001:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer  portainer/portainer</code></pre><p><strong>运行mongodb</strong></p><pre><code>// pidocker run -d --name mongo -v /home/pi/db/mongo:/data/db -p 27017:27017 --restart=always --network=lacus casualsimulation/rpi-mongodb3 mongod --auth// aldocker run -d --name mongo -v /root/db/mongo:/data/db -p 127.0.0.1:5000:27017 --restart=always --network=lacus mongo mongod --auth</code></pre><p><strong>打包</strong></p><pre><code>// al tracer_backenddocker build -t lacus/tracer_backend:1.0 .// al tracer_userdocker build -t lacus/tracer_user:1.0 .// al tracer_admindocker build -t lacus/tracer_admin:1.0 .// al canary_backenddocker build -t lacus/canary_backend:1.0 .// al canary_frontenddocker build -t lacus/canary_frontend:1.0 .// al cherry_backenddocker build -t lacus/cherry_backend:1.0 .// al cherry_frontenddocker build -t lacus/cherry_frontend:1.0 .</code></pre><p><strong>运行</strong></p><pre><code>// al tracer_backenddocker run -it --name tracer_backend -v /root/data/tracer/backEnd/logs:/app/logs -v /root/data/tracer/backEnd/upload:/app/upload -p 127.0.0.1:5002:80 --network=lacus lacus/tracer_backend:1.0 /bin/sh// al tracer_userdocker run -d --name tracer_user -p 127.0.0.1:5003:80 --restart=always --network=lacus lacus/tracer_user:1.0// al tracer_admindocker run -d --name tracer_admin -p 127.0.0.1:5004:80 --restart=always --network=lacus lacus/tracer_admin:1.0// al canary_backenddocker run -it --name canary_backend -v /root/data/canary/backEnd/logs:/app/logs -p 127.0.0.1:5005:80 --network=lacus lacus/canary_backend:1.0 /bin/sh// al canary_frontenddocker run -d --name canary_frontend -p 127.0.0.1:5006:80 --restart=always --network=lacus lacus/canary_frontend:1.0// al cherry_backenddocker run -it --name cherry_backend -v /root/data/cherry/backEnd/logs:/app/logs -p 127.0.0.1:5007:80 --network=lacus lacus/cherry_backend:1.0 /bin/sh// al cherry_frontenddocker run -d --name cherry_frontend -p 127.0.0.1:5008:80 --restart=always --network=lacus lacus/cherry_frontend:1.0// pi ccb frontEnddocker run -d --name ccb_frontend -p 127.0.0.1:5003:80 --restart=always --network=lacus lacus/ccb_frontend:1.0// pi ccb backEnddocker run -it --name ccb -v /home/pi/data/ccb/docker/logs:/app/logs -p 127.0.0.1:5002:80 --restart=always --network=lacus lacus/ccb_backend:1.0 /bin/sh// vueview docker run  -d --name canary_frontEnd -p 127.0.0.1:5006:80 --restart=always -v /root/data/canary/frontEnd:/vue lacus/vueview // flask_env docker run -it --name phonebook_backend -p 127.0.0.1:5011:80 -v /root/data/phonebook/backEnd:/app --network=lacus lacus/flask_env /bin/sh // blog docker run -d --name blog -v /root/data/blog/blog:/usr/share/nginx/html -p 127.0.0.1:5019:80 --network=lacus lacus/blog:1.0</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云服务器初始化</title>
    <link href="undefined2020/03/init-centos/"/>
    <url>2020/03/init-centos/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h1><p>因为是阿里的服务器，装的centos8，已经自己换好阿里的镜像源了，很nice<br>更新<code>yum</code></p><pre><code>sudo yum -y update</code></pre><p>Todo</p><ol><li><input checked="" disabled="" type="checkbox"> nginx</li><li><input checked="" disabled="" type="checkbox"> mongodb </li><li><input checked="" disabled="" type="checkbox"> docker</li><li><input checked="" disabled="" type="checkbox"> htop<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2>使用<code>yum</code>安装<pre><code>sudo yum -y install nginx   # 安装 nginxsudo yum remove nginx  # 卸载 nginx</code></pre>配置<code>nginx</code>服务<pre><code>sudo systemctl enable nginx # 设置开机启动sudo service nginx start # 启动nginx服务sudo service nginx stop # 停止nginx服务sudo service nginx restart # 重启nginx服务sudo service nginx reload # 重新加载配置，一般是在修改过nginx配置文件时使用</code></pre><h2 id="安装htop"><a href="#安装htop" class="headerlink" title="安装htop"></a>安装htop</h2>使用<code>yum</code>安装<pre><code>yum install epel-release -yyum install htop -y</code></pre><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">网页链接</a><br>如果报错<code>package docker-ce-3:19.03.8-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of the providers can be installed</code><br>就执行以下命令<pre><code>dnf install https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpmsudo yum install docker-ce docker-ce-clisudo systemctl start docker</code></pre><h2 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h2>使用<code>docker</code>安装<pre><code>docker run -d --name mongo -v /root/db/mongo:/data/db -p 127.0.0.1:5000:27017 --network=lacus mongo mongod --auth</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>部署新服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongoDB学习笔记</title>
    <link href="undefined2019/11/mongodb/"/>
    <url>2019/11/mongodb/</url>
    
    <content type="html"><![CDATA[<h1 id="mongoDB"><a href="#mongoDB" class="headerlink" title="mongoDB"></a>mongoDB</h1><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><pre><code class="js">db.createUser(  {    user: &quot;yingbo&quot;,    pwd: &quot;&quot;,    roles: [ { role: &quot;dbAdmin&quot;, db: &quot;yingbo&quot; },{ role: &#39;readWrite&#39;, db: &quot;yingbo&quot;} ]  })db.createUser(  {    user: &quot;admin&quot;,    pwd: &quot;&quot;,    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; } ]  })</code></pre><h3 id="log目录-var-log-mongodb-mongod-log"><a href="#log目录-var-log-mongodb-mongod-log" class="headerlink" title="log目录 /var/log/mongodb/mongod.log"></a>log目录 <code>/var/log/mongodb/mongod.log</code></h3><h3 id="db目录-var-lib-mongo"><a href="#db目录-var-lib-mongo" class="headerlink" title="db目录 /var/lib/mongo"></a>db目录 <code>/var/lib/mongo</code></h3><h3 id="配置文件-etc-mongod-conf"><a href="#配置文件-etc-mongod-conf" class="headerlink" title="配置文件 /etc/mongod.conf"></a>配置文件 <code>/etc/mongod.conf</code></h3><h3 id="启动-重启-停止-sudo-service-mongod-start-restart-stop"><a href="#启动-重启-停止-sudo-service-mongod-start-restart-stop" class="headerlink" title="启动/重启/停止  sudo service mongod start/restart/stop"></a>启动/重启/停止  <code>sudo service mongod start/restart/stop</code></h3><h3 id="开启用户认证-conf-文件加"><a href="#开启用户认证-conf-文件加" class="headerlink" title="开启用户认证 conf 文件加"></a>开启用户认证 conf 文件加</h3><pre><code>security:  authorization: enabled</code></pre><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><pre><code class="c">//方法一mongo --port 12236 -u &quot;admin&quot; -p &quot;&quot; --authenticationDatabase &quot;admin&quot;//方法二db.auth(&quot;yingbo&quot;, &quot;&quot;)</code></pre><h3 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h3><p><code>show dbs</code></p><h3 id="删库"><a href="#删库" class="headerlink" title="删库"></a>删库</h3><pre><code>use &lt;dbname&gt;db.dropDatabase()</code></pre><h3 id="显示所有集合"><a href="#显示所有集合" class="headerlink" title="显示所有集合"></a>显示所有集合</h3><p><code>show tables</code> 或者 <code>show collections</code></p><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><pre><code class="js">//正常情况下直接插入数据就可以自动新建一个集合//创建固定集合 mycol，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。db.createCollection(&quot;&lt;collectionName&gt;&quot;, { capped : true, autoIndexId : true, size :    6142800, max : 10000 } )//单纯的新建一个集合db.createCollection(&quot;&lt;collectionName&gt;&quot;)</code></pre><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><p><code>db.&lt;collectionName&gt;.drop()</code></p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><code>db.&lt;collectionName&gt;.insert(&lt;object&gt;)</code></p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><code>db.&lt;collectionName&gt;.remove({key:value})</code> find里边可以为{}删除全部</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code>db.&lt;collectionName&gt;.update(   &lt;query&gt;,   &lt;update&gt;,   {     upsert: &lt;boolean&gt;,     multi: &lt;boolean&gt;,     writeConcern: &lt;document&gt;   })/*    query : update的查询条件，类似sql update查询内where后面的。    update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set后面的    upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。    multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。    writeConcern :可选，抛出异常的级别。*/</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><code>db.&lt;collectionName&gt;.find({key:value})</code> find里边可以没有参数</p><pre><code>//格式化显示db.col.find().pretty()//条件语句db.col.find({likes : {$lt :200, $gt : 100}}).pretty() //限制 100&lt;likes&lt;200$lt:小于$lte:小于或等于$gt:大于$gte:大于或等于$ne: 不等于$type:     Double     1          String     2          Object     3          Array     4          Binary data     5          Undefined     6     已废弃。    Object id     7          Boolean     8          Date     9          Null     10          Regular Expression     11          JavaScript     13          Symbol     14          JavaScript (with scope)     15          32-bit integer     16          Timestamp     17          64-bit integer     18          Min key     255     Query with -1.    Max key     127//ANDdb.col.find({key1:value1, key2:value2}).pretty()//ORdb.col.find({$or:[{&quot;by&quot;:&quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()//AND+ORdb.col.find({&quot;likes&quot;: {$gt:50}, $or: [{&quot;by&quot;: &quot;菜鸟教程&quot;},{&quot;title&quot;: &quot;MongoDB 教程&quot;}]}).pretty()// 排除某个字段，例如_iddb.col.find({},{&quot;_id&quot;: 0})// 指定返回某几个字段db.col.find({},{&quot;name&quot;: 1, &quot;sex&quot;: 1})</code></pre><hr><h2 id="Limit与Skip方法"><a href="#Limit与Skip方法" class="headerlink" title="Limit与Skip方法"></a>Limit与Skip方法</h2><p><code>db.&lt;collectionName&gt;.find().limit(&lt;number1&gt;).skip(&lt;number2&gt;)</code></p><p>number1 : 本次查询最多显示条数</p><p>number2 : 本次查询跳过的条数</p><hr><h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort() 方法"></a>sort() 方法</h2><p><code>db.&lt;collectionName&gt;.find().sort({&lt;key&gt;:&lt;number&gt;})</code></p><p>key : 需要进行排序的键名</p><p>number : 其中 1 为升序排列，而 -1 是用于降序排列</p><hr><h2 id="createIndex-方法"><a href="#createIndex-方法" class="headerlink" title="createIndex() 方法"></a>createIndex() 方法</h2><p><code>db.values.createIndex({&lt;key&gt;: &lt;number&gt;, &lt;key&gt;: &lt;number&gt;}, {background: true})</code></p><p>key : 需要进行排序的键名</p><p>number : 其中 1 为升序排列，而 -1 是用于降序排列</p><p>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。</p><hr><h2 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h2><pre><code>db.mycol.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}]){   &quot;result&quot; : [      {         &quot;_id&quot; : &quot;runoob.com&quot;,         &quot;num_tutorial&quot; : 2      },      {         &quot;_id&quot; : &quot;Neo4j&quot;,         &quot;num_tutorial&quot; : 1      }   ],   &quot;ok&quot; : 1}</code></pre><p>$sum    计算总和。    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])</p><p>$avg    计算平均值    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])</p><p>$min    获取集合中所有文档对应值得最小值。    db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])</p><p>$max    获取集合中所有文档对应值得最大值。    db.mycol.aggregate([{$group : {_id :<br>“$by_user”, num_tutorial : {$max : “$likes”}}}])</p><p>$push    在结果文档中插入值到一个数组中。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])</p><p>$addToSet    在结果文档中插入值到一个数组中，但不创建副本。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])</p><p>$first    根据资源文档的排序获取第一个文档数据。    db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])</p><p>$last    根据资源文档的排序获取最后一个文档数据    db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>$project：修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档。</p><pre><code>结果中就只还有_id,tilte和author三个字段db.article.aggregate(    { $project : {        title : 1 ,        author : 1 ,    }} );连id一起删除db.article.aggregate(    { $project : {        _id : 0 ,        title : 1 ,        author : 1    }});</code></pre><p>$match：用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作。</p><pre><code>db.articles.aggregate( [  { $match : { score : { $gt : 70, $lte : 90 } } },  { $group: { _id: null, count: { $sum: 1 } } }] );</code></pre><p>$limit：用来限制MongoDB聚合管道返回的文档数。</p><p>$skip：在聚合管道中跳过指定数量的文档，并返回余下的文档。</p><pre><code>db.article.aggregate(    { $skip : 5 });</code></pre><p>$unwind：将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值。</p><p>$group：将集合中的文档分组，可用于统计结果。</p><p>$sort：将输入文档排序后输出。</p><p>$geoNear：输出接近某一地理位置的有序文档。</p><hr><h2 id="MongoDB-复制（副本集）"><a href="#MongoDB-复制（副本集）" class="headerlink" title="MongoDB 复制（副本集）"></a>MongoDB 复制（副本集）</h2><p>等树莓派装完再看</p><h2 id="MongoDB-分片"><a href="#MongoDB-分片" class="headerlink" title="MongoDB 分片"></a>MongoDB 分片</h2><p>等树莓派装完再看</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p><code>mongodump -h dbhost -d dbname -o dbdirectory</code></p><p>-h：<br>MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017</p><p>-d：<br>需要备份的数据库实例，例如：test</p><p>-o：<br>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。 </p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p><code>mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;</code></p><pre><code>--host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址，默认为： localhost:27017--db , -d ：需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2--drop：恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！&lt;path&gt;：mongorestore 最后的一个参数，设置备份数据所在位置，例如：c:\data\dump\test。你不能同时指定 &lt;path&gt; 和 --dir 选项，--dir也可以设置备份目录。--dir：指定备份的目录你不能同时指定 &lt;path&gt; 和 --dir 选项。</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>mongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>mongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b更换国内软件源</title>
    <link href="undefined2019/11/pi-origin/"/>
    <url>2019/11/pi-origin/</url>
    
    <content type="html"><![CDATA[<h1 id="更换软件源"><a href="#更换软件源" class="headerlink" title="更换软件源"></a>更换软件源</h1><h2 id="切换到root用户"><a href="#切换到root用户" class="headerlink" title="切换到root用户"></a>切换到root用户</h2><p><code>su - root</code></p><h2 id="修改-etc-apt-sources-list"><a href="#修改-etc-apt-sources-list" class="headerlink" title="修改 /etc/apt/sources.list"></a>修改 /etc/apt/sources.list</h2><p><code>sudo nano /etc/apt/sources.list</code></p><pre><code>原文`deb http://mirrordirector.raspbian.org/raspbian/ stretch main contrib non-free rpi` 加#注释掉加入如下阿里源，`deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi`</code></pre><h2 id="修改-etc-apt-sources-list-d-raspi-list"><a href="#修改-etc-apt-sources-list-d-raspi-list" class="headerlink" title="修改/etc/apt/sources.list.d/raspi.list"></a>修改/etc/apt/sources.list.d/raspi.list</h2><p><code>sudo nano /etc/apt/sources.list.d/raspi.list</code></p><pre><code>原文`deb http://archive.raspberrypi.org/debian/ stretch main ui，` 加#加入如下科大源：`deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui`</code></pre><h2 id="更新系统和软件"><a href="#更新系统和软件" class="headerlink" title="更新系统和软件"></a>更新系统和软件</h2><p><code>sudo apt-get update</code></p><pre><code>`sudo apt-get upgrade`</code></pre>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>软件源</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>软件源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b部署ngrok</title>
    <link href="undefined2019/11/pi-ngrok/"/>
    <url>2019/11/pi-ngrok/</url>
    
    <content type="html"><![CDATA[<h1 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h1><p>先去<a href="http://www.ngrok.cc/" target="_blank" rel="noopener">sunny ngrok</a>买个id</p><p>下载<br><code>wget &#39;hls.ctopus.com/sunny/linux_arm.zip?v=2&#39;</code></p><p>重命名<br><code>mv linux_arm.zip?v=2 linux_arm.zip</code></p><p>解压缩<br><code>unzip linux_arm.zip</code></p><p>切文件夹<br><code>cd linux_arm</code></p><p>启动！<br><code>./sunny clientid &lt;your-clientid&gt;</code></p><p>后台运行<br><code>setsid ./sunny clientid &lt;your-clientid&gt; &amp;</code></p><p>移动到 /use/local/bin 目录下并给予可执行权限</p><pre><code>sudo mv sunny /usr/local/bin/sunnysudo chmod +x /usr/local/bin/sunny</code></pre><p>编写启动脚本<br><code>sudo vim /etc/init.d/sunny</code></p><p>内容</p><pre><code>#!/bin/sh -e### BEGIN INIT INFO# Provides:          ngrok.cc# Required-Start:    $network $remote_fs $local_fs# Required-Stop:     $network $remote_fs $local_fs# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: autostartup of ngrok for Linux### END INIT INFONAME=sunnyDAEMON=/usr/local/bin/$NAMEPIDFILE=/var/run/$NAME.pid[ -x &quot;$DAEMON&quot; ] || exit 0case &quot;$1&quot; in  start)      if [ -f $PIDFILE ]; then        echo &quot;$NAME already running...&quot;        echo -e &quot;\033[1;35mStart Fail\033[0m&quot;      else        echo &quot;Starting $NAME...&quot;        start-stop-daemon -S -p $PIDFILE -m -b -o -q -x $DAEMON -- clientid &lt;your-clientid&gt; || return 2        echo -e &quot;\033[1;32mStart Success\033[0m&quot;    fi    ;;  stop)        echo &quot;Stoping $NAME...&quot;        start-stop-daemon -K -p $PIDFILE -s TERM -o -q || return 2        rm -rf $PIDFILE        echo -e &quot;\033[1;32mStop Success\033[0m&quot;    ;;  restart)    $0 stop &amp;&amp; sleep 2 &amp;&amp; $0 start    ;;  *)    echo &quot;Usage: $0 {start|stop|restart}&quot;    exit 1    ;;esacexit 0</code></pre><p>测试</p><pre><code>sudo chmod 755 /etc/init.d/sunnysudo /etc/init.d/sunny startsudo /etc/init.d/sunny start    #启动sudo /etc/init.d/sunny stop     #停止sudo /etc/init.d/sunny restart  #重启</code></pre><p>开机启动</p><pre><code>cd /etc/init.dsudo update-rc.d sunny defaults 90    #加入开机启动sudo update-rc.d -f sunny remove  #取消开机启动</code></pre>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>ngrok</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>ngrok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派3b安装gogs</title>
    <link href="undefined2019/11/pi-gogs/"/>
    <url>2019/11/pi-gogs/</url>
    
    <content type="html"><![CDATA[<h1 id="gogs"><a href="#gogs" class="headerlink" title="gogs"></a>gogs</h1><p>创建新用户git 如果不创建会导致主账号登陆不了ssh</p><p>切换为root用户为了获取创建用户的权限</p><p><code>sudo su</code></p><p>给root创建一个新的密码</p><p><code>sudo passwd root</code></p><p>添加一个新用户（如用户名为git）</p><p><code>useradd git</code></p><p>为该用户设定登录密码</p><p><code>passwd git</code></p><p>为该用户指定命令解释程序（通常为/bin/bash）</p><p><code>usermod -s /bin/bash git</code></p><p>为该用户指定用户主目录</p><p><code>usermod -d /home/git git</code></p><p>查看用户的属性</p><p><code>cat /etc/passwd</code></p><p>切换到用户git</p><p><code>su git</code></p><p>再次切换到root用户（不要用sudo su, 而用su root）</p><p><code>su root</code></p><p>执行visudo命令</p><p><code>visudo</code></p><p>该命令实际上打开的是/etc/sudoers文件，修改该文件，在“root ALL=(ALL:ALL) ALL”这一行下面加入一行：</p><p><code>git ALL=(ALL:ALL) ALL</code></p><p>ctrl+o（然后再按enter）保存，ctrl+c取消，ctrl+x退出</p><hr><p>下载<br><code>wget &#39;https://github.com/gogs/gogs/releases/download/v0.11.91/raspi_armv7.zip&#39;</code></p><p>解压<br><code>unzip raspi_armv7.zip</code></p><p>进文件夹<br><code>cd gogs</code></p><p>开启web服务<br><code>./gogs web</code></p><p>去3000端口进行设置，数据库设置成sqlite就行</p><p>在<code>/etc/systemd/system/gogs.service</code>新建文件</p><pre><code>[Unit]Description=Gogs (Go Git Service)After=syslog.targetAfter=network.target#After=mysqld.service#After=postgresql.service#After=memcached.service#After=redis.service[Service]# Modify these two values and uncomment them if you have# repos with lots of files and get an HTTP error 500 because# of that####LimitMEMLOCK=infinity#LimitNOFILE=65535Type=simpleUser=gitGroup=gitWorkingDirectory=/home/git/gogsExecStart=/home/git/gogs/gogs webRestart=alwaysEnvironment=USER=git HOME=/home/git[Install]WantedBy=multi-user.target</code></pre><p>更新 User、Group、WorkingDirectory、ExecStart 和 Environment 为相对应的值。其中 WorkingDirectory 为您的 Gogs 实际安装路径根目录。</p><p>[可选] 如果您 Gogs 安装示例使用 MySQL/MariaDB、PostgreSQL、Redis 或 memcached，请去掉相应 After 属性的注释。</p><p>然后通过 <code>sudo systemctl enable gogs</code> 命令激活，最后执行 <code>sudo systemd start gogs</code>，就可以做到开机启动了。</p><p>官方文件解释<a href="'https://gogs.io/docs/advanced/configuration_cheat_sheet'">docs</a></p><p>重启 <code>sudo systemctl restart gogs</code></p>]]></content>
    
    
    <categories>
      
      <category>树莓派3b</category>
      
      <category>gogs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派3b</tag>
      
      <tag>gogs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令总结</title>
    <link href="undefined2019/11/git/"/>
    <url>2019/11/git/</url>
    
    <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><ul><li><p>SSH <code>C:\Users\yingbo\.ssh</code></p><ul><li>创建： <code>ssh-keygen -t rsa -C &#39;邮件地址&#39;</code></li><li>测试： <code>ssh -T git@github.com</code></li><li>注意：上面创建语句完成后会让你输入密码，直接回车，不然之后提交的时候每次都会让你输入密码</li></ul></li><li><p><code>git init</code> 初始化仓库</p></li><li><p><code>git status</code> 查看仓库状态</p></li><li><p><code>git add &#39;文件名&#39;</code> 向暂存区添加文件，如果添加所有文件，’文件名’ =&gt; *</p></li><li><p><code>git commit -m &#39;text&#39;</code> </p><ul><li>提交，text为提交描述</li><li>直接 <code>git commit</code>会进入详细编辑的界面<ul><li>第一行简介</li><li>第二行空行</li><li>第三行详情</li></ul></li></ul></li><li><p><code>git log</code> 提交日志</p><ul><li>尾缀<ul><li><code>--pretty = short</code> 只显示概要</li><li><code>目录名/文件名</code> 只显示该目录或者该文件的记录</li><li><code>-P</code> 显示改动</li><li><code>-P</code> 文件名 显示该文件的改动</li></ul></li></ul></li><li><p><code>git diff</code> 查看区别</p><ul><li><code>git diff HEAD</code> 本次与上次的区别</li></ul></li><li><p><code>git branch</code> 显示所有分支</p><ul><li><code>git checkout -b name</code> 创建name分支并进入( 等同于下边两步)<ul><li>=&gt; <code>git branch name</code></li><li>=&gt; <code>git checkout name</code></li></ul></li><li><code>git checkout -</code> 切换回上一个分支</li><li>注：最好每做一件事就创建一个新的分支，保证代码无误再合并到主分支，保障主分支随时可用</li></ul></li><li><p>合并分支</p><ul><li><code>git checkout &#39;合并到的分支名&#39;</code></li><li><code>git merge --no--ff &#39;合并后消失的分支名&#39;</code></li><li><code>git log --graph</code> 图表形式提交日志</li></ul></li><li><p><code>git reset --hard &#39;哈希值&#39;</code> 回溯历史版本</p></li><li><p><code>git reflog</code> 操作日志</p></li><li><p>查看冲突并解决 git merge 后提示有冲突，此时冲突文件会被修改，进文件改成想要的样子，然后git add，git commit，done！</p></li><li><p><code>git commit --amend</code> 修改上一条的提交信息</p></li><li><p>压缩历史</p><ul><li><code>git commit -am</code> 一次性进暂存然后提交<ul><li>注：修改名称为 typo 例： fix typo</li></ul></li><li><code>git rebase -i HEAD~2</code> 合并两次最新提交</li><li>进入编辑器</li><li>pick 7a34294 Add feature-C</li><li>pick ofba227 Fix typo 将typo -&gt; fixup<br>然后保存 -&gt; ok</li></ul></li><li><p>添加远程仓库</p><ul><li><code>git remote add origin &#39;网址&#39;</code></li><li><code>git push -u origin master</code></li><li>//将当前分支推送到origin远端的master分支（master不存在的话自动新建）</li><li><code>git clone &#39;网址&#39;</code> 克隆仓库</li><li><code>git branch -a</code> 同时显示本地和远端的分支</li><li><code>git checkout -b feature-D origin/feature-D</code></li><li>//新建本地feature-D分支并把远端的feature-D同步过来</li></ul></li><li><p><code>git fetch</code> 与 <code>git pull</code> 的区别</p><ul><li>git pull = git fetch + git margin</li></ul></li><li><p>删除分支</p><ul><li><code>git branch -D &#39;分支名&#39;</code></li></ul></li><li><p>PR总结</p><pre><code>git checkout -b &lt;name&gt; //创建分支coding...git commit -m &#39;&lt;content&gt;&#39; //提交git pushd -u origin &lt;name&gt;  //推远端web -&gt; prgit branch -d &lt;name&gt;  //删除本地git push origin --delete &lt;name&gt; //删除远端</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>命令</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 命令积累</title>
    <link href="undefined2019/11/linux/"/>
    <url>2019/11/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h3 id="切换用户su-root"><a href="#切换用户su-root" class="headerlink" title="切换用户su - root"></a>切换用户<code>su - root</code></h3><ul><li><code>-</code> 的含义是携带当前环境变量</li></ul><h3 id="增加用户useradd"><a href="#增加用户useradd" class="headerlink" title="增加用户useradd"></a>增加用户<code>useradd</code></h3><ul><li><code>-g</code> 指定用户所在群组 </li><li><code>-m</code> 自动建立用户的登入目录 </li><li><code>-n</code> 取消建立和用户同名的群组</li></ul><h3 id="更改对应用户密码passwd"><a href="#更改对应用户密码passwd" class="headerlink" title="更改对应用户密码passwd"></a>更改对应用户密码<code>passwd</code></h3><h3 id="查看进程ps"><a href="#查看进程ps" class="headerlink" title="查看进程ps"></a>查看进程<code>ps</code></h3><ul><li><code>-ef</code> 查看所有进程以及其pid </li><li><code>-aux</code> 查看所有进程并显示其占用的cpu以及mem </li><li><code>-w</code> 显示加宽可以显示更多信息</li><li><code>ps -auxwww</code>加宽三次</li></ul><h3 id="停止进程kill-pid"><a href="#停止进程kill-pid" class="headerlink" title="停止进程kill (pid)"></a>停止进程<code>kill (pid)</code></h3><ul><li><code>-s</code> 发送指定信号到进程</li><li><code>-p</code> 打印出进程号，但是不发送信号</li><li><code>-l</code> 打印出所有可用信号名称</li></ul><h3 id="查看磁盘fdisk-l"><a href="#查看磁盘fdisk-l" class="headerlink" title="查看磁盘fdisk -l"></a>查看磁盘<code>fdisk -l</code></h3><ul><li>必须使用<code>root</code>权限</li></ul><h3 id="切换目录cd"><a href="#切换目录cd" class="headerlink" title="切换目录cd ../"></a>切换目录<code>cd ../</code></h3><ul><li><code>./</code>当前目录</li><li><code>../</code>上级目录</li><li><code>cd -</code>返回到上个目录</li></ul><h3 id="显示当前文件夹下的文件夹以及文件ls"><a href="#显示当前文件夹下的文件夹以及文件ls" class="headerlink" title="显示当前文件夹下的文件夹以及文件ls"></a>显示当前文件夹下的文件夹以及文件<code>ls</code></h3><ul><li><code>-l</code> 显示详细信息</li><li><code>-a -all</code> 列出所有文件包括隐藏文件</li><li><code>-d</code> 将目录名和其他文件一样列出，而不是列出目录的内容</li><li><code>-f</code> 不排序目录内容，按他们在磁盘上存储的顺序列出</li></ul><h3 id="创建一个目录mkdir"><a href="#创建一个目录mkdir" class="headerlink" title="创建一个目录mkdir"></a>创建一个目录<code>mkdir</code></h3><ul><li><code>-m</code> 对新建目录设置权限</li><li><code>-p</code> 可以是一个路径，可以一次创建多层目录</li></ul><h3 id="查看文件内容cat-文件路径"><a href="#查看文件内容cat-文件路径" class="headerlink" title="查看文件内容cat (文件路径)"></a>查看文件内容<code>cat (文件路径)</code></h3><ul><li><code>-n</code> 输出行号</li><li><code>-b</code> 输出行号，对空白行不编号</li></ul><h3 id="复制文件cp"><a href="#复制文件cp" class="headerlink" title="复制文件cp"></a>复制文件<code>cp</code></h3><ul><li><code>-a</code> 保留链接，文件属性，复制其子目录，其作用等于dpr选项的组合</li><li><code>-d</code> 拷贝时保留链接</li><li><code>-f</code> 删除已经存在的目标文件而不提示</li><li><code>-i</code> 覆盖目标文件之前给出提示要求用户确认</li><li><code>-p</code> 除了复制内容，修改时间还有访问权限也复制到新文件中</li><li><code>-r</code> 若给出的文件是一目录文件，此时将会递归复制该目录下的所有文件以及子目录，此时目标文件必须为一个目录名</li></ul><h3 id="为文件改名或者移动mv"><a href="#为文件改名或者移动mv" class="headerlink" title="为文件改名或者移动mv"></a>为文件改名或者移动<code>mv</code></h3><ul><li><code>-i</code> 若操作会导致文件被覆写，将会提示用户确认</li><li><code>-f</code> 禁止交互 会让<code>-i</code> 失效</li><li><code>mv fromfile tofile</code>如把文件a.txt得命名为b.txt，可以是mv a.txt b.txt。</li></ul><h3 id="移除目录或者文件rm"><a href="#移除目录或者文件rm" class="headerlink" title="移除目录或者文件rm"></a>移除目录或者文件<code>rm</code></h3><ul><li><code>-i</code> 进行交互式删除</li><li><code>-f</code> 不需要提示</li><li><code>-r</code> 将所有目录以及子目录递归地删除</li><li><code>-d</code> 删除空目录</li></ul><h3 id="修改文件所有者chown"><a href="#修改文件所有者chown" class="headerlink" title="修改文件所有者chown"></a>修改文件所有者<code>chown</code></h3><h3 id="修改文件所有组chgrp"><a href="#修改文件所有组chgrp" class="headerlink" title="修改文件所有组chgrp"></a>修改文件所有组<code>chgrp</code></h3><h3 id="修改文件访问权限chmod"><a href="#修改文件访问权限chmod" class="headerlink" title="修改文件访问权限chmod"></a>修改文件访问权限<code>chmod</code></h3><ul><li><code>-c</code> 若文件权限更改成功才显示</li><li><code>-f</code> 若文件无法被更改也不打印错误信息</li><li><code>-v</code> 显示权限变更详细资料</li><li>修改文件权限<a href="'https://blog.csdn.net/slwhy/article/details/78876237'">链接</a></li></ul><h3 id="在指定文件中搜索内容"><a href="#在指定文件中搜索内容" class="headerlink" title="在指定文件中搜索内容"></a>在指定文件中搜索内容</h3><ul><li><code>grep</code> 选项 格式 文件</li><li><code>-c</code> 只输出匹配的行数</li><li><code>-i</code> 不区分大小写</li><li><code>-h</code> 查询多文件不显示文件名</li><li><code>-l</code> 查询多文件只显示包含匹配字符的文件名</li><li><code>-n</code> 显示匹配行以及行号</li><li><code>-s</code> 不显示不存在或者无匹配文本的错误信息</li><li><code>-v</code> 显示不包含匹配文本的所有行</li></ul><h3 id="查找指定文件find-路径-选项-描述"><a href="#查找指定文件find-路径-选项-描述" class="headerlink" title="查找指定文件find [路径] [选项] [描述]"></a>查找指定文件<code>find [路径] [选项] [描述]</code></h3><ul><li><code>-depth</code> 使用深度级别的查找过程方式，在某层指定目录中优先查找文件内容</li><li><code>-mount</code> 不在其他文件系统的目录个文件中查找</li><li><code>-name</code> 支持通配符* 和 ?</li><li><code>-user</code> 搜索文件所属为用户名的文件</li><li><code>-print</code> 输出搜索结果并打印</li><li><code>-and</code> 把两个查找参数链接起来</li></ul><h3 id="查找文件locate"><a href="#查找文件locate" class="headerlink" title="查找文件locate"></a>查找文件<code>locate</code></h3><ul><li>先建立一个所有文件名以及路径的数据库所以比find快</li><li><code>-u</code> 从根目录开始建立数据库</li><li><code>-U</code> 从指定位置开始建立数据库</li><li><code>-f</code> 将特定的文件系统排除在数据库外</li><li><code>-r</code> 使用正则表达式做寻找的条件</li><li><code>-o</code> 指定数据库的名成</li><li>创建后会在crontab中每天已更新</li><li>使用updatedb强制更新</li></ul><h3 id="创建链接ln-s-genromfs-0-5-1-tar-gz-hello"><a href="#创建链接ln-s-genromfs-0-5-1-tar-gz-hello" class="headerlink" title="创建链接ln -s ../genromfs-0.5.1.tar.gz ./hello"></a>创建链接<code>ln -s ../genromfs-0.5.1.tar.gz ./hello</code></h3><h3 id="gzip压缩解压"><a href="#gzip压缩解压" class="headerlink" title="gzip压缩解压"></a>gzip压缩解压</h3><ul><li>自动识别</li><li><code>-c</code> 将输出信息输出保留源文件</li><li><code>-d</code> 将压缩文件解压，但是不能压缩目录</li><li><code>-l</code> 显示详细信息</li><li><code>-r</code> 查找指定目录压缩或解压缩里边所有文件</li><li><code>-t</code> 测试，检查压缩文件是否完整</li><li><code>-v</code> 对每一个压缩或者解压的文件显示文件名和压缩比</li></ul><h3 id="对文件目录进行打包和解包tar"><a href="#对文件目录进行打包和解包tar" class="headerlink" title="对文件目录进行打包和解包tar"></a>对文件目录进行打包和解包<code>tar</code></h3><ul><li><code>tar [选项] [打包后文件名] 文件目录列表</code></li><li><code>-c</code> 建立新的打包文件</li><li><code>-r</code> 向打包文件末尾追加文件</li><li><code>-x</code> 从打包文件中解出文件</li><li><code>-o</code> 将文件解开到标准输出</li><li><code>-v</code> 显示处理过程中相关信息</li><li><code>-f</code> 对普通文件操作</li><li><code>-z</code> 调用gzip压缩打包文件，与<code>-x</code>连用解压缩</li><li><code>-j</code> 调用bzip2压缩打包文件，与<code>-x</code>连用解压缩</li><li><code>-Z</code> 调用Compress压缩打包文件，与<code>-x</code>连用解压缩</li></ul><h3 id="查看网络状态ifconfig"><a href="#查看网络状态ifconfig" class="headerlink" title="查看网络状态ifconfig"></a>查看网络状态<code>ifconfig</code></h3><h3 id="系统服务命令chkconfig-list"><a href="#系统服务命令chkconfig-list" class="headerlink" title="系统服务命令chkconfig --list"></a>系统服务命令<code>chkconfig --list</code></h3><ul><li>查看指定命令 <code>chkconfig --list|grep ntpd</code></li><li>操作指定服务 <code>chkconfig --level 3 ntpd on</code></li></ul><h3 id="查看当前文件夹pwd"><a href="#查看当前文件夹pwd" class="headerlink" title="查看当前文件夹pwd"></a>查看当前文件夹<code>pwd</code></h3><h3 id="查看所有端口占用情况"><a href="#查看所有端口占用情况" class="headerlink" title="查看所有端口占用情况"></a>查看所有端口占用情况</h3><p><code>netstat -ntlp</code></p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>touch</code></p><h3 id="查看-5000端口占用程序"><a href="#查看-5000端口占用程序" class="headerlink" title="查看 5000端口占用程序"></a>查看 5000端口占用程序</h3><p><code>sudo lsof -i:5000</code></p><h3 id="停止进程"><a href="#停止进程" class="headerlink" title="停止进程"></a>停止进程</h3><p><code>sudo kill (PID)</code></p><h3 id="下载到当前文件夹"><a href="#下载到当前文件夹" class="headerlink" title="下载到当前文件夹"></a>下载到当前文件夹</h3><p><code>wget&quot;&lt;url&gt;&quot;</code></p><h3 id="下载到-home-omio-Desktop"><a href="#下载到-home-omio-Desktop" class="headerlink" title="下载到 /home/omio/Desktop"></a>下载到 /home/omio/Desktop</h3><p><code>wget -P /home/omio/Desktop/&quot;&lt;url&gt;&quot;</code></p><h3 id="下载并重命名为NewFileName"><a href="#下载并重命名为NewFileName" class="headerlink" title="下载并重命名为NewFileName"></a>下载并重命名为NewFileName</h3><p><code>wget -O /home/omio/Desktop/NewFileName&quot;&lt;url&gt;&quot;</code></p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>zip -r archive_name.zip directory_to_compress</code></p><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><p><code>unzip archive_name.zip</code></p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p><code>tar -cvf archive_name.tar directory_to_compress</code></p><h3 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h3><p><code>tar -xvf archive_name.tar.gz</code></p><h3 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf archive_name.tar.gz directory_to_compress</code></p><h3 id="解压缩-1"><a href="#解压缩-1" class="headerlink" title="解压缩"></a>解压缩</h3><p><code>tar -zxvf archive_name.tar.gz</code></p><p><code>tar -zxvf archive_name.tar.gz -C /tmp/extract_here/</code></p><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p><code>mv fromfile tofile</code></p><ul><li>如把文件a.txt得命名为b.txt，可以是mv a.txt b.txt。</li></ul><h3 id="删除一个空目录"><a href="#删除一个空目录" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h3><p><code>rm -d 目录名</code></p><h3 id="删除一个空目录-1"><a href="#删除一个空目录-1" class="headerlink" title="删除一个空目录"></a>删除一个空目录</h3><p><code>rm -dir 目录名</code></p><h3 id="删除一个非空目录"><a href="#删除一个非空目录" class="headerlink" title="删除一个非空目录"></a>删除一个非空目录</h3><p><code>rm -r 目录名</code></p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p><code>rm 文件名</code></p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p><a href="'https://blog.csdn.net/slwhy/article/details/78876237'">链接</a></p><ul><li>sudo chmod o+rwx /usr/local/bin/sunny</li></ul>]]></content>
    
    
    <categories>
      
      <category>系统</category>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>system</tag>
      
      <tag>linux</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask 简单安装和部署</title>
    <link href="undefined2019/11/flask/"/>
    <url>2019/11/flask/</url>
    
    <content type="html"><![CDATA[<h1 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h1><p>安装venv</p><p><code>python3 -m venv venv</code></p><p>启动venv</p><p><code>. venv/bin/activate</code></p><p>关闭venv</p><p><code>deactivate</code> </p><p>查看现在已经安装的依赖</p><p><code>pip3 list</code></p><p>更新pip</p><p><code>pip install --upgrade pip</code></p><p>安装Flask</p><p><code>pip install Flask</code></p><p>安装最新的flask</p><p><code>pip install -U https://github.com/pallets/flask/archive/master.tar.gz</code></p><p>安装pymongo</p><p><code>pip install pymongo</code></p><p>安装requests</p><p><code>pip install requests</code></p><p>安装payjs</p><p><code>pip install payjs</code></p><p>设置全局变量</p><p><code>export FLASK_APP=qrcode.py</code></p><p><code>export FLASK_ENV=development</code></p><p>启动</p><p><code>flask run --host=0.0.0.0</code></p><p>在虚拟环境下安装gunicorn </p><p><code>pip install gunicorn</code></p><p>添加配置文件 gunicorn.conf.py</p><pre><code># 并行工作线程数workers = 4# 监听内网端口5000【按需要更改】bind = &#39;127.0.0.1:5000&#39;# 设置守护进程【关闭连接时，程序仍在运行】daemon = True# 设置超时时间120s，默认为30s。按自己的需求进行设置timeout = 120# 设置访问日志和错误信息日志路径# accesslog = &#39;./logs/acess.log&#39;# errorlog = &#39;./logs/error.log&#39;# 自动重启autostart = ture</code></pre><p>启动gunicorn</p><p><code>gunicorn qrcode:app -c gunicorn.conf.py</code></p><p>查询gunicorn</p><p><code>pstree -ap|grep gunicorn</code></p><p>停止进程</p><p><code>kill (pid)</code></p><hr><p>在路由中</p><ol><li>同时有user/ 和 user 优先解释 user/</li><li>只有 user 的情况下 访问user/会报404</li><li>只有 user/ 的情况下 访问user会被重定向</li></ol>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>flask</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>flask</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2019/11/hello-world/"/>
    <url>2019/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><pre><code class="html">&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;nLbPI5Gbnr&quot; /&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>quickStart</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>