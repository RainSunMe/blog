---
title: 绿宝书学习笔记7
tags: [js, 基础, 绿宝书]
categories: [语言, js]
index_img: /img/green-title.png
banner_img: /img/dandelion.png
date: 2020-07-17 08:00:00
---
# 写在前边
早安！今天是第八天，希望我能一直坚持到看完这本书，祝我们变得更强！
### 3.4.3 构造对象系统的方法
JS的原型继承并不是唯一构造系统的方法，由语言提供的、原生支持的方法还包括类抄写、类继承、以及直接创建对象等，其他可以在ECMAScript语言基础上拓展的方法包括元继承、元类继承等
#### 3.4.3.1 类抄写
子类的构造逻辑：先向父类传入this引用以抄写父类方法，再向子类传入this引用抄写子类方法，后者覆盖前者的同名成员。整个构造过程都是在不断的从“类构造器”向this引用抄写成员，所以被称为类抄写

这种方法也有好处。由于这种方法是通过不断修改实例（this）的成员来得到对象的，因此所有的属性都在实例（this）的自有属性表中，进一步的推论是访问任何成员都不必回溯原型链，因而效率更高

类抄写的第二个问题是系统并不维护原型继承链。因此在类抄写构建的系统中，不能用`instanceof`来检测继承关系

#### 3.4.3.2 原型继承
存在缺陷；
* 在维护构造器引用和外部原型链之间无法平衡
* 没有提供调用父类方法的机制
  
还是一个典型的时间换空间的方案：继承层次中临近的成员访问更快，而试图访问一个不存在的成员耗时最久

#### 3.4.3.3 类继承

类继承是对原型继承的增强，也是一种再实现

从纯粹概念上说，“原型也是对象实例”是一个极为关键的性质，这是它与类继承体系本质上的不同，对于类继承来说，类不必是对象，因此类也不必具有对象的性质，类可以是一个内存块，也可以是一段描述文本，而不必是一个有对象特性的结构

* 类的实例是创建自基类的
* 类构造方法的调用顺序是逆向的

#### 3.4.3.4 直接创建对象
脱离传统的new运算直接创建对象，是对原型继承模型的简化

无论是经典的原型继承还是class来声明的类继承，都会用new运算调用一次构造器函数，“构造”这一过程既包括对原型链的维护，也包括对新实例的修饰——甚至可以使用`Reflect.construct()`来代替`new`运算，以便更加细致的控制构造过程中`new.target`和所创建实例的`constructor`的值。

new运算的可替代性，让我们注意到一个事实，所谓原型继承，其本质只是“复制原型“，即以原型为模板复制一个新的对象，构造函数与`new`运算等过程所附加的效果，其实对复制原型来说是无意义的

其构造器函数对实例的这种修饰作用——对于原型继承来说——可有可无。于是就出现了`Object.create`这样的一种简单的方法，它将”构造器函数“从对象创建过程中赶了出去，在这种机制中，对象变成了简单的”原型继承+属性定义“，而不再需要”构造器“这样一层语义

`Object.create()`只是能避免使用构造器来设置新实例原型的一种方法。它没有了在构造器修饰对象实例的这一过程，但和class声明一样，在本质上仍然是原型继承

#### 3.4.3.5 如何选择继承的方式
类抄写与原型继承正好是互补的两种方案

* 类抄写时成员访问效率更高，但内存占用更大；而原型继承反之
* 类抄写不依赖内部原型链来维护继承关系，因此也不能通过`instanceof`来做这种检测；原型继承却维护着这种继承关系也可以用于检测

JS根本上是针对小型系统和轻量应用环境设计的，它兼具“动态、函数式、原型继承”等多种语言特性，在灵活多变的同时也带来了一种混杂的程序设计语言知识体系，其结果是易学难精，而且越是深入底层越容易感到混乱，它虽然能组织大型对象系统，但又对大型对象系统的封装和多态处理的不够，所以在大型应用中常常束手束脚，心有余而力不足，这也是ES6之后在类继承语言特性设计上所主要需要解决的问题，包括更强的封装特性，以及类静态语法注解等等

在继承方式的选择上，仍应择需而用：其一，在大型系统上必须采用类继承的思想，继承关系的确定性和支持静态语法检测等特性，可以帮助开发者最终简化构建大型系统开发和业务逻辑的实现，并提供足够的系统稳定性，=；其二，在小型结构或者体系的局部使用原型继承的思路，既可以有优美的实现和高效的性质，也可以深入地理解JavaScript中混合不同语言特性的精髓

